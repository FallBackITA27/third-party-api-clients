//! A fully generated, opinionated API client library for GitHub.
//!
//! This library is generated from the [GitHub OpenAPI
//! specs](https://github.com/github/rest-api-description). This way it will remain
//! up to date as features are added. The documentation for the crate is generated
//! along with the code to make this library easy to use.
//!
//! To install the library, add the following to your `Cargo.toml` file.
//!
//! [dependencies]
//! github_api_client = "0.1.0"
//!
//!
//! ## Basic example
//!
//! Typical use will require intializing a `Client`. This requires
//! a user agent string and set of `auth::Credentials`.
//!
//! ```
//! use github_api_client::{auth::Credentials, Client};
//!
//! let github = Client::new(
//!   String::from("user-agent-name"),
//!   Credentials::Token(
//!     String::from("personal-access-token")
//!   ),
//! );
//! ```
//!
//! If you are a GitHub enterprise customer, you will want to create a client with the
//! [Client#host](struct.Client.html#method.host) method.
//!
//! ## Feature flags
//!
//! ### httpcache
//!
//! Github supports conditional HTTP requests using etags to checksum responses
//! Experimental support for utilizing this to cache responses locally with the
//! `httpcache` feature flag.
//!
//! To enable this, add the following to your `Cargo.toml` file:
//!
//! ```toml
//! [dependencies]
//! github_api_client = { version = "0.1.0", features = ["httpcache"] }
//! ```
//!
//! Then use the `Client::custom` constructor to provide a cache implementation.
//!
//! Here is an example:
//!
//! ```
//! use github_api_client::{auth::Credentials, Client};
//! #[cfg(feature = "httpcache")]
//! use github_api_client::http_cache::HttpCache;
//!
//! #[cfg(feature = "httpcache")]
//! let http_cache = HttpCache::in_home_dir();
//!
//! #[cfg(not(feature = "httpcache"))]
//! let github = Client::custom(
//!     "https://api.github.com",
//!     concat!(env!("CARGO_PKG_NAME"), "/", env!("CARGO_PKG_VERSION")),
//!     Credentials::Token(
//!       String::from("personal-access-token")
//!     ),
//!     reqwest::Client::builder().build().unwrap(),
//! );
//!
//! #[cfg(feature = "httpcache")]
//! let github = Client::custom(
//!     "https://api.github.com",
//!     concat!(env!("CARGO_PKG_NAME"), "/", env!("CARGO_PKG_VERSION")),
//!     Credentials::Token(
//!       String::from("personal-access-token")
//!     ),
//!     reqwest::Client::builder().build().unwrap(),
//!     http_cache
//! );
//! ```
//! ## Authenticating GitHub apps
//!
//! You can also authenticate via a GitHub app.
//!
//! Here is an example:
//!
//! ```rust
//! use std::env;
//!
//! use github_api_client::{Client, auth::{Credentials, InstallationTokenGenerator, JWTCredentials}};
//! #[cfg(feature = "httpcache")]
//! use github_api_client::http_cache::FileBasedCache;
//!
//! let app_id_str = env::var("GH_APP_ID").unwrap();
//! let app_id = app_id_str.parse::<u64>().unwrap();
//!
//! let app_installation_id_str = env::var("GH_INSTALLATION_ID").unwrap();
//! let app_installation_id = app_installation_id_str.parse::<u64>().unwrap();
//!
//! let encoded_private_key = env::var("GH_PRIVATE_KEY").unwrap();
//! let private_key = base64::decode(encoded_private_key).unwrap();
//!
//! // Decode the key.
//! let key = nom_pem::decode_block(&private_key).unwrap();
//!
//! // Get the JWT credentials.
//! let jwt = JWTCredentials::new(app_id, key.data).unwrap();
//!
//! #[cfg(feature = "httpcache")]
//! {
//!     // Create the HTTP cache.
//!     let mut dir = dirs::home_dir().expect("Expected a home dir");
//!     dir.push(".cache/github");
//!     let http_cache = Box::new(FileBasedCache::new(dir));
//! }
//!
//! let token_generator = InstallationTokenGenerator::new(app_installation_id, jwt);
//!
//! #[cfg(not(feature = "httpcache"))]
//! let github = Client::custom(
//!     "https://api.github.com",
//!     concat!(env!("CARGO_PKG_NAME"), "/", env!("CARGO_PKG_VERSION")),
//!     Credentials::InstallationToken(token_generator),
//!     reqwest::Client::builder().build().unwrap(),
//! );
//!
//! #[cfg(feature = "httpcache")]
//! let github = Client::custom(
//!     "https://api.github.com",
//!     concat!(env!("CARGO_PKG_NAME"), "/", env!("CARGO_PKG_VERSION")),
//!     Credentials::InstallationToken(token_generator),
//!     reqwest::Client::builder().build().unwrap(),
//!     http_cache,
//! );
//! ```
//!
//! ## Acknowledgements
//!
//! Shout out to [hubcaps](https://github.com/softprops/hubcaps) for paving the
//! way here. This extends that effort in a generated way so the library is
//! always up to the date with the OpenAPI spec and no longer requires manual
//! contributions to add new endpoints.
//!
#![feature(async_stream)]
#![allow(clippy::too_many_arguments)]
#![allow(missing_docs)]

pub mod auth;
#[cfg(feature = "httpcache")]
pub mod http_cache;
#[doc(hidden)]
pub mod utils;

use anyhow::{anyhow, Error, Result};
use async_recursion::async_recursion;
use chrono::{DateTime, Utc};

const DEFAULT_HOST: &str = "https://api.github.com";

mod progenitor_support {
    use percent_encoding::{utf8_percent_encode, AsciiSet, CONTROLS};

    const PATH_SET: &AsciiSet = &CONTROLS
        .add(b' ')
        .add(b'"')
        .add(b'#')
        .add(b'<')
        .add(b'>')
        .add(b'?')
        .add(b'`')
        .add(b'{')
        .add(b'}');

    pub(crate) fn encode_path(pc: &str) -> String {
        utf8_percent_encode(pc, PATH_SET).to_string()
    }
}

/// The data types sent to and returned from the API client.
pub mod types {
    use chrono::{DateTime, NaiveDate, Utc};
    use schemars::JsonSchema;
    use serde::{Deserialize, Serialize};

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SimpleUser {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Owner {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Permissions {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub checks: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub metadata: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Integration {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_secret: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub installations_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub owner: Owner,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pem: String,
        pub permissions: Permissions,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub webhook_secret: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BasicError {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ValidationErrorSimple {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub errors: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct WebhookConfig {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Enterprise {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub website_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AppPermissions {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub actions: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub administration: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub checks: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_references: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environments: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub metadata: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_administration: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_hooks: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_packages: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_plan: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_projects: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_secrets: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_self_hosted_runners: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_user_blocking: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub packages: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pages: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pull_requests: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_hooks: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_projects: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret_scanning_alerts: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secrets: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub security_events: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub single_file: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub team_discussions: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vulnerability_alerts: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub workflows: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Account {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SuspendedBy {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Installation {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub access_tokens_url: String,
        pub account: Account,
        pub app_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub app_slug: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contact_email: String,
        pub created_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_multiple_single_files: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        pub permissions: AppPermissions,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_selection: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub single_file_name: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub single_file_paths: Vec<String>,
        pub suspended_at: DateTime<Utc>,
        pub suspended_by: SuspendedBy,
        pub target_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_type: String,
        pub updated_at: DateTime<Utc>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LicenseSimple {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub spdx_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct License {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub spdx_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Organization {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RepositoryPermissions {
        pub admin: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maintain: Option<bool>,
        pub pull: bool,
        pub push: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub triage: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RepositoryTemplateRepositoryTemplateRepositoryOwner {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub site_admin: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RepositoryTemplateRepositoryTemplateRepositoryPermissions {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub admin: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pull: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub push: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TemplateRepository {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub archived: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub disabled: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fork: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub forks_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_downloads: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_issues: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_projects: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_wiki: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub network_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub open_issues_count: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owner: Option<Owner>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<Permissions>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pushed_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub size: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub stargazers_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subscribers_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub updated_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub watchers_count: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Repository {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        pub archived: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub disabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        pub fork: bool,
        pub forks: i64,
        pub forks_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        pub has_downloads: bool,
        pub has_issues: bool,
        pub has_pages: bool,
        pub has_projects: bool,
        pub has_wiki: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        pub license: License,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub master_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub network_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        pub open_issues: i64,
        pub open_issues_count: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization: Option<Organization>,
        pub owner: Owner,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<Permissions>,
        pub private: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        pub pushed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        pub stargazers_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subscribers_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub template_repository: Option<TemplateRepository>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
        pub watchers: i64,
        pub watchers_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct InstallationToken {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub expires_at: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_multiple_single_files: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<AppPermissions>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<Repository>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_selection: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub single_file: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub single_file_paths: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Errors {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub code: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub field: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub index: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub resource: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ValidationError {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub errors: Vec<Errors>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct App {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct User {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ApplicationGrant {
        pub app: App,
        pub created_at: DateTime<Utc>,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub scopes: Vec<String>,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub user: Option<User>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScopedInstallation {
        pub account: SimpleUser,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_multiple_single_files: Option<bool>,
        pub permissions: AppPermissions,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_selection: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub single_file_name: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub single_file_paths: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AuthorizationInstallation {
        pub account: SimpleUser,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_multiple_single_files: Option<bool>,
        pub permissions: AppPermissions,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_selection: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub single_file_name: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub single_file_paths: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Authorization {
        pub app: App,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub fingerprint: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hashed_token: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub installation: Option<Installation>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub scopes: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token_last_eight: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub user: Option<User>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeofConduct {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsEnterprisePermissions {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub allowed_actions: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub enabled_organizations: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_actions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_organizations_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrganizationSimple {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub public_members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SelectedActions {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub github_owned_allowed: Option<bool>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub patterns_allowed: Vec<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub verified_allowed: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RunnerGroupsEnterprise {
        pub allows_public_repositories: bool,
        pub default: bool,
        pub id: f64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub runners_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Labels {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Runner {
        pub busy: bool,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<Labels>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub os: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RunnerApplication {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub architecture: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub filename: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub os: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha_256_checksum: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_download_token: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AuthenticationTokenPermissions {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AuthenticationToken {
        pub expires_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<Permissions>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<Repository>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_selection: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub single_file: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActorLocation {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub country_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Data {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AuditLogEvent {
        #[serde(
            default,
            skip_serializing_if = "Option::is_none",
            rename = "@timestamp"
        )]
        pub timestamp: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub document_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub action: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active_was: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub actor: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub actor_id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub actor_location: Option<ActorLocation>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blocked_user: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub business: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub config: Option<serde_json::Value>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub config_was: Option<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created_at: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub data: Option<Data>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deploy_key_fingerprint: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub emoji: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub events: Option<serde_json::Value>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub events_were: Option<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub explanation: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub fingerprint: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hook_id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub limited_availability: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub old_user: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub openssh_public_key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub org: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub org_id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub previous_visibility: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub read_only: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repo: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository_public: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub team: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub transport_protocol: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub transport_protocol_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MinutesUsedBreakdown {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub macos: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ubuntu: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub windows: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsBillingUsage {
        pub included_minutes: i64,
        pub minutes_used_breakdown: MinutesUsedBreakdown,
        pub total_minutes_used: i64,
        pub total_paid_minutes_used: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PackagesBillingUsage {
        pub included_gigabytes_bandwidth: i64,
        pub total_gigabytes_bandwidth_used: i64,
        pub total_paid_gigabytes_bandwidth_used: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CombinedBillingUsage {
        pub days_left_in_billing_cycle: i64,
        pub estimated_paid_storage_for_month: i64,
        pub estimated_storage_for_month: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Actor {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Label {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        pub default: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Creator {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Milestone {
        pub closed_at: DateTime<Utc>,
        pub closed_issues: i64,
        pub created_at: DateTime<Utc>,
        pub creator: Creator,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub due_on: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub number: i64,
        pub open_issues: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Assignee {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub diff_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub merged_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub patch_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PerformedviaGithubApp {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_secret: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub installations_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub owner: Owner,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pem: String,
        pub permissions: Permissions,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub webhook_secret: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueSimple {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub active_lock_reason: String,
        pub assignee: Assignee,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<SimpleUser>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub author_association: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        pub closed_at: DateTime<Utc>,
        pub comments: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<Label>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        pub locked: bool,
        pub milestone: Milestone,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<PerformedviaGithubApp>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pull_request: Option<PullRequest>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository: Option<Repository>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub timeline_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReactionRollup {
        #[serde(rename = "+1")]
        pub plus_one: i64,
        #[serde(rename = "-1")]
        pub minus_one: i64,
        pub confused: i64,
        pub eyes: i64,
        pub heart: i64,
        pub hooray: i64,
        pub laugh: i64,
        pub rocket: i64,
        pub total_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueComment {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub author_association: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<PerformedviaGithubApp>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Repo {
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Pages {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub action: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub page_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub summary: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Payload {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub action: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub comment: Option<IssueComment>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub issue: Option<IssueSimple>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub pages: Vec<Pages>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Event {
        pub actor: Actor,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub org: Option<Actor>,
        pub payload: Payload,
        pub public: bool,
        pub repo: Repo,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LinkWithType {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub href: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Links {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub current_user: Option<LinkWithType>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub current_user_actor: Option<LinkWithType>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub current_user_organization: Option<LinkWithType>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub current_user_organizations: Vec<LinkWithType>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub current_user_public: Option<LinkWithType>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub security_advisories: Option<LinkWithType>,
        pub timeline: LinkWithType,
        pub user: LinkWithType,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Feed {
        pub links: Links,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub current_user_actor_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub current_user_organization_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub current_user_organization_urls: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub current_user_public_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub current_user_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub security_advisories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub timeline_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Files {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BaseGist {
        pub comments: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub files: Files,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub forks: Vec<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_pull_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_push_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub history: Vec<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owner: Option<Owner>,
        pub public: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub truncated: Option<bool>,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Plan {
        pub collaborators: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        pub private_repos: i64,
        pub space: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PublicUser {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub bio: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blog: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub collaborators: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub company: String,
        pub created_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub disk_usage: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        pub followers: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        pub following: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        pub hireable: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owned_private_repos: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub plan: Option<Plan>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private_gists: Option<i64>,
        pub public_gists: i64,
        pub public_repos: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub suspended_at: Option<DateTime<Utc>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_private_repos: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub twitter_username: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ChangeStatus {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub additions: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deletions: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GistHistory {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_status: Option<ChangeStatus>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub committed_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub user: Option<SimpleUser>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub version: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Forks {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub updated_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub user: Option<PublicUser>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ForkOf {
        pub comments: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub files: Files,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub forks: Vec<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_pull_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_push_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub history: Vec<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owner: Option<Owner>,
        pub public: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub truncated: Option<bool>,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GistSimple {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub comments: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub files: Option<Files>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fork_of: Option<ForkOf>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub forks: Vec<Forks>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_pull_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_push_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub history: Vec<GistHistory>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owner: Option<SimpleUser>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub public: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub truncated: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub updated_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GistComment {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub author_association: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        pub created_at: DateTime<Utc>,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GistCommit {
        pub change_status: ChangeStatus,
        pub committed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub user: User,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub version: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitignoreTemplate {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub source: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ClosedBy {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Issue {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub active_lock_reason: String,
        pub assignee: Assignee,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<SimpleUser>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub author_association: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        pub closed_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub closed_by: Option<ClosedBy>,
        pub comments: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<Labels>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        pub locked: bool,
        pub milestone: Milestone,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<PerformedviaGithubApp>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pull_request: Option<PullRequest>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository: Option<Repository>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub timeline_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LicenseData {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub conditions: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub featured: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub implementation: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub limitations: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub permissions: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub spdx_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MarketplaceListingPlan {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub accounts_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub bullets: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub has_free_trial: bool,
        pub id: i64,
        pub monthly_price_in_cents: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        pub number: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub price_model: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub unit_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub yearly_price_in_cents: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MarketplacePendingChange {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub effective_date: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_installed: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub plan: Option<MarketplaceListingPlan>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub unit_count: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MarketplacePurchase {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub billing_cycle: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub free_trial_ends_on: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_installed: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub next_billing_date: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub on_free_trial: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub plan: Option<MarketplaceListingPlan>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub unit_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub updated_at: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MarketplacePurchaseData {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub marketplace_pending_change: Option<MarketplacePendingChange>,
        pub marketplace_purchase: MarketplacePurchase,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_billing_email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SshKeyFingerprints {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha256_dsa: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha256_rsa: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ApiOverview {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub actions: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub api: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub dependabot: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub git: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub hooks: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub importer: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub packages: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub pages: Vec<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ssh_key_fingerprints: Option<SshKeyFingerprints>,
        pub verifiable_password_authentication: bool,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub web: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MinimalRepositoryOwner {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MinimalRepositoryPermissions {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub admin: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maintain: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pull: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub push: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub triage: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MinimalRepositoryTemplateRepository {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MinimalRepositoryLicense {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub spdx_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MinimalRepository {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub archived: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub code_of_conduct: Option<CodeofConduct>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub disabled: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        pub fork: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub forks: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub forks_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_downloads: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_issues: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_projects: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_wiki: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub license: Option<License>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub network_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub open_issues: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub open_issues_count: Option<i64>,
        pub owner: Owner,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<Permissions>,
        pub private: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pushed_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub size: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub stargazers_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subscribers_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub template_repository: Option<TemplateRepository>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub updated_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub watchers: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub watchers_count: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Subject {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub latest_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Thread {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub last_read_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub reason: String,
        pub repository: MinimalRepository,
        pub subject: Subject,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        pub unread: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub updated_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ThreadSubscription {
        pub created_at: DateTime<Utc>,
        pub ignored: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub reason: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        pub subscribed: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub thread_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrganizationFullPlan {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub filled_seats: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        pub private_repos: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub seats: Option<i64>,
        pub space: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrganizationFull {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub billing_email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blog: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub collaborators: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub company: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_repository_permission: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub disk_usage: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        pub followers: i64,
        pub following: i64,
        pub has_organization_projects: bool,
        pub has_repository_projects: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_verified: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_allowed_repository_creation_type: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_internal_repositories: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_private_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_private_repositories: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_public_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_public_repositories: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_repositories: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owned_private_repos: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub plan: Option<Plan>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private_gists: Option<i64>,
        pub public_gists: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub public_members_url: String,
        pub public_repos: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_private_repos: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub twitter_username: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub two_factor_requirement_enabled: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsOrganizationPermissions {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub allowed_actions: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub enabled_repositories: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_actions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_repositories_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RunnerGroupsOrg {
        pub allows_public_repositories: bool,
        pub default: bool,
        pub id: f64,
        pub inherited: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub inherited_allows_public_repositories: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub runners_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrganizationActionsSecret {
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_repositories_url: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsPublicKey {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EmptyObject {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CredentialAuthorization {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub authorized_credential_id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub authorized_credential_note: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub authorized_credential_title: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub credential_accessed_at: Option<DateTime<Utc>>,
        pub credential_authorized_at: DateTime<Utc>,
        pub credential_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub credential_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub fingerprint: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub scopes: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token_last_eight: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrganizationInvitation {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub failed_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub failed_reason: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub invitation_teams_url: String,
        pub inviter: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub role: String,
        pub team_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Config {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrgHook {
        pub active: bool,
        pub config: Config,
        pub created_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ping_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct InteractionLimitResponse {
        pub expires_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub limit: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub origin: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct InteractionLimit {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub expiry: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub limit: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamSimple {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ldap_dn: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub privacy: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamPermissions {
        pub admin: bool,
        pub maintain: bool,
        pub pull: bool,
        pub push: bool,
        pub triage: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Parent {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ldap_dn: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub privacy: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Team {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub parent: Parent,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<Permissions>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub privacy: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrgMembershipPermissions {
        pub can_create_repository: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct OrgMembership {
        pub organization: OrganizationSimple,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<Permissions>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub role: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Migration {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub exclude: Vec<serde_json::Value>,
        pub exclude_attachments: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub guid: String,
        pub id: i64,
        pub lock_repositories: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub owner: Owner,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<Repository>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PackageRepository {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub archived: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub code_of_conduct: Option<CodeofConduct>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub disabled: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        pub fork: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub forks: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub forks_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_downloads: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_issues: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_projects: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_wiki: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub license: Option<License>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub network_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub open_issues: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub open_issues_count: Option<i64>,
        pub owner: Owner,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<Permissions>,
        pub private: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pushed_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub size: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub stargazers_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subscribers_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub template_repository: Option<TemplateRepository>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub updated_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub watchers: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub watchers_count: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Package {
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owner: Option<Owner>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub package_type: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository: Option<Repository>,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub version_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Container {
        pub tags: serde_json::Value,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Docker {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub tag: Option<serde_json::Value>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Metadata {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub container: Option<Container>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub docker: Option<Docker>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub package_type: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PackageVersion {
        pub created_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deleted_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub license: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub metadata: Option<Metadata>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub package_html_url: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Project {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub columns_url: String,
        pub created_at: DateTime<Utc>,
        pub creator: Creator,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub number: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_permission: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub owner_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Groups {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub group_description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub group_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub group_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub synced_at: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GroupMapping {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<Groups>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamFull {
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ldap_dn: String,
        pub members_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub organization: OrganizationFull,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent: Option<Parent>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub privacy: String,
        pub repos_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Author {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamDiscussion {
        pub author: Author,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_version: String,
        pub comments_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub last_edited_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub number: i64,
        pub pinned: bool,
        pub private: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub team_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamDiscussionComment {
        pub author: Author,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_version: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub discussion_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub last_edited_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Reaction {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        pub created_at: DateTime<Utc>,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamMembership {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub role: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamProjectPermissions {
        pub admin: bool,
        pub read: bool,
        pub write: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamProject {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub columns_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        pub creator: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub number: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_permission: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub owner_url: String,
        pub permissions: Permissions,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub updated_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamRepositoryPermissions {
        pub admin: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maintain: Option<bool>,
        pub pull: bool,
        pub push: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub triage: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamRepositoryTemplateRepository {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TeamRepository {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        pub archived: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub disabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        pub fork: bool,
        pub forks: i64,
        pub forks_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        pub has_downloads: bool,
        pub has_issues: bool,
        pub has_pages: bool,
        pub has_projects: bool,
        pub has_wiki: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        pub license: License,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub master_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub network_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        pub open_issues: i64,
        pub open_issues_count: i64,
        pub owner: Owner,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<Permissions>,
        pub private: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        pub pushed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        pub stargazers_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subscribers_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub template_repository: Option<TemplateRepository>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
        pub watchers: i64,
        pub watchers_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProjectCard {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub archived: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub column_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub column_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_url: String,
        pub created_at: DateTime<Utc>,
        pub creator: Creator,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub project_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub project_url: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProjectColumn {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub cards_url: String,
        pub created_at: DateTime<Utc>,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub project_url: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RepositoryCollaboratorPermission {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RateLimit {
        pub limit: i64,
        pub remaining: i64,
        pub reset: i64,
        pub used: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Resources {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub code_scanning_upload: Option<RateLimit>,
        pub core: RateLimit,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub graphql: Option<RateLimit>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub integration_manifest: Option<RateLimit>,
        pub search: RateLimit,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub source_import: Option<RateLimit>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RateLimitOverview {
        pub rate: RateLimit,
        pub resources: Resources,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeofConductSimple {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FullRepositoryPermissions {
        pub admin: bool,
        pub pull: bool,
        pub push: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FullRepositoryTemplateRepository {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AdvancedSecurity {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SecretScanning {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SecurityandAnalysis {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub advanced_security: Option<AdvancedSecurity>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub secret_scanning: Option<SecretScanning>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FullRepository {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub anonymous_access_enabled: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        pub archived: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub code_of_conduct: Option<CodeofConductSimple>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub disabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        pub fork: bool,
        pub forks: i64,
        pub forks_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        pub has_downloads: bool,
        pub has_issues: bool,
        pub has_pages: bool,
        pub has_projects: bool,
        pub has_wiki: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        pub license: License,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub master_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        pub network_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        pub open_issues: i64,
        pub open_issues_count: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization: Option<Organization>,
        pub owner: SimpleUser,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent: Option<Repository>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<Permissions>,
        pub private: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        pub pushed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub security_and_analysis: Option<SecurityandAnalysis>,
        pub size: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub source: Option<Repository>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        pub stargazers_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        pub subscribers_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub template_repository: Option<TemplateRepository>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
        pub watchers: i64,
        pub watchers_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Artifact {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_download_url: String,
        pub created_at: DateTime<Utc>,
        pub expired: bool,
        pub expires_at: DateTime<Utc>,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub size_in_bytes: i64,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Steps {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub completed_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub conclusion: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        pub number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub started_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Job {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub check_run_url: String,
        pub completed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub conclusion: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub run_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub run_url: String,
        pub started_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub steps: Vec<Steps>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsRepositoryPermissions {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub allowed_actions: String,
        pub enabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub selected_actions_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Head {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        pub repo: Repo,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Base {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        pub repo: Repo,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestMinimal {
        pub base: Base,
        pub head: Head,
        pub id: i64,
        pub number: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SimpleCommitAuthor {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Committer {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SimpleCommit {
        pub author: Author,
        pub committer: Committer,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        pub timestamp: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tree_id: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct HeadCommit {
        pub author: Author,
        pub committer: Committer,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        pub timestamp: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tree_id: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct WorkflowRun {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub artifacts_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub cancel_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub check_suite_id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub check_suite_node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub check_suite_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub conclusion: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_branch: String,
        pub head_commit: HeadCommit,
        pub head_repository: MinimalRepository,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub head_repository_id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub jobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub logs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub pull_requests: Vec<PullRequestMinimal>,
        pub repository: MinimalRepository,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub rerun_url: String,
        pub run_number: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub workflow_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub workflow_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Environments {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub updated_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnvironmentApprovals {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comment: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub environments: Vec<Environments>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        pub user: SimpleUser,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Environment {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Reviewer {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Reviewers {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reviewer: Option<Reviewer>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PendingDeployment {
        pub current_user_can_approve: bool,
        pub environment: Environment,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub reviewers: Vec<Reviewers>,
        pub wait_timer: i64,
        pub wait_timer_started_at: DateTime<Utc>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PayloadData {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Deployment {
        pub created_at: DateTime<Utc>,
        pub creator: Creator,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub original_environment: String,
        pub payload: Payload,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<PerformedviaGithubApp>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub production_environment: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub task: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub transient_environment: Option<bool>,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Ubuntu {
        pub jobs: i64,
        pub total_ms: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Macos {
        pub jobs: i64,
        pub total_ms: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Windows {
        pub jobs: i64,
        pub total_ms: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Billable {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub macos: Option<Macos>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ubuntu: Option<Ubuntu>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub windows: Option<Windows>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct WorkflowRunUsage {
        pub billable: Billable,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub run_duration_ms: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ActionsSecret {
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        pub updated_at: DateTime<Utc>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Workflow {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub badge_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deleted_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct WorkflowUsageBillableBillableUbuntu {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_ms: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct WorkflowUsageBillableBillableMacos {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_ms: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct WorkflowUsageBillableBillableWindows {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_ms: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct WorkflowUsage {
        pub billable: Billable,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProtectedBranchAdminEnforced {
        pub enabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DismissalRestrictions {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<Team>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<SimpleUser>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub users_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProtectedBranchPullRequestReview {
        pub dismiss_stale_reviews: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismissal_restrictions: Option<DismissalRestrictions>,
        pub require_code_owner_reviews: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_approving_review_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Users {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub site_admin: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Teams {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub parent: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub privacy: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BranchRestrictionPolicyAppsAppsOwner {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub public_members_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub site_admin: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BranchRestrictionPolicyAppsAppsPermissions {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub metadata: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub single_file: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Apps {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub owner: Option<Owner>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<Permissions>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub updated_at: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BranchRestrictionPolicy {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub apps: Vec<Apps>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub apps_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<Teams>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<Users>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub users_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RequiredStatusChecks {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub contexts: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contexts_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub enforcement_level: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub strict: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RequiredLinearHistory {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub enabled: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AllowForcePushes {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub enabled: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AllowDeletions {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub enabled: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RequiredConversationResolution {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub enabled: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RequiredSignatures {
        pub enabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BranchProtection {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_deletions: Option<AllowDeletions>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_force_pushes: Option<AllowForcePushes>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub enabled: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub enforce_admins: Option<ProtectedBranchAdminEnforced>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub protection_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_conversation_resolution: Option<RequiredConversationResolution>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_linear_history: Option<RequiredLinearHistory>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_pull_request_reviews: Option<ProtectedBranchPullRequestReview>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_signatures: Option<RequiredSignatures>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_status_checks: Option<RequiredStatusChecks>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub restrictions: Option<BranchRestrictionPolicy>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Commit {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ShortBranch {
        pub commit: Commit,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        pub protected: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub protection: Option<BranchProtection>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub protection_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitUser {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub date: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Verification {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub payload: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub reason: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub signature: String,
        pub verified: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitCommitCommitAuthor {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub date: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitCommitCommitCommitter {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub date: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Tree {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitCommit {
        pub author: Author,
        pub comment_count: i64,
        pub committer: Committer,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        pub tree: Tree,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub verification: Option<Verification>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitCommitter {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Parents {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Stats {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub additions: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deletions: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitFiles {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub additions: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blob_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub changes: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deletions: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub filename: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub patch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub previous_filename: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub raw_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitData {
        pub author: Author,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        pub commit: Commit,
        pub committer: Committer,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub files: Vec<Files>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub parents: Vec<Parents>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub stats: Option<Stats>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BranchWithProtectionLinks {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "self"
        )]
        pub self_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BranchWithProtection {
        pub links: Links,
        pub commit: Commit,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pattern: String,
        pub protected: bool,
        pub protection: BranchProtection,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub protection_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_approving_review_count: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct StatusCheckPolicy {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub contexts: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contexts_url: String,
        pub strict: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProtectedBranchRequiredPullRequestReviewsRequiredPullRequestReviewsDismissalRestrictions
    {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<Team>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<SimpleUser>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub users_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RequiredPullRequestReviews {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismiss_stale_reviews: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismissal_restrictions: Option<DismissalRestrictions>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub require_code_owner_reviews: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_approving_review_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnforceAdmins {
        pub enabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProtectedBranchRequiredLinearHistory {
        pub enabled: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProtectedBranchAllowForcePushes {
        pub enabled: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProtectedBranchAllowDeletions {
        pub enabled: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProtectedBranch {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_deletions: Option<AllowDeletions>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_force_pushes: Option<AllowForcePushes>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub enforce_admins: Option<EnforceAdmins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_conversation_resolution: Option<RequiredConversationResolution>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_linear_history: Option<RequiredLinearHistory>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_pull_request_reviews: Option<RequiredPullRequestReviews>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_signatures: Option<RequiredSignatures>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_status_checks: Option<StatusCheckPolicy>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub restrictions: Option<BranchRestrictionPolicy>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeploymentSimple {
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub original_environment: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<PerformedviaGithubApp>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub production_environment: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub task: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub transient_environment: Option<bool>,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Output {
        pub annotations_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub annotations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub summary: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub text: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CheckSuite {
        pub id: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CheckRunApp {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_secret: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub installations_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub owner: Owner,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pem: String,
        pub permissions: Permissions,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub webhook_secret: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CheckRun {
        pub app: App,
        pub check_suite: CheckSuite,
        pub completed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub conclusion: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deployment: Option<DeploymentSimple>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub details_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub output: Output,
        pub pull_requests: serde_json::Value,
        pub started_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CheckAnnotation {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub annotation_level: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blob_href: String,
        pub end_column: i64,
        pub end_line: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub raw_details: String,
        pub start_column: i64,
        pub start_line: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CheckSuiteApp {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_secret: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub installations_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub owner: Owner,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pem: String,
        pub permissions: Permissions,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub webhook_secret: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CheckSuiteData {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub after: String,
        pub app: App,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub before: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub check_runs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub conclusion: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_branch: String,
        pub head_commit: SimpleCommit,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_sha: String,
        pub id: i64,
        pub latest_check_runs_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub pull_requests: Vec<PullRequestMinimal>,
        pub repository: MinimalRepository,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AutoTriggerChecks {
        pub app_id: i64,
        pub setting: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Preferences {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub auto_trigger_checks: Vec<AutoTriggerChecks>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CheckSuitePreference {
        pub preferences: Preferences,
        pub repository: MinimalRepository,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAlertRuleSummary {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub severity: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAnalysisTool {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub guid: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub version: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAlertLocation {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub end_column: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub end_line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_column: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_line: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Message {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub text: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAlertInstance {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub analysis_key: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub classifications: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub location: Option<CodeScanningAlertLocation>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub message: Option<Message>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAlertItems {
        pub created_at: DateTime<Utc>,
        pub dismissed_at: DateTime<Utc>,
        pub dismissed_by: SimpleUser,
        pub dismissed_reason: serde_json::Value,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub instances_url: String,
        pub most_recent_instance: CodeScanningAlertInstance,
        pub number: i64,
        pub rule: CodeScanningAlertRuleSummary,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        pub tool: CodeScanningAnalysisTool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAlertRule {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub help: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub security_severity_level: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub severity: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub tags: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAlert {
        pub created_at: DateTime<Utc>,
        pub dismissed_at: DateTime<Utc>,
        pub dismissed_by: SimpleUser,
        pub dismissed_reason: serde_json::Value,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub instances: Option<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub instances_url: String,
        pub most_recent_instance: CodeScanningAlertInstance,
        pub number: i64,
        pub rule: CodeScanningAlertRule,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        pub tool: CodeScanningAnalysisTool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAnalysis {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub analysis_key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub category: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_sha: String,
        pub created_at: DateTime<Utc>,
        pub deletable: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub error: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        pub results_count: i64,
        pub rules_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sarif_id: String,
        pub tool: CodeScanningAnalysisTool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tool_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub warning: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningAnalysisDeletion {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub confirm_delete_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub next_analysis_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimError {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub detail: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub scim_type: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub status: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningSarifsReceipt {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeScanningSarifsStatus {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub analyses_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub processing_status: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CollaboratorPermissions {
        pub admin: bool,
        pub pull: bool,
        pub push: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Collaborator {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<Permissions>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Invitee {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Inviter {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RepositoryInvitation {
        pub created_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub expired: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        pub invitee: Invitee,
        pub inviter: Inviter,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permissions: String,
        pub repository: MinimalRepository,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitComment {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub author_association: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        pub line: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        pub position: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct BranchShort {
        pub commit: Commit,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        pub protected: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Link {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub href: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AutoMerge {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_title: String,
        pub enabled_by: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merge_method: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestSimpleLabels {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub default: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestSimpleHead {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub label: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        pub repo: Repository,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestSimpleBase {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub label: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        pub repo: Repository,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestSimpleLinks {
        pub comments: Link,
        pub commits: Link,
        pub html: Link,
        pub issue: Link,
        pub review_comment: Link,
        pub review_comments: Link,
        #[serde(rename = "self")]
        pub self_: Link,
        pub statuses: Link,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestSimple {
        pub links: Links,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub active_lock_reason: String,
        pub assignee: Assignee,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<SimpleUser>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub author_association: String,
        pub auto_merge: AutoMerge,
        pub base: Base,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        pub closed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub diff_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub draft: Option<bool>,
        pub head: Head,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<Labels>,
        pub locked: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merge_commit_sha: String,
        pub merged_at: DateTime<Utc>,
        pub milestone: Milestone,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub number: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub patch_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub requested_reviewers: Vec<SimpleUser>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub requested_teams: Vec<Team>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub review_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub review_comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SimpleCommitStatus {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub context: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_url: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CombinedCommitStatus {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        pub repository: MinimalRepository,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub statuses: Vec<SimpleCommitStatus>,
        pub total_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Status {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub context: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        pub creator: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub updated_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommunityHealthFile {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommunityProfileFilesFilesCodeofConduct {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeofConductFile {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Contributing {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Readme {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueTemplate {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestTemplate {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommunityProfileFiles {
        pub code_of_conduct: CodeofConduct,
        pub code_of_conduct_file: CodeofConductFile,
        pub contributing: Contributing,
        pub issue_template: IssueTemplate,
        pub license: License,
        pub pull_request_template: PullRequestTemplate,
        pub readme: Readme,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommunityProfile {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub content_reports_enabled: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation: String,
        pub files: Files,
        pub health_percentage: i64,
        pub updated_at: DateTime<Utc>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DiffEntry {
        pub additions: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blob_url: String,
        pub changes: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        pub deletions: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub filename: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub patch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub previous_filename: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub raw_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitComparison {
        pub ahead_by: i64,
        pub base_commit: Commit,
        pub behind_by: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub commits: Vec<Commit>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub diff_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub files: Vec<DiffEntry>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub merge_base_commit: Commit,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub patch_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permalink_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        pub total_commits: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentReferenceAttachment {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentTreeEntriesEntriesLinks {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "self"
        )]
        pub self_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Entries {
        pub links: Links,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentTreeLinks {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "self"
        )]
        pub self_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentTree {
        pub links: Links,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub entries: Vec<Entries>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentDirectoryLinks {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "self"
        )]
        pub self_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentDirectory {
        pub links: Links,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentFileLinks {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "self"
        )]
        pub self_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentFile {
        pub links: Links,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub encoding: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub submodule_git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentSymlinkLinks {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "self"
        )]
        pub self_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentSymlink {
        pub links: Links,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentSubmoduleLinks {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "self"
        )]
        pub self_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentSubmodule {
        pub links: Links,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub submodule_git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FileCommitContentContentLinks {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "self"
        )]
        pub self_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Content {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub links: Option<Links>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub size: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FileCommitCommitCommitAuthor {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub date: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FileCommitCommitCommitCommitter {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub date: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FileCommitCommitCommitTree {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FileCommitCommitCommitParents {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FileCommitCommitCommitVerification {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub payload: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub reason: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub signature: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub verified: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FileCommitCommit {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub author: Option<Author>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub committer: Option<Committer>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub parents: Vec<Parents>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub tree: Option<Tree>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub verification: Option<Verification>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct FileCommit {
        pub commit: Commit,
        pub content: Content,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Contributor {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        pub contributions: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub site_admin: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeploymentStatus {
        pub created_at: DateTime<Utc>,
        pub creator: Creator,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub log_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<PerformedviaGithubApp>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_url: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeploymentBranchPolicy {
        pub custom_branch_policies: bool,
        pub protected_branches: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProtectionRules {
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub wait_timer: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct EnvironmentData {
        pub created_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deployment_branch_policy: Option<DeploymentBranchPolicy>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub protection_rules: Vec<ProtectionRules>,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ShortBlob {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Blob {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub encoding: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub highlighted_content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCommitAuthor {
        pub date: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCommitCommitter {
        pub date: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCommitParents {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitCommit {
        pub author: Author,
        pub committer: Committer,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub parents: Vec<Parents>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        pub tree: Tree,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub verification: Verification,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Object {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitRef {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub object: Object,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Tagger {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub date: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitTag {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub object: Object,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tag: String,
        pub tagger: Tagger,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub verification: Option<Verification>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitTreeTree {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mode: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub size: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GitTree {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub tree: Vec<Tree>,
        pub truncated: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct HookResponse {
        pub code: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct HookConfig {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub digest: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub password: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub room: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subdomain: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Hook {
        pub active: bool,
        pub config: Config,
        pub created_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        pub id: i64,
        pub last_response: HookResponse,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ping_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub test_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProjectChoices {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub human_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tfvc_project: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Import {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub authors_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub authors_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub commit_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub error_message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub failed_step: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_large_files: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub import_percent: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub large_files_count: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub large_files_size: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub project_choices: Vec<ProjectChoices>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub push_percent: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status_text: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svc_root: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_root: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tfvc_project: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub use_lfs: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PorterAuthor {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub import_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub remote_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub remote_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PorterLargeFile {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub oid: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ref_name: String,
        pub size: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueEventLabel {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueEventDismissedReview {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub dismissal_commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub dismissal_message: String,
        pub review_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueEventMilestone {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueEventProjectCard {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub column_name: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub previous_column_name: String,
        pub project_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub project_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueEventRename {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub from: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub to: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueEventActor {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Assigner {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReviewRequester {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RequestedReviewer {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueEvent {
        pub actor: Actor,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub assignee: Option<Assignee>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub assigner: Option<Assigner>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub author_association: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismissed_review: Option<IssueEventDismissedReview>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub issue: Option<IssueSimple>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub label: Option<IssueEventLabel>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub lock_reason: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub milestone: Option<IssueEventMilestone>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<PerformedviaGithubApp>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_card: Option<IssueEventProjectCard>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub rename: Option<IssueEventRename>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub requested_reviewer: Option<RequestedReviewer>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub requested_team: Option<Team>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub review_requester: Option<ReviewRequester>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LabeledIssueEventLabel {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LabeledIssueEvent {
        pub actor: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        pub label: Label,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UnlabeledIssueEventLabel {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UnlabeledIssueEvent {
        pub actor: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        pub label: Label,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AssignedIssueEvent {
        pub actor: SimpleUser,
        pub assignee: SimpleUser,
        pub assigner: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UnassignedIssueEvent {
        pub actor: SimpleUser,
        pub assignee: SimpleUser,
        pub assigner: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MilestonedIssueEventMilestone {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MilestonedIssueEvent {
        pub actor: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        pub milestone: Milestone,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DemilestonedIssueEventMilestone {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DemilestonedIssueEvent {
        pub actor: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        pub milestone: Milestone,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Rename {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub from: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub to: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RenamedIssueEvent {
        pub actor: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        pub rename: Rename,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReviewRequestedIssueEvent {
        pub actor: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub requested_reviewer: Option<SimpleUser>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub requested_team: Option<Team>,
        pub review_requester: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReviewRequestRemovedIssueEvent {
        pub actor: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub requested_reviewer: Option<SimpleUser>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub requested_team: Option<Team>,
        pub review_requester: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DismissedReview {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub dismissal_commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub dismissal_message: String,
        pub review_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReviewDismissedIssueEvent {
        pub actor: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        pub dismissed_review: DismissedReview,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LockedIssueEvent {
        pub actor: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub lock_reason: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddedtoProjectIssueEventProjectCard {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub column_name: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub previous_column_name: String,
        pub project_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub project_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddedtoProjectIssueEvent {
        pub actor: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_card: Option<ProjectCard>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MovedColumninProjectIssueEventProjectCard {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub column_name: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub previous_column_name: String,
        pub project_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub project_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MovedColumninProjectIssueEvent {
        pub actor: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_card: Option<ProjectCard>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RemovedFromProjectIssueEventProjectCard {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub column_name: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub previous_column_name: String,
        pub project_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub project_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RemovedFromProjectIssueEvent {
        pub actor: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_card: Option<ProjectCard>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ConvertedNotetoIssueIssueEventProjectCard {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub column_name: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub previous_column_name: String,
        pub project_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub project_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ConvertedNotetoIssueIssueEvent {
        pub actor: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub project_card: Option<ProjectCard>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueEventforIssue {
        pub actor: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        pub label: Label,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineCommentEvent {
        pub actor: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub author_association: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<Integration>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub user: SimpleUser,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Source {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub issue: Option<IssueSimple>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineCrossReferencedEvent {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub actor: Option<SimpleUser>,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub source: Source,
        pub updated_at: DateTime<Utc>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineCommittedEventAuthor {
        pub date: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineCommittedEventCommitter {
        pub date: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineCommittedEventParents {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineCommittedEvent {
        pub author: Author,
        pub committer: Committer,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub parents: Vec<Parents>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        pub tree: Tree,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub verification: Verification,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Html {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub href: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineReviewedEventLinksLinksPullRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub href: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineReviewedEventLinks {
        pub html: Html,
        pub pull_request: PullRequest,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineReviewedEvent {
        pub links: Links,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub author_association: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pull_request_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub submitted_at: Option<DateTime<Utc>>,
        pub user: SimpleUser,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SelfData {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub href: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestReviewCommentLinksLinksPullRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub href: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestReviewCommentLinks {
        pub html: Html,
        pub pull_request: PullRequest,
        #[serde(rename = "self")]
        pub self_: SelfData,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestReviewComment {
        pub links: Links,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub author_association: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub diff_hunk: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub in_reply_to_id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub original_commit_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub original_line: Option<i64>,
        pub original_position: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub original_start_line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        pub position: i64,
        pub pull_request_review_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pull_request_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub side: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub start_side: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub user: SimpleUser,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineLineCommentedEvent {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub comments: Vec<PullRequestReviewComment>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineCommitCommentedEvent {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub comments: Vec<CommitComment>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineAssignedIssueEvent {
        pub actor: SimpleUser,
        pub assignee: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineUnassignedIssueEvent {
        pub actor: SimpleUser,
        pub assignee: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub performed_via_github_app: Integration,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TimelineIssueEvents {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeployKey {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        pub read_only: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub verified: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Language {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LicenseContentLinks {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "self"
        )]
        pub self_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LicenseContent {
        pub links: Links,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub encoding: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub license: License,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PagesSourceHash {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PagesHttpsCertificate {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub domains: serde_json::Value,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub expires_at: Option<NaiveDate>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Page {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub cname: String,
        pub custom_404: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub https_certificate: Option<PagesHttpsCertificate>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub https_enforced: Option<bool>,
        pub public: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub source: Option<PagesSourceHash>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Error {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Pusher {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PageBuild {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit: String,
        pub created_at: DateTime<Utc>,
        pub duration: i64,
        pub error: Error,
        pub pusher: Pusher,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PageBuildStatus {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Domain {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub caa_error: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dns_resolves: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub enforces_https: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_cname_record: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_mx_records_present: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub host: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub https_error: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_a_record: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_apex_domain: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cloudflare_ip: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cname_to_fastly: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cname_to_github_user_domain: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cname_to_pages_dot_github_dot_com: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_fastly_ip: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_https_eligible: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_non_github_pages_ip_present: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_old_ip_address: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_pages_domain: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_pointed_to_github_pages_ip: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_proxied: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_served_by_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_valid: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_valid_domain: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub nameservers: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub reason: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub responds_to_https: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub should_be_a_record: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub uri: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AltDomain {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub caa_error: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dns_resolves: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub enforces_https: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_cname_record: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_mx_records_present: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub host: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub https_error: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_a_record: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_apex_domain: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cloudflare_ip: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cname_to_fastly: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cname_to_github_user_domain: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_cname_to_pages_dot_github_dot_com: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_fastly_ip: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_https_eligible: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_non_github_pages_ip_present: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_old_ip_address: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_pages_domain: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_pointed_to_github_pages_ip: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_proxied: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_served_by_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_valid: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_valid_domain: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub nameservers: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub reason: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub responds_to_https: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub should_be_a_record: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub uri: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PagesHealthCheck {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub alt_domain: Option<AltDomain>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub domain: Option<Domain>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestLabels {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub default: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestHeadHeadRepoRepoOwner {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestHeadHeadRepoRepoPermissions {
        pub admin: bool,
        pub pull: bool,
        pub push: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestHeadHeadRepoRepoLicense {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub spdx_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestHeadHeadRepo {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        pub archived: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub disabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        pub fork: bool,
        pub forks: i64,
        pub forks_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        pub has_downloads: bool,
        pub has_issues: bool,
        pub has_pages: bool,
        pub has_projects: bool,
        pub has_wiki: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        pub license: License,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub master_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        pub open_issues: i64,
        pub open_issues_count: i64,
        pub owner: Owner,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<Permissions>,
        pub private: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        pub pushed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        pub stargazers_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub watchers: i64,
        pub watchers_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestHeadHeadUser {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestHead {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub label: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        pub repo: Repo,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestBaseBaseRepoRepoOwner {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestBaseBaseRepoRepoPermissions {
        pub admin: bool,
        pub pull: bool,
        pub push: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestBaseBaseRepo {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        pub archived: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub disabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        pub fork: bool,
        pub forks: i64,
        pub forks_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        pub has_downloads: bool,
        pub has_issues: bool,
        pub has_pages: bool,
        pub has_projects: bool,
        pub has_wiki: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        pub license: License,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub master_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        pub open_issues: i64,
        pub open_issues_count: i64,
        pub owner: Owner,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<Permissions>,
        pub private: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        pub pushed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        pub stargazers_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub watchers: i64,
        pub watchers_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestBaseBaseUser {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestBase {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub label: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        pub repo: Repo,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestLinks {
        pub comments: Link,
        pub commits: Link,
        pub html: Link,
        pub issue: Link,
        pub review_comment: Link,
        pub review_comments: Link,
        #[serde(rename = "self")]
        pub self_: Link,
        pub statuses: Link,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MergedBy {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestData {
        pub links: Links,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub active_lock_reason: String,
        pub additions: i64,
        pub assignee: Assignee,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<SimpleUser>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub author_association: String,
        pub auto_merge: AutoMerge,
        pub base: Base,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        pub changed_files: i64,
        pub closed_at: DateTime<Utc>,
        pub comments: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        pub commits: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        pub created_at: DateTime<Utc>,
        pub deletions: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub diff_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub draft: Option<bool>,
        pub head: Head,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<Labels>,
        pub locked: bool,
        pub maintainer_can_modify: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merge_commit_sha: String,
        pub mergeable: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mergeable_state: String,
        pub merged: bool,
        pub merged_at: DateTime<Utc>,
        pub merged_by: MergedBy,
        pub milestone: Milestone,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub number: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub patch_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub rebaseable: Option<bool>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub requested_reviewers: Vec<SimpleUser>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub requested_teams: Vec<TeamSimple>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub review_comment_url: String,
        pub review_comments: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub review_comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestMergeResult {
        pub merged: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestReviewRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<Team>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<SimpleUser>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestReviewLinksLinksPullRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub href: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestReviewLinks {
        pub html: Html,
        pub pull_request: PullRequest,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PullRequestReview {
        pub links: Links,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub author_association: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pull_request_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub submitted_at: Option<DateTime<Utc>>,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReviewCommentLinks {
        pub html: Link,
        pub pull_request: Link,
        #[serde(rename = "self")]
        pub self_: Link,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReviewComment {
        pub links: Links,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub author_association: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub diff_hunk: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub in_reply_to_id: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub original_commit_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub original_line: Option<i64>,
        pub original_position: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub original_start_line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        pub position: i64,
        pub pull_request_review_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pull_request_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub side: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub start_side: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Uploader {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_at: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReleaseAsset {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub browser_download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        pub created_at: DateTime<Utc>,
        pub download_count: i64,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub label: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        pub updated_at: DateTime<Utc>,
        pub uploader: Uploader,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Release {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assets: Vec<ReleaseAsset>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assets_url: String,
        pub author: SimpleUser,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub discussion_url: String,
        pub draft: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub prerelease: bool,
        pub published_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reactions: Option<ReactionRollup>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tag_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tarball_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_commitish: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub upload_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub zipball_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SecretScanningAlert {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub number: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub resolution: Option<serde_json::Value>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub resolved_at: Option<DateTime<Utc>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub resolved_by: Option<SimpleUser>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Stargazer {
        pub starred_at: DateTime<Utc>,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitActivity {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub days: Vec<i64>,
        pub total: i64,
        pub week: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Weeks {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub a: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub c: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub d: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub w: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContributorActivity {
        pub author: Author,
        pub total: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub weeks: Vec<Weeks>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ParticipationStats {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub all: Vec<i64>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub owner: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RepositorySubscription {
        pub created_at: DateTime<Utc>,
        pub ignored: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub reason: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        pub subscribed: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Tag {
        pub commit: Commit,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tarball_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub zipball_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Topic {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub names: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Traffic {
        pub count: i64,
        pub timestamp: DateTime<Utc>,
        pub uniques: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CloneTraffic {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub clones: Vec<Traffic>,
        pub count: i64,
        pub uniques: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ContentTraffic {
        pub count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        pub uniques: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReferrerTraffic {
        pub count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub referrer: String,
        pub uniques: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ViewTraffic {
        pub count: i64,
        pub uniques: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub views: Vec<Traffic>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Members {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "$ref"
        )]
        pub ref_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Meta {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub last_modified: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub resource_type: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimGroupListEnterpriseResources {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub members: Vec<Members>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub meta: Option<Meta>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimGroupListEnterprise {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub resources: Vec<Resources>,
        pub items_per_page: f64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        pub start_index: f64,
        pub total_results: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimEnterpriseGroup {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub members: Vec<Members>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub meta: Option<Meta>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Name {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub family_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub given_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Emails {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub primary: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUserListEnterpriseResourcesResourcesGroups {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUserListEnterpriseResources {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<Emails>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<Groups>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub meta: Option<Meta>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUserListEnterprise {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub resources: Vec<Resources>,
        pub items_per_page: f64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        pub start_index: f64,
        pub total_results: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimEnterpriseUserGroups {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimEnterpriseUser {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<Emails>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<Groups>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub meta: Option<Meta>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUserName {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub family_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub formatted: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub given_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUserEmails {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub primary: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUserMeta {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created: Option<DateTime<Utc>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub last_modified: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub resource_type: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Operations {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub op: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUser {
        pub active: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_name: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<Emails>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub id: String,
        pub meta: Meta,
        pub name: Name,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub operations: Vec<Operations>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub organization_id: Option<i64>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ScimUserList {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub resources: Vec<ScimUser>,
        pub items_per_page: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        pub start_index: i64,
        pub total_results: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Matches {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub indices: Vec<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub text: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SearchResultTextMatches {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub fragment: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub matches: Vec<Matches>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub object_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub object_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub property: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CodeSearchResultItem {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub file_size: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub last_modified_at: Option<DateTime<Utc>>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub line_numbers: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        pub repository: MinimalRepository,
        pub score: f64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub text_matches: Option<SearchResultTextMatches>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitSearchResultItemCommitCommitAuthor {
        pub date: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitSearchResultItemCommitCommitCommitter {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub date: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitSearchResultItemCommit {
        pub author: Author,
        pub comment_count: i64,
        pub committer: Committer,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        pub tree: Tree,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub verification: Option<Verification>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitSearchResultItemCommitter {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub date: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitSearchResultItemParents {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CommitSearchResultItem {
        pub author: Author,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        pub commit: Commit,
        pub committer: Committer,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub parents: Vec<Parents>,
        pub repository: MinimalRepository,
        pub score: f64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub text_matches: Option<SearchResultTextMatches>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueSearchResultItemLabels {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub default: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct IssueSearchResultItem {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub active_lock_reason: String,
        pub assignee: Assignee,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<SimpleUser>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub author_association: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_html: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body_text: String,
        pub closed_at: DateTime<Utc>,
        pub comments: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub draft: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<Labels>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        pub locked: bool,
        pub milestone: Milestone,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub number: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub performed_via_github_app: Option<PerformedviaGithubApp>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pull_request: Option<PullRequest>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository: Option<Repository>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        pub score: f64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub text_matches: Option<SearchResultTextMatches>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub timeline_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub user: User,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LabelSearchResultItem {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        pub default: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub score: f64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub text_matches: Option<SearchResultTextMatches>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RepoSearchResultItemPermissions {
        pub admin: bool,
        pub pull: bool,
        pub push: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RepoSearchResultItem {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub archive_url: String,
        pub archived: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignees_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blobs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branches_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub clone_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub collaborators_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub compare_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contents_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub contributors_url: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub deployments_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub disabled: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub downloads_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        pub fork: bool,
        pub forks: i64,
        pub forks_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub forks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub full_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_commits_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_refs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        pub has_downloads: bool,
        pub has_issues: bool,
        pub has_pages: bool,
        pub has_projects: bool,
        pub has_wiki: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hooks_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_comment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub labels_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub language: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub languages_url: String,
        pub license: License,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub master_branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merges_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub milestones_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mirror_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        pub open_issues: i64,
        pub open_issues_count: i64,
        pub owner: Owner,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<Permissions>,
        pub private: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pulls_url: String,
        pub pushed_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub releases_url: String,
        pub score: f64,
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ssh_url: String,
        pub stargazers_count: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub stargazers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub statuses_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscribers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscription_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub svn_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tags_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub temp_clone_token: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub text_matches: Option<SearchResultTextMatches>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub topics: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub trees_url: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub watchers: i64,
        pub watchers_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TopicRelation {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub relation_type: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub topic_id: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Related {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub topic_relation: Option<TopicRelation>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Aliases {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub topic_relation: Option<TopicRelation>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TopicSearchResultItem {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub aliases: Vec<Aliases>,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_by: String,
        pub curated: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_name: String,
        pub featured: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub logo_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub related: Vec<Related>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub released: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub repository_count: Option<i64>,
        pub score: f64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub short_description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub text_matches: Option<SearchResultTextMatches>,
        pub updated_at: DateTime<Utc>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UserSearchResultItem {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub bio: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blog: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub company: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub created_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub followers: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub following: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hireable: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub public_gists: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub public_repos: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub score: f64,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub suspended_at: Option<DateTime<Utc>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub text_matches: Option<SearchResultTextMatches>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub updated_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PrivateUser {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub bio: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blog: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub business_plus: Option<bool>,
        pub collaborators: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub company: String,
        pub created_at: DateTime<Utc>,
        pub disk_usage: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        pub followers: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        pub following: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        pub hireable: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ldap_dn: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        pub owned_private_repos: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub plan: Option<Plan>,
        pub private_gists: i64,
        pub public_gists: i64,
        pub public_repos: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub suspended_at: Option<DateTime<Utc>>,
        pub total_private_repos: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub twitter_username: String,
        pub two_factor_authentication: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Email {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        pub primary: bool,
        pub verified: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GpgKeyEmails {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub verified: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Subkeys {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub can_certify: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub can_encrypt_comms: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub can_encrypt_storage: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub can_sign: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub created_at: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub expires_at: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub primary_key_id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub public_key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub raw_key: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub subkeys: Vec<serde_json::Value>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GpgKey {
        pub can_certify: bool,
        pub can_encrypt_comms: bool,
        pub can_encrypt_storage: bool,
        pub can_sign: bool,
        pub created_at: DateTime<Utc>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<Emails>,
        pub expires_at: DateTime<Utc>,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key_id: String,
        pub primary_key_id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub public_key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub raw_key: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub subkeys: Vec<Subkeys>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Key {
        pub created_at: DateTime<Utc>,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        pub read_only: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        pub verified: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MarketplaceAccount {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_billing_email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UserMarketplacePurchase {
        pub account: MarketplaceAccount,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub billing_cycle: String,
        pub free_trial_ends_on: DateTime<Utc>,
        pub next_billing_date: DateTime<Utc>,
        pub on_free_trial: bool,
        pub plan: MarketplaceListingPlan,
        pub unit_count: i64,
        pub updated_at: DateTime<Utc>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct StarredRepository {
        pub repo: Repository,
        pub starred_at: DateTime<Utc>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Contexts {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub octicon: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Hovercard {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub contexts: Vec<Contexts>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct KeySimple {
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetGithubApiRootOkResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub authorizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub code_search_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_search_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub current_user_authorizations_html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub current_user_repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub current_user_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub emails_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub emojis_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub feeds_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hub_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issue_search_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub issues_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub keys_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub label_search_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub notifications_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_teams_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub public_gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub rate_limit_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_search_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub topic_search_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_organizations_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_repositories_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_search_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateGithubAppFromManifestRequest {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostCreateGithubAppFromManifestCreatedResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_secret: String,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub installations_count: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        pub owner: Owner,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub pem: String,
        pub permissions: Permissions,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub slug: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub webhook_secret: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateWebhookConfigurationAppRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateInstallationAccessTokenAppRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<AppPermissions>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repository_ids: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeleteAppAuthorizationRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub access_token: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CheckTokenRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub access_token: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeleteAppTokenRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub access_token: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ResetTokenRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub access_token: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateScopedAccessTokenRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub access_token: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub permissions: Option<AppPermissions>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repository_ids: Vec<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub target_id: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetCheckAuthorizationOkResponse {
        pub app: App,
        pub created_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub fingerprint: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub hashed_token: String,
        pub id: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub installation: Option<Installation>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub scopes: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token_last_eight: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub user: Option<User>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateNewAuthorizationRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub fingerprint: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub scopes: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetorCreateAuthorizationSpecificAppRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub fingerprint: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub scopes: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetorCreateAuthorizationSpecificAppandFingerprintRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub client_secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub scopes: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateExistingAuthorizationRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub add_scopes: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub fingerprint: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub remove_scopes: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub scopes: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetEmojisOkResponse {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetGithubActionsPermissionsEnterpriseRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub allowed_actions: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub enabled_organizations: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListSelectedOrganizationsEnabledGithubActionsinEnterpriseOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub organizations: Vec<OrganizationSimple>,
        pub total_count: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetSelectedOrganizationsEnabledGithubActionsinEnterpriseRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_organization_ids: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListSelfDataHostedRunnerGroupsEnterpriseOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runner_groups: Vec<RunnerGroupsEnterprise>,
        pub total_count: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateSelfDataHostedRunnerGroupEnterpriseRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runners: Vec<i64>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_organization_ids: Vec<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateSelfDataHostedRunnerGroupEnterpriseRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListOrganizationAccessSelfDataHostedRunnerGroupinEnterpriseOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub organizations: Vec<OrganizationSimple>,
        pub total_count: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetOrganizationAccessSelfDataHostedRunnerGroupinEnterpriseRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_organization_ids: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListSelfDataHostedRunnersinGroupEnterpriseOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runners: Vec<Runner>,
        pub total_count: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetSelfDataHostedRunnersinGroupEnterpriseRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runners: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListSelfDataHostedRunnersEnterpriseOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runners: Vec<Runner>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<f64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateGistRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        pub files: Files,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub public: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateGistRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub files: Option<Files>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateGistCommentRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateGistCommentRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetCheckifGistIsStarredNotFoundResponse {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListRepositoriesAccessibleAppInstallationOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<Repository>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_selection: String,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RenderMarkdownDocumentRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub context: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mode: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub text: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MarkNotificationsasReadRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub last_read_at: Option<DateTime<Utc>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub read: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PutMarkNotificationsasReadAcceptedResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetThreadSubscriptionRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ignored: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateOrganizationRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub billing_email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blog: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub company: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_repository_permission: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_organization_projects: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_repository_projects: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub members_allowed_repository_creation_type: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_internal_repositories: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_private_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_private_repositories: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_public_pages: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_public_repositories: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub members_can_create_repositories: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub twitter_username: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PatchUpdateOrganizationUnprocessableEntityResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub errors: Vec<Errors>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetGithubActionsPermissionsOrganizationRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub allowed_actions: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub enabled_repositories: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListSelectedRepositoriesEnabledGithubActionsinOrganizationOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<Repository>,
        pub total_count: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetSelectedRepositoriesEnabledGithubActionsinOrganizationRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_repository_ids: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListSelfDataHostedRunnerGroupsOrganizationOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runner_groups: Vec<RunnerGroupsOrg>,
        pub total_count: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateSelfDataHostedRunnerGroupOrganizationRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runners: Vec<i64>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_repository_ids: Vec<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateSelfDataHostedRunnerGroupOrganizationRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListRepositoryAccessSelfDataHostedRunnerGroupinOrganizationOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<MinimalRepository>,
        pub total_count: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetRepositoryAccessSelfDataHostedRunnerGroupinOrganizationRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_repository_ids: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListSelfDataHostedRunnersinGroupOrganizationOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runners: Vec<Runner>,
        pub total_count: f64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetSelfDataHostedRunnersinGroupOrganizationRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runners: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListSelfDataHostedRunnersOrganizationOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runners: Vec<Runner>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListOrganizationSecretsOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub secrets: Vec<OrganizationActionsSecret>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateUpdateOrganizationSecretRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub encrypted_value: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_repository_ids: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListSelectedRepositoriesOrganizationSecretOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<MinimalRepository>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetSelectedRepositoriesOrganizationSecretRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub selected_repository_ids: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateOrganizationWebhookRequestConfig {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub password: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub username: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateOrganizationWebhookRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        pub config: Config,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateOrganizationWebhookRequestConfig {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateOrganizationWebhookRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub config: Option<Config>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateWebhookConfigurationOrganizationRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListAppInstallationsOrganizationOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub installations: Vec<Installation>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetInteractionRestrictionsOrganizationOkResponse {
        pub expires_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub limit: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub origin: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateOrganizationInvitationRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub invitee_id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub role: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub team_ids: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetOrganizationMembershipUserRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub role: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct StartOrganizationMigrationRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub exclude: Vec<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub exclude_attachments: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lock_repositories: Option<bool>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PutConvertOrganizationMemberOutsideCollaboratorAcceptedResponse {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeleteRemoveOutsideCollaboratorFromOrganizationUnprocessableEntityResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateOrganizationProjectRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateOrganizationRepositoryRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub auto_init: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gitignore_template: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_issues: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_projects: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_wiki: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub license_template: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub team_id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateTeamRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub maintainers: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_team_id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub privacy: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repo_names: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateTeamRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_team_id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub privacy: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateDiscussionRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateDiscussionRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateDiscussionCommentRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateDiscussionCommentRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateReactionTeamDiscussionCommentRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateReactionTeamDiscussionRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddUpdateTeamMembershipUserRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub role: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddUpdateTeamProjectPermissionsRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PutAddUpdateTeamProjectPermissionsForbiddenResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddUpdateTeamRepositoryPermissionsRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateUpdateIdpGroupConnectionsRequestGroups {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub group_description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub group_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub group_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateUpdateIdpGroupConnectionsRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<Groups>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeleteProjectCardForbiddenResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub errors: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateExistingProjectCardRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub archived: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MoveProjectCardRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub column_id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub position: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostMoveProjectCardCreatedResponse {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostMoveProjectCardForbiddenResponseErrors {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub code: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub field: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub resource: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostMoveProjectCardForbiddenResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub errors: Vec<Errors>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostMoveProjectCardServiceUnavailableResponseErrors {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub code: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostMoveProjectCardServiceUnavailableResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub code: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub errors: Vec<Errors>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateExistingProjectColumnRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateProjectCardRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub note: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostCreateProjectCardUnprocessableEntityResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub errors: Vec<Errors>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostCreateProjectCardServiceUnavailableResponseErrors {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub code: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostCreateProjectCardServiceUnavailableResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub code: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub errors: Vec<Errors>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MoveProjectColumnRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub position: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostMoveProjectColumnCreatedResponse {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeleteProjectForbiddenResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub errors: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateProjectRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization_permission: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PatchUpdateProjectForbiddenResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub errors: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddProjectCollaboratorRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateProjectColumnRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeleteRepositoryForbiddenResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateRepositoryRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub archived: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub default_branch: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_issues: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_projects: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_wiki: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub security_and_analysis: Option<SecurityandAnalysis>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListArtifactsRepositoryOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub artifacts: Vec<Artifact>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetGithubActionsPermissionsRepositoryRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub allowed_actions: String,
        pub enabled: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListSelfDataHostedRunnersRepositoryOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub runners: Vec<Runner>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListWorkflowRunsRepositoryOkResponse {
        pub total_count: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub workflow_runs: Vec<WorkflowRun>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListWorkflowRunArtifactsOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub artifacts: Vec<Artifact>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostCancelWorkflowRunAcceptedResponse {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListJobsWorkflowRunOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub jobs: Vec<Job>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReviewPendingDeploymentsWorkflowRunRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub comment: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub environment_ids: Vec<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostReRunWorkflowCreatedResponse {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListRepositorySecretsOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub secrets: Vec<ActionsSecret>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateUpdateRepositorySecretRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub encrypted_value: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key_id: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PutCreateUpdateRepositorySecretCreatedResponse {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListRepositoryWorkflowsOkResponse {
        pub total_count: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub workflows: Vec<Workflow>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Inputs {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateWorkflowDispatchEventRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub inputs: Option<Inputs>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListWorkflowRunsOkResponse {
        pub total_count: i64,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub workflow_runs: Vec<WorkflowRun>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateBranchProtectionRequestRequiredStatusChecks {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub contexts: Vec<String>,
        pub strict: bool,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateBranchProtectionRequestRequiredPullRequestReviewsRequiredPullRequestReviewsDismissalRestrictions
    {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateBranchProtectionRequestRequiredPullRequestReviews {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismiss_stale_reviews: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismissal_restrictions: Option<DismissalRestrictions>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub require_code_owner_reviews: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_approving_review_count: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Restrictions {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub apps: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateBranchProtectionRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_deletions: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_force_pushes: Option<bool>,
        pub enforce_admins: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_conversation_resolution: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_linear_history: Option<bool>,
        pub required_pull_request_reviews: RequiredPullRequestReviews,
        pub required_status_checks: RequiredStatusChecks,
        pub restrictions: Restrictions,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdatePullRequestReviewProtectionRequestDismissalRestrictions {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdatePullRequestReviewProtectionRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismiss_stale_reviews: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismissal_restrictions: Option<DismissalRestrictions>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub require_code_owner_reviews: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub required_approving_review_count: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateStatusCheckProtectionRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub contexts: Vec<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub strict: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddStatusCheckContextsRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub contexts: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetStatusCheckContextsRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub contexts: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RemoveStatusCheckContextsRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub contexts: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddAppAccessRestrictionsRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub apps: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetAppAccessRestrictionsRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub apps: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RemoveAppAccessRestrictionsRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub apps: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddTeamAccessRestrictionsRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetTeamAccessRestrictionsRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RemoveTeamAccessRestrictionsRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub teams: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddUserAccessRestrictionsRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetUserAccessRestrictionsRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RemoveUserAccessRestrictionsRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub users: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RenameBranchRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub new_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Annotations {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub annotation_level: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub end_column: Option<i64>,
        pub end_line: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub raw_details: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_column: Option<i64>,
        pub start_line: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Images {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub alt: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub caption: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub image_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateCheckRunRequestOutput {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub annotations: Vec<Annotations>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub images: Vec<Images>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub summary: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub text: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Actions {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub identifier: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub label: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateCheckRunRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub actions: Vec<Actions>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub completed_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub conclusion: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub details_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub output: Option<Output>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub started_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateCheckRunRequestOutput {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub annotations: Vec<Annotations>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub images: Vec<Images>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub summary: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub text: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateCheckRunRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub actions: Vec<Actions>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub completed_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub conclusion: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub details_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub output: Option<Output>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub started_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub status: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateCheckSuiteRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head_sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateRepositoryPreferencesCheckSuitesRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub auto_trigger_checks: Vec<AutoTriggerChecks>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListCheckRunsinCheckSuiteOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub check_runs: Vec<CheckRun>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostRerequestCheckSuiteCreatedResponse {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateCodeScanningAlertRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dismissed_reason: Option<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UploadAnalysisasSarifDataRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub checkout_uri: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sarif: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub started_at: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tool_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddRepositoryCollaboratorRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permissions: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateCommitCommentRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateReactionCommitCommentRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateCommitCommentRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub position: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListCheckRunsGitReferenceOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub check_runs: Vec<CheckRun>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListCheckSuitesGitReferenceOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub check_suites: Vec<CheckSuite>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateContentAttachmentRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetRepositoryContentOkResponse {
        pub links: Links,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub download_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub git_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        pub size: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateUpdateFileContentsRequestCommitter {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub date: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateUpdateFileContentsRequestAuthor {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub date: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateUpdateFileContentsRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub author: Option<Author>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branch: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub committer: Option<Committer>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeleteFileRequestCommitter {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeleteFileRequestAuthor {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeleteFileRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub author: Option<Author>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branch: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub committer: Option<Committer>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateDeploymentRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub auto_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub payload: Option<Payload>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub production_environment: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub required_contexts: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub task: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub transient_environment: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PostCreateDeploymentAcceptedResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateDeploymentStatusRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub auto_inactive: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub environment_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub log_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ClientPayload {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateRepositoryDispatchEventRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub client_payload: Option<ClientPayload>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event_type: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetAllEnvironmentsOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub environments: Vec<Environment>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_count: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateUpdateEnvironmentRequestReviewers {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateUpdateEnvironmentRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub deployment_branch_policy: Option<DeploymentBranchPolicy>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub reviewers: Vec<Reviewers>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub wait_timer: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateForkRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organization: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateBlobRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub encoding: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateCommitRequestAuthor {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub date: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateCommitRequestCommitter {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub date: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateCommitRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub author: Option<Author>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub committer: Option<Committer>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub parents: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub signature: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tree: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateReferenceRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "ref"
        )]
        pub ref_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateReferenceRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub force: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateTagObjectRequestTagger {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub date: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateTagObjectRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub object: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tag: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub tagger: Option<Tagger>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateTreeRequestTree {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub mode: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateTreeRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub base_tree: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub tree: Vec<Tree>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateRepositoryWebhookRequestConfig {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub digest: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub token: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateRepositoryWebhookRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub config: Option<Config>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateRepositoryWebhookRequestConfig {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub address: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub room: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateRepositoryWebhookRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub add_events: Vec<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub config: Option<Config>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub events: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub remove_events: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateWebhookConfigurationRepositoryRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content_type: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub insecure_ssl: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub secret: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct StartImportRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tfvc_project: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs_password: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs_username: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateImportRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tfvc_project: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs_password: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub vcs_username: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MapCommitAuthorRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateGitLfsPreferenceRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub use_lfs: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetInteractionRestrictionsRepositoryOkResponse {
        pub expires_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub limit: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub origin: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateRepositoryInvitationRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permissions: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateIssueRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignee: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<Labels>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub milestone: Option<Milestone>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateIssueCommentRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateReactionIssueCommentRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateIssueRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub assignee: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<Labels>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub milestone: Option<Milestone>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddAssigneesIssueRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RemoveAssigneesFromIssueRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub assignees: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateIssueCommentRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddLabelsIssueRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetLabelsIssueRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub labels: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct LockIssueRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub lock_reason: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateReactionIssueRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateDeployKeyRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub read_only: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateLabelRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateLabelRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub color: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub new_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MergeBranchRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub base: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateMilestoneRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub due_on: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateMilestoneRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub due_on: Option<DateTime<Utc>>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MarkRepositoryNotificationsasReadRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub last_read_at: Option<DateTime<Utc>>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PutMarkRepositoryNotificationsasReadAcceptedResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateGithubPagesSiteRequestSource {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub branch: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateGithubPagesSiteRequest {
        pub source: Source,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateInformationAboutGithubPagesSiteRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub cname: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub https_enforced: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub public: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub source: Option<Source>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateRepositoryProjectRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreatePullRequestRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub base: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub draft: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub head: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub issue: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maintainer_can_modify: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateReviewCommentPullRequestRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateReactionPullRequestReviewCommentRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdatePullRequestRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub base: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maintainer_can_modify: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateReviewCommentPullRequestRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub in_reply_to: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub position: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub side: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub start_side: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateReplyReviewCommentRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct MergePullRequestRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_title: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub merge_method: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PutMergePullRequestMethodNotAllowedResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PutMergePullRequestConflictResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub documentation_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RequestReviewersPullRequestRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub reviewers: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub team_reviewers: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct RemoveRequestedReviewersFromPullRequestRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub reviewers: Vec<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub team_reviewers: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct Comments {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub path: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub position: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub side: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start_line: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub start_side: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateReviewPullRequestRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub comments: Vec<Comments>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub commit_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateReviewPullRequestRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DismissReviewPullRequestRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SubmitReviewPullRequestRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub event: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdatePullRequestBranchRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub expected_head_sha: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct PutUpdatePullRequestBranchAcceptedResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub message: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateReleaseRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub discussion_category_name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub draft: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub prerelease: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tag_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_commitish: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateReleaseAssetRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub label: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateReleaseRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub discussion_category_name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub draft: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub prerelease: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub tag_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_commitish: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateReactionReleaseRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub content: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateSecretScanningAlertRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub resolution: Option<serde_json::Value>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateCommitStatusRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub context: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub target_url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetRepositorySubscriptionRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ignored: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subscribed: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ReplaceAllRepositoryTopicsRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub names: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct TransferRepositoryRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub new_owner: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub team_ids: Vec<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateRepositoryUsingTemplateRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_all_branches: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub owner: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListEnvironmentSecretsOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub secrets: Vec<ActionsSecret>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateUpdateEnvironmentSecretRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub encrypted_value: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key_id: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProvisionScimEnterpriseGroupandInviteUsersRequestMembers {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProvisionScimEnterpriseGroupandInviteUsersRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_name: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub members: Vec<Members>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetScimInformationProvisionedEnterpriseGroupRequestMembers {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetScimInformationProvisionedEnterpriseGroupRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_name: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub members: Vec<Members>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateAttributeScimEnterpriseGroupRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub operations: Vec<Operations>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProvisionandInviteScimEnterpriseUserRequestName {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub family_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub given_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProvisionandInviteScimEnterpriseUserRequestEmails {
        pub primary: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProvisionandInviteScimEnterpriseUserRequestGroups {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProvisionandInviteScimEnterpriseUserRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<Emails>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<Groups>,
        pub name: Name,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetScimInformationProvisionedEnterpriseUserRequestName {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub family_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub given_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetScimInformationProvisionedEnterpriseUserRequestEmails {
        pub primary: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetScimInformationProvisionedEnterpriseUserRequestGroups {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetScimInformationProvisionedEnterpriseUserRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<Emails>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<Groups>,
        pub name: Name,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateAttributeScimEnterpriseUserRequestOperations {}

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateAttributeScimEnterpriseUserRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub operations: Vec<Operations>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProvisionandInviteScimUserRequestName {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub family_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub formatted: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub given_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProvisionandInviteScimUserRequestEmails {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub primary: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ProvisionandInviteScimUserRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_name: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<Emails>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<String>,
        pub name: Name,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateProvisionedOrganizationMembershipRequestName {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub family_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub formatted: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub given_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateProvisionedOrganizationMembershipRequestEmails {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub primary: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub value: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateProvisionedOrganizationMembershipRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub display_name: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<Emails>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<String>,
        pub name: Name,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct ValueData {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub external_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub family_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub given_name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub user_name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateAttributeScimUserRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub operations: Vec<Operations>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub schemas: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetSearchCodeOkResponse {
        pub incomplete_results: bool,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<CodeSearchResultItem>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetSearchCommitsOkResponse {
        pub incomplete_results: bool,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<CommitSearchResultItem>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetSearchIssuesandPullRequestsOkResponse {
        pub incomplete_results: bool,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<IssueSearchResultItem>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetSearchLabelsOkResponse {
        pub incomplete_results: bool,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<LabelSearchResultItem>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetSearchRepositoriesOkResponse {
        pub incomplete_results: bool,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<RepoSearchResultItem>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetSearchTopicsOkResponse {
        pub incomplete_results: bool,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<TopicSearchResultItem>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetSearchUsersOkResponse {
        pub incomplete_results: bool,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub items: Vec<UserSearchResultItem>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateTeamRequestData {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_team_id: Option<i64>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub permission: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub privacy: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateUpdateIdpGroupConnectionsRequestData {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub groups: Vec<Groups>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub synced_at: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetOkResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub bio: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blog: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub business_plus: Option<bool>,
        pub collaborators: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub company: String,
        pub created_at: DateTime<Utc>,
        pub disk_usage: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        pub followers: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        pub following: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        pub hireable: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ldap_dn: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        pub owned_private_repos: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub plan: Option<Plan>,
        pub private_gists: i64,
        pub public_gists: i64,
        pub public_repos: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub suspended_at: Option<DateTime<Utc>>,
        pub total_private_repos: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub twitter_username: String,
        pub two_factor_authentication: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub bio: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blog: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub company: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hireable: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub twitter_username: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct SetPrimaryEmailVisibilityRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub visibility: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct AddEmailAddressRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct DeleteEmailAddressRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub emails: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateGpgKeyRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub armored_public_key: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListAppInstallationsAccessibleUserAccessTokenOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub installations: Vec<Installation>,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetListRepositoriesAccessibleUserAccessTokenOkResponse {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<Repository>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repository_selection: String,
        pub total_count: i64,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetInteractionRestrictionsPublicRepositoriesOkResponse {
        pub expires_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub limit: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub origin: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreatePublicSshKeyRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub key: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub title: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct UpdateOrganizationMembershipRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub state: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct StartUserMigrationRequest {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub exclude: Vec<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub exclude_attachments: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lock_repositories: Option<bool>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub repositories: Vec<String>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateUserProjectRequest {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub body: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct CreateRepositoryRequest {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_merge_commit: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_rebase_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allow_squash_merge: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub auto_init: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delete_branch_on_merge: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub description: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gitignore_template: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_downloads: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_issues: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_projects: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub has_wiki: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub homepage: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_template: Option<bool>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub license_template: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub team_id: Option<i64>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
    pub struct GetUserOkResponse {
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub avatar_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub bio: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub blog: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub business_plus: Option<bool>,
        pub collaborators: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub company: String,
        pub created_at: DateTime<Utc>,
        pub disk_usage: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub email: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub events_url: String,
        pub followers: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub followers_url: String,
        pub following: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub following_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gists_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub gravatar_id: String,
        pub hireable: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub html_url: String,
        pub id: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub ldap_dn: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub location: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub login: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub name: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub node_id: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub organizations_url: String,
        pub owned_private_repos: i64,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub plan: Option<Plan>,
        pub private_gists: i64,
        pub public_gists: i64,
        pub public_repos: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub received_events_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub repos_url: String,
        pub site_admin: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub starred_url: String,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub subscriptions_url: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub suspended_at: Option<DateTime<Utc>>,
        pub total_private_repos: i64,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub twitter_username: String,
        pub two_factor_authentication: bool,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize",
            rename = "type"
        )]
        pub type_: String,
        pub updated_at: DateTime<Utc>,
        #[serde(
            default,
            skip_serializing_if = "String::is_empty",
            deserialize_with = "crate::utils::deserialize_null_string::deserialize"
        )]
        pub url: String,
    }
}

/// Entrypoint for interacting with the API client.
pub struct Client {
    host: String,
    agent: String,
    client: reqwest::Client,
    credentials: Option<crate::auth::Credentials>,
    #[cfg(feature = "httpcache")]
    http_cache: crate::http_cache::BoxedHttpCache,
}

impl Client {
    pub fn new<A, C>(agent: A, credentials: C) -> Result<Self>
    where
        A: Into<String>,
        C: Into<Option<crate::auth::Credentials>>,
    {
        Self::host(DEFAULT_HOST, agent, credentials)
    }

    pub fn host<H, A, C>(host: H, agent: A, credentials: C) -> Result<Self>
    where
        H: Into<String>,
        A: Into<String>,
        C: Into<Option<crate::auth::Credentials>>,
    {
        let http = reqwest::Client::builder().build()?;
        #[cfg(feature = "httpcache")]
        {
            Ok(Self::custom(
                host,
                agent,
                credentials,
                http,
                <dyn crate::http_cache::HttpCache>::noop(),
            ))
        }
        #[cfg(not(feature = "httpcache"))]
        {
            Ok(Self::custom(host, agent, credentials, http))
        }
    }

    #[cfg(feature = "httpcache")]
    pub fn custom<H, A, CR>(
        host: H,
        agent: A,
        credentials: CR,
        http: reqwest::Client,
        http_cache: crate::http_cache::BoxedHttpCache,
    ) -> Self
    where
        H: Into<String>,
        A: Into<String>,
        CR: Into<Option<crate::auth::Credentials>>,
    {
        Self {
            host: host.into(),
            agent: agent.into(),
            client: http,
            credentials: credentials.into(),
            http_cache,
        }
    }

    #[cfg(not(feature = "httpcache"))]
    pub fn custom<H, A, CR>(host: H, agent: A, credentials: CR, http: reqwest::Client) -> Self
    where
        H: Into<String>,
        A: Into<String>,
        CR: Into<Option<crate::auth::Credentials>>,
    {
        Self {
            host: host.into(),
            agent: agent.into(),
            client: http,
            credentials: credentials.into(),
        }
    }

    pub fn set_credentials<CR>(&mut self, credentials: CR)
    where
        CR: Into<Option<crate::auth::Credentials>>,
    {
        self.credentials = credentials.into();
    }

    fn credentials(
        &self,
        authentication: crate::auth::AuthenticationConstraint,
    ) -> Option<&crate::auth::Credentials> {
        match (authentication, self.credentials.as_ref()) {
            (crate::auth::AuthenticationConstraint::Unconstrained, creds) => creds,
            (
                crate::auth::AuthenticationConstraint::JWT,
                creds @ Some(&crate::auth::Credentials::JWT(_)),
            ) => creds,
            (
                crate::auth::AuthenticationConstraint::JWT,
                Some(&crate::auth::Credentials::InstallationToken(ref apptoken)),
            ) => Some(apptoken.jwt()),
            (crate::auth::AuthenticationConstraint::JWT, creds) => {
                println!(
                    "Request needs JWT authentication but only {:?} available",
                    creds
                );
                None
            }
        }
    }

    async fn url_and_auth(
        &self,
        uri: &str,
        authentication: crate::auth::AuthenticationConstraint,
    ) -> Result<(reqwest::Url, Option<String>)> {
        let parsed_url = uri.parse::<reqwest::Url>();

        match self.credentials(authentication) {
            Some(&crate::auth::Credentials::Client(ref id, ref secret)) => parsed_url
                .map(|mut u| {
                    u.query_pairs_mut()
                        .append_pair("client_id", id)
                        .append_pair("client_secret", secret);
                    (u, None)
                })
                .map_err(Error::from),
            Some(&crate::auth::Credentials::Token(ref token)) => {
                let auth = format!("token {}", token);
                parsed_url.map(|u| (u, Some(auth))).map_err(Error::from)
            }
            Some(&crate::auth::Credentials::JWT(ref jwt)) => {
                let auth = format!("Bearer {}", jwt.token());
                parsed_url.map(|u| (u, Some(auth))).map_err(Error::from)
            }
            Some(&crate::auth::Credentials::InstallationToken(ref apptoken)) => {
                if let Some(token) = apptoken.token() {
                    let auth = format!("token {}", token);
                    parsed_url.map(|u| (u, Some(auth))).map_err(Error::from)
                } else {
                    println!("App token is stale, refreshing");
                    let token_ref = apptoken.access_key.clone();

                    let token = self
                        .apps_create_installation_access_token(
                            apptoken.installation_id as i64,
                            &types::CreateInstallationAccessTokenAppRequest {
                                permissions: Default::default(),
                                repositories: Default::default(),
                                repository_ids: Default::default(),
                            },
                        )
                        .await
                        .unwrap();
                    let auth = format!("token {}", &token.token);
                    *token_ref.lock().unwrap() = Some(token.token);
                    parsed_url.map(|u| (u, Some(auth))).map_err(Error::from)
                }
            }
            None => parsed_url.map(|u| (u, None)).map_err(Error::from),
        }
    }

    async fn request<Out>(
        &self,
        method: http::Method,
        uri: &str,
        body: Option<reqwest::Body>,
        media_type: crate::utils::MediaType,
        authentication: crate::auth::AuthenticationConstraint,
    ) -> Result<(Option<hyperx::header::Link>, Out)>
    where
        Out: serde::de::DeserializeOwned + 'static + Send,
    {
        #[cfg(feature = "httpcache")]
        let uri2 = uri.to_string();

        let (url, auth) = self.url_and_auth(uri, authentication).await?;

        let instance = <&Client>::clone(&self);

        #[cfg(not(feature = "httpcache"))]
        let mut req = instance.client.request(method, url);

        #[cfg(feature = "httpcache")]
        let mut req = {
            let mut req = instance.client.request(method.clone(), url);
            if method == http::Method::GET {
                if let Ok(etag) = instance.http_cache.lookup_etag(&uri2) {
                    req = req.header(http::header::IF_NONE_MATCH, etag);
                }
            }
            req
        };

        req = req.header(http::header::USER_AGENT, &*instance.agent);
        req = req.header(
            http::header::ACCEPT,
            &*format!(
                "{}",
                hyperx::header::qitem::<mime::Mime>(From::from(media_type))
            ),
        );

        if let Some(auth_str) = auth {
            req = req.header(http::header::AUTHORIZATION, &*auth_str);
        }

        if let Some(body) = body {
            //println!("Body: {:?}", String::from_utf8(body.as_bytes().unwrap().to_vec()).unwrap());
            req = req.body(body);
        }
        println!("Request: {:?}", &req);
        let response = req.send().await?;

        #[cfg(feature = "httpcache")]
        let instance2 = <&Client>::clone(&self);

        #[cfg(feature = "httpcache")]
        let uri3 = uri.to_string();

        #[cfg(not(feature = "httpcache"))]
        let (remaining, reset) = crate::utils::get_header_values(response.headers());

        #[cfg(feature = "httpcache")]
        let (remaining, reset, etag) = crate::utils::get_header_values(response.headers());

        let status = response.status();
        let link = response
            .headers()
            .get(http::header::LINK)
            .and_then(|l| l.to_str().ok())
            .and_then(|l| l.parse().ok());

        let response_body = response.bytes().await?;

        if status.is_success() {
            println!(
                "response payload {}",
                String::from_utf8_lossy(&response_body)
            );
            #[cfg(feature = "httpcache")]
            {
                if let Some(etag) = etag {
                    let next_link = link.as_ref().and_then(|l| crate::utils::next_link(l));
                    if let Err(e) = instance2.http_cache.cache_response(
                        &uri3,
                        &response_body,
                        &etag,
                        &next_link,
                    ) {
                        // failing to cache isn't fatal, so just log & swallow the error
                        println!("Failed to cache body & etag: {}", e);
                    }
                }
            }
            let parsed_response = if status == http::StatusCode::NO_CONTENT {
                serde_json::from_str("null")
            } else {
                serde_json::from_slice::<Out>(&response_body)
            };
            parsed_response.map(|out| (link, out)).map_err(Error::from)
        } else if status == http::StatusCode::NOT_MODIFIED {
            // only supported case is when client provides if-none-match
            // header when cargo builds with --cfg feature="httpcache"
            #[cfg(feature = "httpcache")]
            {
                let body = instance2.http_cache.lookup_body(&uri3).unwrap();
                let out = serde_json::from_str::<Out>(&body).unwrap();
                let link = match link {
                    Some(link) => Ok(Some(link)),
                    None => instance2
                        .http_cache
                        .lookup_next_link(&uri3)
                        .map(|next_link| {
                            next_link.map(|next| {
                                let next = hyperx::header::LinkValue::new(next)
                                    .push_rel(hyperx::header::RelationType::Next);
                                hyperx::header::Link::new(vec![next])
                            })
                        }),
                };
                link.map(|link| (link, out))
            }
            #[cfg(not(feature = "httpcache"))]
            {
                unreachable!("this should not be reachable without the httpcache feature enabled")
            }
        } else {
            println!(
                "error status: {:?}, response payload: {}",
                status,
                String::from_utf8_lossy(&response_body),
            );
            let error = match (remaining, reset) {
                (Some(remaining), Some(reset)) if remaining == 0 => {
                    let now = std::time::SystemTime::now()
                        .duration_since(std::time::UNIX_EPOCH)
                        .unwrap()
                        .as_secs();
                    anyhow!(
                        "rate limit exceeded, will reset in {} seconds",
                        u64::from(reset) - now
                    )
                }
                _ => {
                    if response_body.is_empty() {
                        anyhow!("code: {}, empty response", status)
                    } else {
                        anyhow!(
                            "code: {}, error: {:?}",
                            status,
                            serde_json::from_slice(&response_body)?
                        )
                    }
                }
            };
            Err(error)
        }
    }

    async fn request_entity<D>(
        &self,
        method: http::Method,
        uri: &str,
        body: Option<reqwest::Body>,
        media_type: crate::utils::MediaType,
        authentication: crate::auth::AuthenticationConstraint,
    ) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        let (_, r) = self
            .request(method, uri, body, media_type, authentication)
            .await?;
        Ok(r)
    }

    async fn get<D>(&self, uri: &str) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.get_media(uri, crate::utils::MediaType::Json).await
    }

    async fn get_media<D>(&self, uri: &str, media: crate::utils::MediaType) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.request_entity(
            http::Method::GET,
            &(self.host.clone() + uri),
            None,
            media,
            self::auth::AuthenticationConstraint::Unconstrained,
        )
        .await
    }

    async fn get_all_pages<D>(&self, uri: &str) -> Result<Vec<D>>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.unfold(uri).await
    }

    async fn get_pages<D>(&self, uri: &str) -> Result<(Option<hyperx::header::Link>, Vec<D>)>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.request(
            http::Method::GET,
            &(self.host.clone() + uri),
            None,
            crate::utils::MediaType::Json,
            crate::auth::AuthenticationConstraint::Unconstrained,
        )
        .await
    }

    async fn get_pages_url<D>(
        &self,
        url: &reqwest::Url,
    ) -> Result<(Option<hyperx::header::Link>, Vec<D>)>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.request(
            http::Method::GET,
            url.as_str(),
            None,
            crate::utils::MediaType::Json,
            crate::auth::AuthenticationConstraint::Unconstrained,
        )
        .await
    }

    async fn post<D>(&self, uri: &str, message: Option<reqwest::Body>) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.post_media(
            uri,
            message,
            crate::utils::MediaType::Json,
            crate::auth::AuthenticationConstraint::Unconstrained,
        )
        .await
    }

    async fn post_media<D>(
        &self,
        uri: &str,
        message: Option<reqwest::Body>,
        media: crate::utils::MediaType,
        authentication: crate::auth::AuthenticationConstraint,
    ) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.request_entity(
            http::Method::POST,
            &(self.host.clone() + uri),
            message,
            media,
            authentication,
        )
        .await
    }

    async fn patch_media<D>(
        &self,
        uri: &str,
        message: Option<reqwest::Body>,
        media: crate::utils::MediaType,
    ) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.request_entity(
            http::Method::PATCH,
            &(self.host.clone() + uri),
            message,
            media,
            crate::auth::AuthenticationConstraint::Unconstrained,
        )
        .await
    }

    async fn patch<D>(&self, uri: &str, message: Option<reqwest::Body>) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.patch_media(uri, message, crate::utils::MediaType::Json)
            .await
    }

    async fn put<D>(&self, uri: &str, message: Option<reqwest::Body>) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.put_media(uri, message, crate::utils::MediaType::Json)
            .await
    }

    async fn put_media<D>(
        &self,
        uri: &str,
        message: Option<reqwest::Body>,
        media: crate::utils::MediaType,
    ) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.request_entity(
            http::Method::PUT,
            &(self.host.clone() + uri),
            message,
            media,
            crate::auth::AuthenticationConstraint::Unconstrained,
        )
        .await
    }

    async fn delete<D>(&self, uri: &str, message: Option<reqwest::Body>) -> Result<D>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        self.request_entity(
            http::Method::DELETE,
            &(self.host.clone() + uri),
            message,
            crate::utils::MediaType::Json,
            crate::auth::AuthenticationConstraint::Unconstrained,
        )
        .await
    }

    /// "unfold" paginated results of a vector of items
    async fn unfold<D>(&self, uri: &str) -> Result<Vec<D>>
    where
        D: serde::de::DeserializeOwned + 'static + Send,
    {
        let mut global_items = Vec::new();
        let (new_link, mut items) = self.get_pages(uri).await.unwrap();
        let mut link = new_link;
        items.reverse();
        while !items.is_empty() {
            match items.pop() {
                Some(item) => global_items.push(item),
                // We need to get the next link.
                None => {
                    if let Some(url) = link.as_ref().and_then(|l| crate::utils::next_link(l)) {
                        let url = reqwest::Url::parse(&url).unwrap();
                        let (new_link, new_items) = self.get_pages_url(&url).await?;
                        link = new_link;
                        items = new_items;
                    }
                }
            }
        }

        Ok(global_items)
    }

    /**
    * GitHub API Root.
    *
    * This function performs a `GET` to the `/` endpoint.
    *
    * Get Hypermedia links to resources accessible in GitHub's REST API
    *
    * FROM: <https://docs.github.com/rest/overview/resources-in-the-rest-api#root-endpoint>
    */
    pub async fn meta_root(&self) -> Result<types::GetGithubApiRootOkResponse> {
        let url = "".to_string();
        self.get(&url).await
    }

    /**
    * Get the authenticated app.
    *
    * This function performs a `GET` to the `/app` endpoint.
    *
    * Returns the GitHub App associated with the authentication credentials used. To see how many app installations are associated with this GitHub App, see the `installations_count` in the response. For more details about your app's installations, see the "[List installations for the authenticated app](https://docs.github.com/rest/reference/apps#list-installations-for-the-authenticated-app)" endpoint.
    *
    * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#get-the-authenticated-app>
    */
    pub async fn apps_get_authenticated(&self) -> Result<types::Integration> {
        let url = "/app".to_string();
        self.get(&url).await
    }

    /**
    * Create a GitHub App from a manifest.
    *
    * This function performs a `POST` to the `/app-manifests/{code}/conversions` endpoint.
    *
    * Use this endpoint to complete the handshake necessary when implementing the [GitHub App Manifest flow](https://docs.github.com/apps/building-github-apps/creating-github-apps-from-a-manifest/). When you create a GitHub App with the manifest flow, you receive a temporary `code` used to retrieve the GitHub App's `id`, `pem` (private key), and `webhook_secret`.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#create-a-github-app-from-a-manifest>
    */
    pub async fn apps_create_from_manifest(
        &self,
        code: &str,
        body: &types::CreateGithubAppFromManifestRequest,
    ) -> Result<types::PostCreateGithubAppFromManifestCreatedResponse> {
        let url = format!(
            "/app-manifests/{}/conversions",
            progenitor_support::encode_path(&code.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a webhook configuration for an app.
    *
    * This function performs a `GET` to the `/app/hook/config` endpoint.
    *
    * Returns the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
    *
    * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#get-a-webhook-configuration-for-an-app>
    */
    pub async fn apps_get_webhook_config_for_app(&self) -> Result<types::WebhookConfig> {
        let url = "/app/hook/config".to_string();
        self.get(&url).await
    }

    /**
    * Update a webhook configuration for an app.
    *
    * This function performs a `PATCH` to the `/app/hook/config` endpoint.
    *
    * Updates the webhook configuration for a GitHub App. For more information about configuring a webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
    *
    * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#update-a-webhook-configuration-for-an-app>
    */
    pub async fn apps_update_webhook_config_for_app(
        &self,
        body: &types::UpdateWebhookConfigurationAppRequest,
    ) -> Result<types::WebhookConfig> {
        let url = "/app/hook/config".to_string();
        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List installations for the authenticated app.
    *
    * This function performs a `GET` to the `/app/installations` endpoint.
    *
    * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
    *
    * The permissions the installation has are included under the `permissions` key.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#list-installations-for-the-authenticated-app>
    */
    pub async fn apps_list_installations(
        &self,
        per_page: i64,
        page: i64,
        since: DateTime<Utc>,
        outdated: &str,
    ) -> Result<Vec<types::Installation>> {
        let url = format!(
            "/app/installations?outdated={}&page={}&per_page={}&since={}",
            outdated.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get an installation for the authenticated app.
    *
    * This function performs a `GET` to the `/app/installations/{installation_id}` endpoint.
    *
    * Enables an authenticated GitHub App to find an installation's information using the installation id. The installation's account type (`target_type`) will be either an organization or a user account, depending which account the repository belongs to.
    *
    * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#get-an-installation-for-the-authenticated-app>
    */
    pub async fn apps_get_installation(&self, installation_id: i64) -> Result<types::Installation> {
        let url = format!(
            "/app/installations/{}",
            progenitor_support::encode_path(&installation_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete an installation for the authenticated app.
    *
    * This function performs a `DELETE` to the `/app/installations/{installation_id}` endpoint.
    *
    * Uninstalls a GitHub App on a user, organization, or business account. If you prefer to temporarily suspend an app's access to your account's resources, then we recommend the "[Suspend an app installation](https://docs.github.com/rest/reference/apps/#suspend-an-app-installation)" endpoint.
    *
    * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#delete-an-installation-for-the-authenticated-app>
    */
    pub async fn apps_delete_installation(&self, installation_id: i64) -> Result<()> {
        let url = format!(
            "/app/installations/{}",
            progenitor_support::encode_path(&installation_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Create an installation access token for an app.
    *
    * This function performs a `POST` to the `/app/installations/{installation_id}/access_tokens` endpoint.
    *
    * Creates an installation access token that enables a GitHub App to make authenticated API requests for the app's installation on an organization or individual account. Installation tokens expire one hour from the time you create them. Using an expired token produces a status code of `401 - Unauthorized`, and requires creating a new installation token. By default the installation token has access to all repositories that the installation can access. To restrict the access to specific repositories, you can provide the `repository_ids` when creating the token. When you omit `repository_ids`, the response does not contain the `repositories` key.
    *
    * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps/#create-an-installation-access-token-for-an-app>
    */
    #[async_recursion]
    pub async fn apps_create_installation_access_token(
        &self,
        installation_id: i64,
        body: &types::CreateInstallationAccessTokenAppRequest,
    ) -> Result<types::InstallationToken> {
        let url = format!(
            "/app/installations/{}/access_tokens",
            progenitor_support::encode_path(&installation_id.to_string()),
        );

        self.post_media(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
            crate::utils::MediaType::Json,
            crate::auth::AuthenticationConstraint::JWT,
        )
        .await
    }

    /**
    * Suspend an app installation.
    *
    * This function performs a `PUT` to the `/app/installations/{installation_id}/suspended` endpoint.
    *
    * Suspends a GitHub App on a user, organization, or business account, which blocks the app from accessing the account's resources. When a GitHub App is suspended, the app's access to the GitHub API or webhook events is blocked for that account.
    *
    * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#suspend-an-app-installation>
    */
    pub async fn apps_suspend_installation(&self, installation_id: i64) -> Result<()> {
        let url = format!(
            "/app/installations/{}/suspended",
            progenitor_support::encode_path(&installation_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Unsuspend an app installation.
    *
    * This function performs a `DELETE` to the `/app/installations/{installation_id}/suspended` endpoint.
    *
    * Removes a GitHub App installation suspension.
    *
    * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#unsuspend-an-app-installation>
    */
    pub async fn apps_unsuspend_installation(&self, installation_id: i64) -> Result<()> {
        let url = format!(
            "/app/installations/{}/suspended",
            progenitor_support::encode_path(&installation_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List your grants.
    *
    * This function performs a `GET` to the `/applications/grants` endpoint.
    *
    * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
    *
    * You can use this API to list the set of OAuth applications that have been granted access to your account. Unlike the [list your authorizations](https://docs.github.com/rest/reference/oauth-authorizations#list-your-authorizations) API, this API does not manage individual tokens. This API will return one entry for each OAuth application that has been granted access to your account, regardless of the number of tokens an application has generated for your user. The list of OAuth applications returned matches what is shown on [the application authorizations settings screen within GitHub](https://github.com/settings/applications#authorized). The `scopes` returned are the union of scopes authorized for the application. For example, if an application has one token with `repo` scope and another token with `user` scope, the grant will return `["repo", "user"]`.
    *
    * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#list-your-grants>
    */
    pub async fn oauth_authorizations_list_grants(
        &self,
        per_page: i64,
        page: i64,
        client_id: &str,
    ) -> Result<Vec<types::ApplicationGrant>> {
        let url = format!(
            "/applications/grants?client_id={}&page={}&per_page={}",
            client_id.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a single grant.
    *
    * This function performs a `GET` to the `/applications/grants/{grant_id}` endpoint.
    *
    * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
    *
    * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#get-a-single-grant>
    */
    pub async fn oauth_authorizations_get_grant(
        &self,
        grant_id: i64,
    ) -> Result<types::ApplicationGrant> {
        let url = format!(
            "/applications/grants/{}",
            progenitor_support::encode_path(&grant_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a grant.
    *
    * This function performs a `DELETE` to the `/applications/grants/{grant_id}` endpoint.
    *
    * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
    *
    * Deleting an OAuth application's grant will also delete all OAuth tokens associated with the application for your user. Once deleted, the application has no access to your account and is no longer listed on [the application authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).
    *
    * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#delete-a-grant>
    */
    pub async fn oauth_authorizations_delete_grant(&self, grant_id: i64) -> Result<()> {
        let url = format!(
            "/applications/grants/{}",
            progenitor_support::encode_path(&grant_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Delete an app authorization.
    *
    * This function performs a `DELETE` to the `/applications/{client_id}/grant` endpoint.
    *
    * OAuth application owners can revoke a grant for their OAuth application and a specific user. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. You must also provide a valid OAuth `access_token` as an input parameter and the grant for the token's owner will be deleted.
    * Deleting an OAuth application's grant will also delete all OAuth tokens associated with the application for the user. Once deleted, the application will have no access to the user's account and will no longer be listed on [the application authorizations settings screen within GitHub](https://github.com/settings/applications#authorized).
    *
    * FROM: <https://docs.github.com/rest/reference/apps#delete-an-app-authorization>
    */
    pub async fn apps_delete_authorization(
        &self,
        client_id: &str,
        body: &types::DeleteAppAuthorizationRequest,
    ) -> Result<()> {
        let url = format!(
            "/applications/{}/grant",
            progenitor_support::encode_path(&client_id.to_string()),
        );

        self.delete(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Revoke a grant for an application.
    *
    * This function performs a `DELETE` to the `/applications/{client_id}/grants/{access_token}` endpoint.
    *
    * **Deprecation Notice:** GitHub will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
    *
    * OAuth application owners can revoke a grant for their OAuth application and a specific user. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. You must also provide a valid token as `:access_token` and the grant for the token's owner will be deleted.
    *
    * Deleting an OAuth application's grant will also delete all OAuth tokens associated with the application for the user. Once deleted, the application will have no access to the user's account and will no longer be listed on [the Applications settings page under "Authorized OAuth Apps" on GitHub](https://github.com/settings/applications#authorized).
    *
    * FROM: <https://docs.github.com/rest/reference/apps#revoke-a-grant-for-an-application>
    */
    pub async fn apps_revoke_grant_for_application(
        &self,
        client_id: &str,
        access_token: &str,
    ) -> Result<()> {
        let url = format!(
            "/applications/{}/grants/{}",
            progenitor_support::encode_path(&client_id.to_string()),
            progenitor_support::encode_path(&access_token.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Check a token.
    *
    * This function performs a `POST` to the `/applications/{client_id}/token` endpoint.
    *
    * OAuth applications can use a special API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) to use this endpoint, where the username is the OAuth application `client_id` and the password is its `client_secret`. Invalid tokens will return `404 NOT FOUND`.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#check-a-token>
    */
    pub async fn apps_check_token(
        &self,
        client_id: &str,
        body: &types::CheckTokenRequest,
    ) -> Result<types::Authorization> {
        let url = format!(
            "/applications/{}/token",
            progenitor_support::encode_path(&client_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete an app token.
    *
    * This function performs a `DELETE` to the `/applications/{client_id}/token` endpoint.
    *
    * OAuth application owners can revoke a single token for an OAuth application. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#delete-an-app-token>
    */
    pub async fn apps_delete_token(
        &self,
        client_id: &str,
        body: &types::DeleteAppTokenRequest,
    ) -> Result<()> {
        let url = format!(
            "/applications/{}/token",
            progenitor_support::encode_path(&client_id.to_string()),
        );

        self.delete(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Reset a token.
    *
    * This function performs a `PATCH` to the `/applications/{client_id}/token` endpoint.
    *
    * OAuth applications can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the "token" property in the response because changes take effect immediately. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#reset-a-token>
    */
    pub async fn apps_reset_token(
        &self,
        client_id: &str,
        body: &types::ResetTokenRequest,
    ) -> Result<types::Authorization> {
        let url = format!(
            "/applications/{}/token",
            progenitor_support::encode_path(&client_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Create a scoped access token.
    *
    * This function performs a `POST` to the `/applications/{client_id}/token/scoped` endpoint.
    *
    * Use a non-scoped user-to-server OAuth access token to create a repository scoped and/or permission scoped user-to-server OAuth access token. You can specify which repositories the token can access and which permissions are granted to the token. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#create-a-scoped-access-token>
    */
    pub async fn apps_scope_token(
        &self,
        client_id: &str,
        body: &types::CreateScopedAccessTokenRequest,
    ) -> Result<types::Authorization> {
        let url = format!(
            "/applications/{}/token/scoped",
            progenitor_support::encode_path(&client_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Check an authorization.
    *
    * This function performs a `GET` to the `/applications/{client_id}/tokens/{access_token}` endpoint.
    *
    * **Deprecation Notice:** GitHub will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
    *
    * OAuth applications can use a special API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#check-an-authorization>
    */
    pub async fn apps_check_authorization(
        &self,
        client_id: &str,
        access_token: &str,
    ) -> Result<types::GetCheckAuthorizationOkResponse> {
        let url = format!(
            "/applications/{}/tokens/{}",
            progenitor_support::encode_path(&client_id.to_string()),
            progenitor_support::encode_path(&access_token.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Reset an authorization.
    *
    * This function performs a `POST` to the `/applications/{client_id}/tokens/{access_token}` endpoint.
    *
    * **Deprecation Notice:** GitHub will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
    *
    * OAuth applications can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the "token" property in the response because changes take effect immediately. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#reset-an-authorization>
    */
    pub async fn apps_reset_authorization(
        &self,
        client_id: &str,
        access_token: &str,
    ) -> Result<types::Authorization> {
        let url = format!(
            "/applications/{}/tokens/{}",
            progenitor_support::encode_path(&client_id.to_string()),
            progenitor_support::encode_path(&access_token.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Revoke an authorization for an application.
    *
    * This function performs a `DELETE` to the `/applications/{client_id}/tokens/{access_token}` endpoint.
    *
    * **Deprecation Notice:** GitHub will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
    *
    * OAuth application owners can revoke a single token for an OAuth application. You must use [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#revoke-an-authorization-for-an-application>
    */
    pub async fn apps_revoke_authorization_for_application(
        &self,
        client_id: &str,
        access_token: &str,
    ) -> Result<()> {
        let url = format!(
            "/applications/{}/tokens/{}",
            progenitor_support::encode_path(&client_id.to_string()),
            progenitor_support::encode_path(&access_token.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get an app.
    *
    * This function performs a `GET` to the `/apps/{app_slug}` endpoint.
    *
    * **Note**: The `:app_slug` is just the URL-friendly name of your GitHub App. You can find this on the settings page for your GitHub App (e.g., `https://github.com/settings/apps/:app_slug`).
    *
    * If the GitHub App you specify is public, you can access this endpoint without authenticating. If the GitHub App you specify is private, you must authenticate with a [personal access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/) or an [installation access token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps/#get-an-app>
    */
    pub async fn apps_get_by_slug(&self, app_slug: &str) -> Result<types::Integration> {
        let url = format!(
            "/apps/{}",
            progenitor_support::encode_path(&app_slug.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List your authorizations.
    *
    * This function performs a `GET` to the `/authorizations` endpoint.
    *
    * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
    *
    * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#list-your-authorizations>
    */
    pub async fn oauth_authorizations_list_authorizations(
        &self,
        per_page: i64,
        page: i64,
        client_id: &str,
    ) -> Result<Vec<types::Authorization>> {
        let url = format!(
            "/authorizations?client_id={}&page={}&per_page={}",
            client_id.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a new authorization.
    *
    * This function performs a `POST` to the `/authorizations` endpoint.
    *
    * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
    *
    * **Warning:** Apps must use the [web application flow](https://docs.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will be unable to access GitHub SAML organizations. For more information, see the [blog post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
    *
    * Creates OAuth tokens using [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication). If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
    *
    * To create tokens for a particular OAuth application using this endpoint, you must authenticate as the user you want to create an authorization for and provide the app's client ID and secret, found on your OAuth application's settings page. If your OAuth application intends to create multiple tokens for one user, use `fingerprint` to differentiate between them.
    *
    * You can also create tokens on GitHub from the [personal access tokens settings](https://github.com/settings/tokens) page. Read more about these tokens in [the GitHub Help documentation](https://help.github.com/articles/creating-an-access-token-for-command-line-use).
    *
    * Organizations that enforce SAML SSO require personal access tokens to be allowed. Read more about allowing tokens in [the GitHub Help documentation](https://help.github.com/articles/about-identity-and-access-management-with-saml-single-sign-on).
    *
    * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#create-a-new-authorization>
    */
    pub async fn oauth_authorizations_create_authorization(
        &self,
        body: &types::CreateNewAuthorizationRequest,
    ) -> Result<types::Authorization> {
        let url = "/authorizations".to_string();
        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get-or-create an authorization for a specific app.
    *
    * This function performs a `PUT` to the `/authorizations/clients/{client_id}` endpoint.
    *
    * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
    *
    * **Warning:** Apps must use the [web application flow](https://docs.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will be unable to access GitHub SAML organizations. For more information, see the [blog post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
    *
    * Creates a new authorization for the specified OAuth application, only if an authorization for that application doesn't already exist for the user. The URL includes the 20 character client ID for the OAuth app that is requesting the token. It returns the user's existing authorization for the application if one is present. Otherwise, it creates and returns a new one.
    *
    * If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
    *
    * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
    *
    * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#get-or-create-an-authorization-for-a-specific-app>
    */
    pub async fn oauth_authorizations_get_or_create_authorization_for_app(
        &self,
        client_id: &str,
        body: &types::GetorCreateAuthorizationSpecificAppRequest,
    ) -> Result<types::Authorization> {
        let url = format!(
            "/authorizations/clients/{}",
            progenitor_support::encode_path(&client_id.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get-or-create an authorization for a specific app and fingerprint.
    *
    * This function performs a `PUT` to the `/authorizations/clients/{client_id}/{fingerprint}` endpoint.
    *
    * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
    *
    * **Warning:** Apps must use the [web application flow](https://docs.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens that work with GitHub SAML organizations. OAuth tokens created using the Authorizations API will be unable to access GitHub SAML organizations. For more information, see the [blog post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
    *
    * This method will create a new authorization for the specified OAuth application, only if an authorization for that application and fingerprint do not already exist for the user. The URL includes the 20 character client ID for the OAuth app that is requesting the token. `fingerprint` is a unique string to distinguish an authorization from others created for the same client ID and user. It returns the user's existing authorization for the application if one is present. Otherwise, it creates and returns a new one.
    *
    * If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
    *
    * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#get-or-create-an-authorization-for-a-specific-app-and-fingerprint>
    */
    pub async fn oauth_authorizations_get_or_create_authorization_for_app_and_fingerprint(
        &self,
        client_id: &str,
        fingerprint: &str,
        body: &types::GetorCreateAuthorizationSpecificAppandFingerprintRequest,
    ) -> Result<types::Authorization> {
        let url = format!(
            "/authorizations/clients/{}/{}",
            progenitor_support::encode_path(&client_id.to_string()),
            progenitor_support::encode_path(&fingerprint.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a single authorization.
    *
    * This function performs a `GET` to the `/authorizations/{authorization_id}` endpoint.
    *
    * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
    *
    * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#get-a-single-authorization>
    */
    pub async fn oauth_authorizations_get_authorization(
        &self,
        authorization_id: i64,
    ) -> Result<types::Authorization> {
        let url = format!(
            "/authorizations/{}",
            progenitor_support::encode_path(&authorization_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete an authorization.
    *
    * This function performs a `DELETE` to the `/authorizations/{authorization_id}` endpoint.
    *
    * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
    *
    * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#delete-an-authorization>
    */
    pub async fn oauth_authorizations_delete_authorization(
        &self,
        authorization_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/authorizations/{}",
            progenitor_support::encode_path(&authorization_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update an existing authorization.
    *
    * This function performs a `PATCH` to the `/authorizations/{authorization_id}` endpoint.
    *
    * **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
    *
    * If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
    *
    * You can only send one of these scope keys at a time.
    *
    * FROM: <https://docs.github.com/rest/reference/oauth-authorizations#update-an-existing-authorization>
    */
    pub async fn oauth_authorizations_update_authorization(
        &self,
        authorization_id: i64,
        body: &types::UpdateExistingAuthorizationRequest,
    ) -> Result<types::Authorization> {
        let url = format!(
            "/authorizations/{}",
            progenitor_support::encode_path(&authorization_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get all codes of conduct.
    *
    * This function performs a `GET` to the `/codes_of_conduct` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/codes-of-conduct#get-all-codes-of-conduct>
    */
    pub async fn codes_of_conduct_get_all_codes_of_conduct(
        &self,
    ) -> Result<Vec<types::CodeofConduct>> {
        let url = "/codes_of_conduct".to_string();
        self.get_all_pages(&url).await
    }

    /**
    * Get a code of conduct.
    *
    * This function performs a `GET` to the `/codes_of_conduct/{key}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/codes-of-conduct#get-a-code-of-conduct>
    */
    pub async fn codes_of_conduct_get_conduct_code(
        &self,
        key: &str,
    ) -> Result<types::CodeofConduct> {
        let url = format!(
            "/codes_of_conduct/{}",
            progenitor_support::encode_path(&key.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get emojis.
    *
    * This function performs a `GET` to the `/emojis` endpoint.
    *
    * Lists all the emojis available to use on GitHub.
    *
    * FROM: <https://docs.github.com/rest/reference/emojis#get-emojis>
    */
    pub async fn emojis_get(&self) -> Result<types::GetEmojisOkResponse> {
        let url = "/emojis".to_string();
        self.get(&url).await
    }

    /**
    * Get GitHub Actions permissions for an enterprise.
    *
    * This function performs a `GET` to the `/enterprises/{enterprise}/actions/permissions` endpoint.
    *
    * Gets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#get-github-actions-permissions-for-an-enterprise>
    */
    pub async fn enterprise_admin_get_github_actions_permissions_enterprise(
        &self,
        enterprise: &str,
    ) -> Result<types::ActionsEnterprisePermissions> {
        let url = format!(
            "/enterprises/{}/actions/permissions",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Set GitHub Actions permissions for an enterprise.
    *
    * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/permissions` endpoint.
    *
    * Sets the GitHub Actions permissions policy for organizations and allowed actions in an enterprise.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#set-github-actions-permissions-for-an-enterprise>
    */
    pub async fn enterprise_admin_set_github_actions_permissions_enterprise(
        &self,
        enterprise: &str,
        body: &types::SetGithubActionsPermissionsEnterpriseRequest,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/permissions",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List selected organizations enabled for GitHub Actions in an enterprise.
    *
    * This function performs a `GET` to the `/enterprises/{enterprise}/actions/permissions/organizations` endpoint.
    *
    * Lists the organizations that are selected to have GitHub Actions enabled in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-selected-organizations-enabled-for-github-actions-in-an-enterprise>
    */
    pub async fn enterprise_admin_list_selected_organizations_enabled_github_actions_enterprise(
        &self,
        enterprise: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListSelectedOrganizationsEnabledGithubActionsinEnterpriseOkResponse> {
        let url = format!(
            "/enterprises/{}/actions/permissions/organizations?page={}&per_page={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Set selected organizations enabled for GitHub Actions in an enterprise.
    *
    * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/permissions/organizations` endpoint.
    *
    * Replaces the list of selected organizations that are enabled for GitHub Actions in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#set-selected-organizations-enabled-for-github-actions-in-an-enterprise>
    */
    pub async fn enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise(
        &self,
        enterprise: &str,
        body: &types::SetSelectedOrganizationsEnabledGithubActionsinEnterpriseRequest,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/permissions/organizations",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Enable a selected organization for GitHub Actions in an enterprise.
    *
    * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/permissions/organizations/{org_id}` endpoint.
    *
    * Adds an organization to the list of selected organizations that are enabled for GitHub Actions in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#enable-a-selected-organization-for-github-actions-in-an-enterprise>
    */
    pub async fn enterprise_admin_enable_selected_organization_github_actions_enterprise(
        &self,
        enterprise: &str,
        org_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/permissions/organizations/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&org_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Disable a selected organization for GitHub Actions in an enterprise.
    *
    * This function performs a `DELETE` to the `/enterprises/{enterprise}/actions/permissions/organizations/{org_id}` endpoint.
    *
    * Removes an organization from the list of selected organizations that are enabled for GitHub Actions in an enterprise. To use this endpoint, the enterprise permission policy for `enabled_organizations` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#disable-a-selected-organization-for-github-actions-in-an-enterprise>
    */
    pub async fn enterprise_admin_disable_selected_organization_github_actions_enterprise(
        &self,
        enterprise: &str,
        org_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/permissions/organizations/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&org_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get allowed actions for an enterprise.
    *
    * This function performs a `GET` to the `/enterprises/{enterprise}/actions/permissions/selected-actions` endpoint.
    *
    * Gets the selected actions that are allowed in an enterprise. To use this endpoint, the enterprise permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#get-allowed-actions-for-an-enterprise>
    */
    pub async fn enterprise_admin_get_allowed_actions_enterprise(
        &self,
        enterprise: &str,
    ) -> Result<types::SelectedActions> {
        let url = format!(
            "/enterprises/{}/actions/permissions/selected-actions",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Set allowed actions for an enterprise.
    *
    * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/permissions/selected-actions` endpoint.
    *
    * Sets the actions that are allowed in an enterprise. To use this endpoint, the enterprise permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#set-allowed-actions-for-an-enterprise>
    */
    pub async fn enterprise_admin_set_allowed_actions_enterprise(
        &self,
        enterprise: &str,
        body: &types::SelectedActions,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/permissions/selected-actions",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List self-hosted runner groups for an enterprise.
    *
    * This function performs a `GET` to the `/enterprises/{enterprise}/actions/runner-groups` endpoint.
    *
    * Lists all self-hosted runner groups for an enterprise.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-self-hosted-runner-groups-for-an-enterprise>
    */
    pub async fn enterprise_admin_list_self_hosted_runner_groups_for_enterprise(
        &self,
        enterprise: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListSelfDataHostedRunnerGroupsEnterpriseOkResponse> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups?page={}&per_page={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Create a self-hosted runner group for an enterprise.
    *
    * This function performs a `POST` to the `/enterprises/{enterprise}/actions/runner-groups` endpoint.
    *
    * Creates a new self-hosted runner group for an enterprise.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#create-self-hosted-runner-group-for-an-enterprise>
    */
    pub async fn enterprise_admin_create_self_hosted_runner_group_for_enterprise(
        &self,
        enterprise: &str,
        body: &types::CreateSelfDataHostedRunnerGroupEnterpriseRequest,
    ) -> Result<types::RunnerGroupsEnterprise> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a self-hosted runner group for an enterprise.
    *
    * This function performs a `GET` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}` endpoint.
    *
    * Gets a specific self-hosted runner group for an enterprise.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#get-a-self-hosted-runner-group-for-an-enterprise>
    */
    pub async fn enterprise_admin_get_self_hosted_runner_group_for_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
    ) -> Result<types::RunnerGroupsEnterprise> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a self-hosted runner group from an enterprise.
    *
    * This function performs a `DELETE` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}` endpoint.
    *
    * Deletes a self-hosted runner group for an enterprise.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#delete-a-self-hosted-runner-group-from-an-enterprise>
    */
    pub async fn enterprise_admin_delete_self_hosted_runner_group_from_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a self-hosted runner group for an enterprise.
    *
    * This function performs a `PATCH` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}` endpoint.
    *
    * Updates the `name` and `visibility` of a self-hosted runner group in an enterprise.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#update-a-self-hosted-runner-group-for-an-enterprise>
    */
    pub async fn enterprise_admin_update_self_hosted_runner_group_for_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        body: &types::UpdateSelfDataHostedRunnerGroupEnterpriseRequest,
    ) -> Result<types::RunnerGroupsEnterprise> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List organization access to a self-hosted runner group in an enterprise.
    *
    * This function performs a `GET` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations` endpoint.
    *
    * Lists the organizations with access to a self-hosted runner group.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-organization-access-to-a-self-hosted-runner-group-in-a-enterprise>
    */
    pub async fn enterprise_admin_list_org_access_to_self_hosted_runner_group_in_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListOrganizationAccessSelfDataHostedRunnerGroupinEnterpriseOkResponse>
    {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/organizations?page={}&per_page={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Set organization access for a self-hosted runner group in an enterprise.
    *
    * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations` endpoint.
    *
    * Replaces the list of organizations that have access to a self-hosted runner configured in an enterprise.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#set-organization-access-to-a-self-hosted-runner-group-in-an-enterprise>
    */
    pub async fn enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        body: &types::SetOrganizationAccessSelfDataHostedRunnerGroupinEnterpriseRequest,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/organizations",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Add organization access to a self-hosted runner group in an enterprise.
    *
    * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}` endpoint.
    *
    * Adds an organization to the list of selected organizations that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#add-organization-access-to-a-self-hosted-runner-group-in-an-enterprise>
    */
    pub async fn enterprise_admin_add_org_access_to_self_hosted_runner_group_in_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        org_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/organizations/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&org_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Remove organization access to a self-hosted runner group in an enterprise.
    *
    * This function performs a `DELETE` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}` endpoint.
    *
    * Removes an organization from the list of selected organizations that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an enterprise](#create-a-self-hosted-runner-group-for-an-enterprise)."
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#remove-organization-access-to-a-self-hosted-runner-group-in-an-enterprise>
    */
    pub async fn enterprise_admin_remove_org_access_to_self_hosted_runner_group_in_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        org_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/organizations/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&org_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List self-hosted runners in a group for an enterprise.
    *
    * This function performs a `GET` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners` endpoint.
    *
    * Lists the self-hosted runners that are in a specific enterprise group.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-self-hosted-runners-in-a-group-for-an-enterprise>
    */
    pub async fn enterprise_admin_list_self_hosted_runners_in_group_for_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListSelfDataHostedRunnersinGroupEnterpriseOkResponse> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/runners?page={}&per_page={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Set self-hosted runners in a group for an enterprise.
    *
    * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners` endpoint.
    *
    * Replaces the list of self-hosted runners that are part of an enterprise runner group.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#set-self-hosted-runners-in-a-group-for-an-enterprise>
    */
    pub async fn enterprise_admin_set_self_hosted_runners_in_group_for_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        body: &types::SetSelfDataHostedRunnersinGroupEnterpriseRequest,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/runners",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Add a self-hosted runner to a group for an enterprise.
    *
    * This function performs a `PUT` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}` endpoint.
    *
    * Adds a self-hosted runner to a runner group configured in an enterprise.
    *
    * You must authenticate using an access token with the `admin:enterprise`
    * scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#add-a-self-hosted-runner-to-a-group-for-an-enterprise>
    */
    pub async fn enterprise_admin_add_self_hosted_runner_to_group_for_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        runner_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/runners/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Remove a self-hosted runner from a group for an enterprise.
    *
    * This function performs a `DELETE` to the `/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}` endpoint.
    *
    * Removes a self-hosted runner from a group configured in an enterprise. The runner is then returned to the default group.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#remove-a-self-hosted-runner-from-a-group-for-an-enterprise>
    */
    pub async fn enterprise_admin_remove_self_hosted_runner_from_group_for_enterprise(
        &self,
        enterprise: &str,
        runner_group_id: i64,
        runner_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runner-groups/{}/runners/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List self-hosted runners for an enterprise.
    *
    * This function performs a `GET` to the `/enterprises/{enterprise}/actions/runners` endpoint.
    *
    * Lists all self-hosted runners configured for an enterprise.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-self-hosted-runners-for-an-enterprise>
    */
    pub async fn enterprise_admin_list_self_hosted_runners_for_enterprise(
        &self,
        enterprise: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListSelfDataHostedRunnersEnterpriseOkResponse> {
        let url = format!(
            "/enterprises/{}/actions/runners?page={}&per_page={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * List runner applications for an enterprise.
    *
    * This function performs a `GET` to the `/enterprises/{enterprise}/actions/runners/downloads` endpoint.
    *
    * Lists binaries for the runner application that you can download and run.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-runner-applications-for-an-enterprise>
    */
    pub async fn enterprise_admin_list_runner_applications_for_enterprise(
        &self,
        enterprise: &str,
    ) -> Result<Vec<types::RunnerApplication>> {
        let url = format!(
            "/enterprises/{}/actions/runners/downloads",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a registration token for an enterprise.
    *
    * This function performs a `POST` to the `/enterprises/{enterprise}/actions/runners/registration-token` endpoint.
    *
    * Returns a token that you can pass to the `config` script. The token expires after one hour.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * #### Example using registration token
    *
    * Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.
    *
    * ```
    * ./config.sh --url https://github.com/enterprises/octo-enterprise --token TOKEN
    * ```
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#create-a-registration-token-for-an-enterprise>
    */
    pub async fn enterprise_admin_create_registration_token_for_enterprise(
        &self,
        enterprise: &str,
    ) -> Result<types::AuthenticationToken> {
        let url = format!(
            "/enterprises/{}/actions/runners/registration-token",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Create a remove token for an enterprise.
    *
    * This function performs a `POST` to the `/enterprises/{enterprise}/actions/runners/remove-token` endpoint.
    *
    * Returns a token that you can pass to the `config` script to remove a self-hosted runner from an enterprise. The token expires after one hour.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * #### Example using remove token
    *
    * To remove your self-hosted runner from an enterprise, replace `TOKEN` with the remove token provided by this
    * endpoint.
    *
    * ```
    * ./config.sh remove --token TOKEN
    * ```
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#create-a-remove-token-for-an-enterprise>
    */
    pub async fn enterprise_admin_create_remove_token_for_enterprise(
        &self,
        enterprise: &str,
    ) -> Result<types::AuthenticationToken> {
        let url = format!(
            "/enterprises/{}/actions/runners/remove-token",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Get a self-hosted runner for an enterprise.
    *
    * This function performs a `GET` to the `/enterprises/{enterprise}/actions/runners/{runner_id}` endpoint.
    *
    * Gets a specific self-hosted runner configured in an enterprise.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#get-a-self-hosted-runner-for-an-enterprise>
    */
    pub async fn enterprise_admin_get_self_hosted_runner_for_enterprise(
        &self,
        enterprise: &str,
        runner_id: i64,
    ) -> Result<types::Runner> {
        let url = format!(
            "/enterprises/{}/actions/runners/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a self-hosted runner from an enterprise.
    *
    * This function performs a `DELETE` to the `/enterprises/{enterprise}/actions/runners/{runner_id}` endpoint.
    *
    * Forces the removal of a self-hosted runner from an enterprise. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.
    *
    * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#delete-self-hosted-runner-from-an-enterprise>
    */
    pub async fn enterprise_admin_delete_self_hosted_runner_from_enterprise(
        &self,
        enterprise: &str,
        runner_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/enterprises/{}/actions/runners/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get the audit log for an enterprise.
    *
    * This function performs a `GET` to the `/enterprises/{enterprise}/audit-log` endpoint.
    *
    * Gets the audit log for an enterprise. To use this endpoint, you must be an enterprise admin, and you must use an access token with the `admin:enterprise` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#get-the-audit-log-for-an-enterprise>
    */
    pub async fn enterprise_admin_get_audit_log(
        &self,
        enterprise: &str,
        phrase: &str,
        include: &str,
        after: &str,
        before: &str,
        order: &str,
        page: i64,
        per_page: i64,
    ) -> Result<Vec<types::AuditLogEvent>> {
        let url = format!("/enterprises/{}/audit-log?after={}&before={}&include={}&order={}&page={}&per_page={}&phrase={}",
            progenitor_support::encode_path(&enterprise.to_string()),
after.to_string(), before.to_string(), include.to_string(), order.to_string(), format!("{}", page), format!("{}", per_page), phrase.to_string(),         );

        self.get_all_pages(&url).await
    }

    /**
    * Get GitHub Actions billing for an enterprise.
    *
    * This function performs a `GET` to the `/enterprises/{enterprise}/settings/billing/actions` endpoint.
    *
    * Gets the summary of the free and paid GitHub Actions minutes used.
    *
    * Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
    *
    * The authenticated user must be an enterprise admin.
    *
    * FROM: <https://docs.github.com/rest/reference/billing#get-github-actions-billing-for-an-enterprise>
    */
    pub async fn billing_get_github_actions_billing_ghe(
        &self,
        enterprise: &str,
    ) -> Result<types::ActionsBillingUsage> {
        let url = format!(
            "/enterprises/{}/settings/billing/actions",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get GitHub Packages billing for an enterprise.
    *
    * This function performs a `GET` to the `/enterprises/{enterprise}/settings/billing/packages` endpoint.
    *
    * Gets the free and paid storage used for GitHub Packages in gigabytes.
    *
    * Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
    *
    * The authenticated user must be an enterprise admin.
    *
    * FROM: <https://docs.github.com/rest/reference/billing#get-github-packages-billing-for-an-enterprise>
    */
    pub async fn billing_get_github_packages_billing_ghe(
        &self,
        enterprise: &str,
    ) -> Result<types::PackagesBillingUsage> {
        let url = format!(
            "/enterprises/{}/settings/billing/packages",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get shared storage billing for an enterprise.
    *
    * This function performs a `GET` to the `/enterprises/{enterprise}/settings/billing/shared-storage` endpoint.
    *
    * Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
    *
    * Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
    *
    * The authenticated user must be an enterprise admin.
    *
    * FROM: <https://docs.github.com/rest/reference/billing#get-shared-storage-billing-for-an-enterprise>
    */
    pub async fn billing_get_shared_storage_billing_ghe(
        &self,
        enterprise: &str,
    ) -> Result<types::CombinedBillingUsage> {
        let url = format!(
            "/enterprises/{}/settings/billing/shared-storage",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List public events.
    *
    * This function performs a `GET` to the `/events` endpoint.
    *
    * We delay the public events feed by five minutes, which means the most recent event returned by the public events API actually occurred at least five minutes ago.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-public-events>
    */
    pub async fn activity_list_public_events(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Event>> {
        let url = format!(
            "/events?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get feeds.
    *
    * This function performs a `GET` to the `/feeds` endpoint.
    *
    * GitHub provides several timeline resources in [Atom](http://en.wikipedia.org/wiki/Atom_(standard)) format. The Feeds API lists all the feeds available to the authenticated user:
    *
    * *   **Timeline**: The GitHub global public timeline
    * *   **User**: The public timeline for any user, using [URI template](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia)
    * *   **Current user public**: The public timeline for the authenticated user
    * *   **Current user**: The private timeline for the authenticated user
    * *   **Current user actor**: The private timeline for activity created by the authenticated user
    * *   **Current user organizations**: The private timeline for the organizations the authenticated user is a member of.
    * *   **Security advisories**: A collection of public announcements that provide information about security-related vulnerabilities in software on GitHub.
    *
    * **Note**: Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) since current feed URIs use the older, non revocable auth tokens.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#get-feeds>
    */
    pub async fn activity_get_feeds(&self) -> Result<types::Feed> {
        let url = "/feeds".to_string();
        self.get(&url).await
    }

    /**
    * List gists for the authenticated user.
    *
    * This function performs a `GET` to the `/gists` endpoint.
    *
    * Lists the authenticated user's gists or if called anonymously, this endpoint returns all public gists:
    *
    * FROM: <https://docs.github.com/rest/reference/gists#list-gists-for-the-authenticated-user>
    */
    pub async fn gists_list(
        &self,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::BaseGist>> {
        let url = format!(
            "/gists?page={}&per_page={}&since={}",
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a gist.
    *
    * This function performs a `POST` to the `/gists` endpoint.
    *
    * Allows you to add a new gist with one or more files.
    *
    * **Note:** Don't name your files "gistfile" with a numerical suffix. This is the format of the automatic naming scheme that Gist uses internally.
    *
    * FROM: <https://docs.github.com/rest/reference/gists#create-a-gist>
    */
    pub async fn gists_create(&self, body: &types::CreateGistRequest) -> Result<types::GistSimple> {
        let url = "/gists".to_string();
        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List public gists.
    *
    * This function performs a `GET` to the `/gists/public` endpoint.
    *
    * List public gists sorted by most recently updated to least recently updated.
    *
    * Note: With [pagination](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination), you can fetch up to 3000 gists. For example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.
    *
    * FROM: <https://docs.github.com/rest/reference/gists#list-public-gists>
    */
    pub async fn gists_list_public(
        &self,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::BaseGist>> {
        let url = format!(
            "/gists/public?page={}&per_page={}&since={}",
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List starred gists.
    *
    * This function performs a `GET` to the `/gists/starred` endpoint.
    *
    * List the authenticated user's starred gists:
    *
    * FROM: <https://docs.github.com/rest/reference/gists#list-starred-gists>
    */
    pub async fn gists_list_starred(
        &self,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::BaseGist>> {
        let url = format!(
            "/gists/starred?page={}&per_page={}&since={}",
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a gist.
    *
    * This function performs a `GET` to the `/gists/{gist_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/gists#get-a-gist>
    */
    pub async fn gists_get(&self, gist_id: &str) -> Result<types::GistSimple> {
        let url = format!(
            "/gists/{}",
            progenitor_support::encode_path(&gist_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a gist.
    *
    * This function performs a `DELETE` to the `/gists/{gist_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/gists#delete-a-gist>
    */
    pub async fn gists_delete(&self, gist_id: &str) -> Result<()> {
        let url = format!(
            "/gists/{}",
            progenitor_support::encode_path(&gist_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a gist.
    *
    * This function performs a `PATCH` to the `/gists/{gist_id}` endpoint.
    *
    * Allows you to update or delete a gist file and rename gist files. Files from the previous version of the gist that aren't explicitly changed during an edit are unchanged.
    *
    * FROM: <https://docs.github.com/rest/reference/gists/#update-a-gist>
    */
    pub async fn gists_update(
        &self,
        gist_id: &str,
        body: &types::UpdateGistRequest,
    ) -> Result<types::GistSimple> {
        let url = format!(
            "/gists/{}",
            progenitor_support::encode_path(&gist_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List gist comments.
    *
    * This function performs a `GET` to the `/gists/{gist_id}/comments` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/gists#list-gist-comments>
    */
    pub async fn gists_list_comments(
        &self,
        gist_id: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::GistComment>> {
        let url = format!(
            "/gists/{}/comments?page={}&per_page={}",
            progenitor_support::encode_path(&gist_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a gist comment.
    *
    * This function performs a `POST` to the `/gists/{gist_id}/comments` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/gists#create-a-gist-comment>
    */
    pub async fn gists_create_comment(
        &self,
        gist_id: &str,
        body: &types::CreateGistCommentRequest,
    ) -> Result<types::GistComment> {
        let url = format!(
            "/gists/{}/comments",
            progenitor_support::encode_path(&gist_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a gist comment.
    *
    * This function performs a `GET` to the `/gists/{gist_id}/comments/{comment_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/gists#get-a-gist-comment>
    */
    pub async fn gists_get_comment(
        &self,
        gist_id: &str,
        comment_id: i64,
    ) -> Result<types::GistComment> {
        let url = format!(
            "/gists/{}/comments/{}",
            progenitor_support::encode_path(&gist_id.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a gist comment.
    *
    * This function performs a `DELETE` to the `/gists/{gist_id}/comments/{comment_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/gists#delete-a-gist-comment>
    */
    pub async fn gists_delete_comment(&self, gist_id: &str, comment_id: i64) -> Result<()> {
        let url = format!(
            "/gists/{}/comments/{}",
            progenitor_support::encode_path(&gist_id.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a gist comment.
    *
    * This function performs a `PATCH` to the `/gists/{gist_id}/comments/{comment_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/gists#update-a-gist-comment>
    */
    pub async fn gists_update_comment(
        &self,
        gist_id: &str,
        comment_id: i64,
        body: &types::UpdateGistCommentRequest,
    ) -> Result<types::GistComment> {
        let url = format!(
            "/gists/{}/comments/{}",
            progenitor_support::encode_path(&gist_id.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List gist commits.
    *
    * This function performs a `GET` to the `/gists/{gist_id}/commits` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/gists#list-gist-commits>
    */
    pub async fn gists_list_commits(
        &self,
        gist_id: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::GistCommit>> {
        let url = format!(
            "/gists/{}/commits?page={}&per_page={}",
            progenitor_support::encode_path(&gist_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List gist forks.
    *
    * This function performs a `GET` to the `/gists/{gist_id}/forks` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/gists#list-gist-forks>
    */
    pub async fn gists_list_forks(
        &self,
        gist_id: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::GistSimple>> {
        let url = format!(
            "/gists/{}/forks?page={}&per_page={}",
            progenitor_support::encode_path(&gist_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Fork a gist.
    *
    * This function performs a `POST` to the `/gists/{gist_id}/forks` endpoint.
    *
    * **Note**: This was previously `/gists/:gist_id/fork`.
    *
    * FROM: <https://docs.github.com/rest/reference/gists#fork-a-gist>
    */
    pub async fn gists_fork(&self, gist_id: &str) -> Result<types::BaseGist> {
        let url = format!(
            "/gists/{}/forks",
            progenitor_support::encode_path(&gist_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Check if a gist is starred.
    *
    * This function performs a `GET` to the `/gists/{gist_id}/star` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/gists#check-if-a-gist-is-starred>
    */
    pub async fn gists_check_is_starred(&self, gist_id: &str) -> Result<()> {
        let url = format!(
            "/gists/{}/star",
            progenitor_support::encode_path(&gist_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Star a gist.
    *
    * This function performs a `PUT` to the `/gists/{gist_id}/star` endpoint.
    *
    * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
    *
    * FROM: <https://docs.github.com/rest/reference/gists#star-a-gist>
    */
    pub async fn gists_star(&self, gist_id: &str) -> Result<()> {
        let url = format!(
            "/gists/{}/star",
            progenitor_support::encode_path(&gist_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Unstar a gist.
    *
    * This function performs a `DELETE` to the `/gists/{gist_id}/star` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/gists#unstar-a-gist>
    */
    pub async fn gists_unstar(&self, gist_id: &str) -> Result<()> {
        let url = format!(
            "/gists/{}/star",
            progenitor_support::encode_path(&gist_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get a gist revision.
    *
    * This function performs a `GET` to the `/gists/{gist_id}/{sha}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/gists#get-a-gist-revision>
    */
    pub async fn gists_get_revision(&self, gist_id: &str, sha: &str) -> Result<types::GistSimple> {
        let url = format!(
            "/gists/{}/{}",
            progenitor_support::encode_path(&gist_id.to_string()),
            progenitor_support::encode_path(&sha.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get all gitignore templates.
    *
    * This function performs a `GET` to the `/gitignore/templates` endpoint.
    *
    * List all templates available to pass as an option when [creating a repository](https://docs.github.com/rest/reference/repos#create-a-repository-for-the-authenticated-user).
    *
    * FROM: <https://docs.github.com/rest/reference/gitignore#get-all-gitignore-templates>
    */
    pub async fn gitignore_get_all_templates(&self) -> Result<Vec<String>> {
        let url = "/gitignore/templates".to_string();
        self.get_all_pages(&url).await
    }

    /**
    * Get a gitignore template.
    *
    * This function performs a `GET` to the `/gitignore/templates/{name}` endpoint.
    *
    * The API also allows fetching the source of a single template.
    * Use the raw [media type](https://docs.github.com/rest/overview/media-types/) to get the raw contents.
    *
    * FROM: <https://docs.github.com/rest/reference/gitignore#get-a-gitignore-template>
    */
    pub async fn gitignore_get_template(&self, name: &str) -> Result<types::GitignoreTemplate> {
        let url = format!(
            "/gitignore/templates/{}",
            progenitor_support::encode_path(&name.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List repositories accessible to the app installation.
    *
    * This function performs a `GET` to the `/installation/repositories` endpoint.
    *
    * List repositories that an app installation can access.
    *
    * You must use an [installation access token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#list-repositories-accessible-to-the-app-installation>
    */
    pub async fn apps_list_repos_accessible_to_installation(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListRepositoriesAccessibleAppInstallationOkResponse> {
        let url = format!(
            "/installation/repositories?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Revoke an installation access token.
    *
    * This function performs a `DELETE` to the `/installation/token` endpoint.
    *
    * Revokes the installation token you're using to authenticate as an installation and access this endpoint.
    *
    * Once an installation token is revoked, the token is invalidated and cannot be used. Other endpoints that require the revoked installation token must have a new installation token to work. You can create a new token using the "[Create an installation access token for an app](https://docs.github.com/rest/reference/apps#create-an-installation-access-token-for-an-app)" endpoint.
    *
    * You must use an [installation access token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#revoke-an-installation-access-token>
    */
    pub async fn apps_revoke_installation_access_token(&self) -> Result<()> {
        let url = "/installation/token".to_string();
        self.delete(&url, None).await
    }

    /**
    * List issues assigned to the authenticated user.
    *
    * This function performs a `GET` to the `/issues` endpoint.
    *
    * List issues assigned to the authenticated user across all visible repositories including owned repositories, member
    * repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not
    * necessarily assigned to you.
    *
    *
    * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
    * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
    * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
    * request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#list-issues-assigned-to-the-authenticated-user>
    */
    pub async fn issues_list(
        &self,
        filter: &str,
        state: &str,
        labels: &str,
        sort: &str,
        direction: &str,
        since: DateTime<Utc>,
        collab: bool,
        orgs: bool,
        owned: bool,
        pulls: bool,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Issue>> {
        let url = format!("/issues?collab={}&direction={}&filter={}&labels={}&orgs={}&owned={}&page={}&per_page={}&pulls={}&since={}&sort={}&state={}",
format!("{}", collab), direction.to_string(), filter.to_string(), labels.to_string(), format!("{}", orgs), format!("{}", owned), format!("{}", page), format!("{}", per_page), format!("{}", pulls), since.to_rfc3339(), sort.to_string(), state.to_string(),         );

        self.get_all_pages(&url).await
    }

    /**
    * Get all commonly used licenses.
    *
    * This function performs a `GET` to the `/licenses` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/licenses#get-all-commonly-used-licenses>
    */
    pub async fn licenses_get_all_commonly_used(
        &self,
        featured: bool,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::LicenseSimple>> {
        let url = format!(
            "/licenses?featured={}&page={}&per_page={}",
            format!("{}", featured),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a license.
    *
    * This function performs a `GET` to the `/licenses/{license}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/licenses#get-a-license>
    */
    pub async fn licenses_get(&self, license: &str) -> Result<types::License> {
        let url = format!(
            "/licenses/{}",
            progenitor_support::encode_path(&license.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Render a Markdown document.
    *
    * This function performs a `POST` to the `/markdown` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/markdown#render-a-markdown-document>
    */
    pub async fn markdown_render(
        &self,
        body: &types::RenderMarkdownDocumentRequest,
    ) -> Result<String> {
        let url = "/markdown".to_string();
        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Render a Markdown document in raw mode.
    *
    * This function performs a `POST` to the `/markdown/raw` endpoint.
    *
    * You must send Markdown as plain text (using a `Content-Type` header of `text/plain` or `text/x-markdown`) to this endpoint, rather than using JSON format. In raw mode, [GitHub Flavored Markdown](https://github.github.com/gfm/) is not supported and Markdown will be rendered in plain format like a README.md file. Markdown content must be 400 KB or less.
    *
    * FROM: <https://docs.github.com/rest/reference/markdown#render-a-markdown-document-in-raw-mode>
    */
    pub async fn markdown_render_raw<T: Into<reqwest::Body>>(&self, body: T) -> Result<String> {
        let url = "/markdown/raw".to_string();
        self.post(&url, Some(body.into())).await
    }

    /**
    * Get a subscription plan for an account.
    *
    * This function performs a `GET` to the `/marketplace_listing/accounts/{account_id}` endpoint.
    *
    * Shows whether the user or organization account actively subscribes to a plan listed by the authenticated GitHub App. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.
    *
    * GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#get-a-subscription-plan-for-an-account>
    */
    pub async fn apps_get_subscription_plan_for_account(
        &self,
        account_id: i64,
    ) -> Result<types::MarketplacePurchase> {
        let url = format!(
            "/marketplace_listing/accounts/{}",
            progenitor_support::encode_path(&account_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List plans.
    *
    * This function performs a `GET` to the `/marketplace_listing/plans` endpoint.
    *
    * Lists all plans that are part of your GitHub Marketplace listing.
    *
    * GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#list-plans>
    */
    pub async fn apps_list_plans(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MarketplaceListingPlan>> {
        let url = format!(
            "/marketplace_listing/plans?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List accounts for a plan.
    *
    * This function performs a `GET` to the `/marketplace_listing/plans/{plan_id}/accounts` endpoint.
    *
    * Returns user and organization accounts associated with the specified plan, including free plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including the number of seats purchased. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.
    *
    * GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#list-accounts-for-a-plan>
    */
    pub async fn apps_list_accounts_for_plan(
        &self,
        plan_id: i64,
        sort: &str,
        direction: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MarketplacePurchase>> {
        let url = format!(
            "/marketplace_listing/plans/{}/accounts?direction={}&page={}&per_page={}&sort={}",
            progenitor_support::encode_path(&plan_id.to_string()),
            direction.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            sort.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a subscription plan for an account (stubbed).
    *
    * This function performs a `GET` to the `/marketplace_listing/stubbed/accounts/{account_id}` endpoint.
    *
    * Shows whether the user or organization account actively subscribes to a plan listed by the authenticated GitHub App. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.
    *
    * GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#get-a-subscription-plan-for-an-account-stubbed>
    */
    pub async fn apps_get_subscription_plan_for_account_stubbed(
        &self,
        account_id: i64,
    ) -> Result<types::MarketplacePurchase> {
        let url = format!(
            "/marketplace_listing/stubbed/accounts/{}",
            progenitor_support::encode_path(&account_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List plans (stubbed).
    *
    * This function performs a `GET` to the `/marketplace_listing/stubbed/plans` endpoint.
    *
    * Lists all plans that are part of your GitHub Marketplace listing.
    *
    * GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#list-plans-stubbed>
    */
    pub async fn apps_list_plans_stubbed(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MarketplaceListingPlan>> {
        let url = format!(
            "/marketplace_listing/stubbed/plans?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List accounts for a plan (stubbed).
    *
    * This function performs a `GET` to the `/marketplace_listing/stubbed/plans/{plan_id}/accounts` endpoint.
    *
    * Returns repository and organization accounts associated with the specified plan, including free plans. For per-seat pricing, you see the list of accounts that have purchased the plan, including the number of seats purchased. When someone submits a plan change that won't be processed until the end of their billing cycle, you will also see the upcoming pending change.
    *
    * GitHub Apps must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint. OAuth Apps must use [basic authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication) with their client ID and client secret to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#list-accounts-for-a-plan-stubbed>
    */
    pub async fn apps_list_accounts_for_plan_stubbed(
        &self,
        plan_id: i64,
        sort: &str,
        direction: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MarketplacePurchase>> {
        let url = format!("/marketplace_listing/stubbed/plans/{}/accounts?direction={}&page={}&per_page={}&sort={}",
            progenitor_support::encode_path(&plan_id.to_string()),
direction.to_string(), format!("{}", page), format!("{}", per_page), sort.to_string(),         );

        self.get_all_pages(&url).await
    }

    /**
    * Get GitHub meta information.
    *
    * This function performs a `GET` to the `/meta` endpoint.
    *
    * Returns meta information about GitHub, including a list of GitHub's IP addresses. For more information, see "[About GitHub's IP addresses](https://help.github.com/articles/about-github-s-ip-addresses/)."
    *
    * **Note:** The IP addresses shown in the documentation's response are only example values. You must always query the API directly to get the latest list of IP addresses.
    *
    * FROM: <https://docs.github.com/rest/reference/meta#get-github-meta-information>
    */
    pub async fn meta_get(&self) -> Result<types::ApiOverview> {
        let url = "/meta".to_string();
        self.get(&url).await
    }

    /**
    * List public events for a network of repositories.
    *
    * This function performs a `GET` to the `/networks/{owner}/{repo}/events` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-public-events-for-a-network-of-repositories>
    */
    pub async fn activity_list_public_events_for_repo_network(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Event>> {
        let url = format!(
            "/networks/{}/{}/events?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List notifications for the authenticated user.
    *
    * This function performs a `GET` to the `/notifications` endpoint.
    *
    * List all notifications for the current user, sorted by most recently updated.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user>
    */
    pub async fn activity_list_notifications_for_authenticated_user(
        &self,
        all: bool,
        participating: bool,
        since: DateTime<Utc>,
        before: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Thread>> {
        let url = format!(
            "/notifications?all={}&before={}&page={}&participating={}&per_page={}&since={}",
            format!("{}", all),
            before.to_rfc3339(),
            format!("{}", page),
            format!("{}", participating),
            format!("{}", per_page),
            since.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Mark notifications as read.
    *
    * This function performs a `PUT` to the `/notifications` endpoint.
    *
    * Marks all notifications as "read" removes it from the [default view on GitHub](https://github.com/notifications). If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List notifications for the authenticated user](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#mark-notifications-as-read>
    */
    pub async fn activity_mark_notifications_as_read(
        &self,
        body: &types::MarkNotificationsasReadRequest,
    ) -> Result<types::PutMarkNotificationsasReadAcceptedResponse> {
        let url = "/notifications".to_string();
        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a thread.
    *
    * This function performs a `GET` to the `/notifications/threads/{thread_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/activity#get-a-thread>
    */
    pub async fn activity_get_thread(&self, thread_id: i64) -> Result<types::Thread> {
        let url = format!(
            "/notifications/threads/{}",
            progenitor_support::encode_path(&thread_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Mark a thread as read.
    *
    * This function performs a `PATCH` to the `/notifications/threads/{thread_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/activity#mark-a-thread-as-read>
    */
    pub async fn activity_mark_thread_as_read(&self, thread_id: i64) -> Result<()> {
        let url = format!(
            "/notifications/threads/{}",
            progenitor_support::encode_path(&thread_id.to_string()),
        );

        self.patch(&url, None).await
    }

    /**
    * Get a thread subscription for the authenticated user.
    *
    * This function performs a `GET` to the `/notifications/threads/{thread_id}/subscription` endpoint.
    *
    * This checks to see if the current user is subscribed to a thread. You can also [get a repository subscription](https://docs.github.com/rest/reference/activity#get-a-repository-subscription).
    *
    * Note that subscriptions are only generated if a user is participating in a conversation--for example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#get-a-thread-subscription-for-the-authenticated-user>
    */
    pub async fn activity_get_thread_subscription_for_authenticated_user(
        &self,
        thread_id: i64,
    ) -> Result<types::ThreadSubscription> {
        let url = format!(
            "/notifications/threads/{}/subscription",
            progenitor_support::encode_path(&thread_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Set a thread subscription.
    *
    * This function performs a `PUT` to the `/notifications/threads/{thread_id}/subscription` endpoint.
    *
    * If you are watching a repository, you receive notifications for all threads by default. Use this endpoint to ignore future notifications for threads until you comment on the thread or get an **@mention**.
    *
    * You can also use this endpoint to subscribe to threads that you are currently not receiving notifications for or to subscribed to threads that you have previously ignored.
    *
    * Unsubscribing from a conversation in a repository that you are not watching is functionally equivalent to the [Delete a thread subscription](https://docs.github.com/rest/reference/activity#delete-a-thread-subscription) endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#set-a-thread-subscription>
    */
    pub async fn activity_set_thread_subscription(
        &self,
        thread_id: i64,
        body: &types::SetThreadSubscriptionRequest,
    ) -> Result<types::ThreadSubscription> {
        let url = format!(
            "/notifications/threads/{}/subscription",
            progenitor_support::encode_path(&thread_id.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete a thread subscription.
    *
    * This function performs a `DELETE` to the `/notifications/threads/{thread_id}/subscription` endpoint.
    *
    * Mutes all future notifications for a conversation until you comment on the thread or get an **@mention**. If you are watching the repository of the thread, you will still receive notifications. To ignore future notifications for a repository you are watching, use the [Set a thread subscription](https://docs.github.com/rest/reference/activity#set-a-thread-subscription) endpoint and set `ignore` to `true`.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#delete-a-thread-subscription>
    */
    pub async fn activity_delete_thread_subscription(&self, thread_id: i64) -> Result<()> {
        let url = format!(
            "/notifications/threads/{}/subscription",
            progenitor_support::encode_path(&thread_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get Octocat.
    *
    * This function performs a `GET` to the `/octocat` endpoint.
    *
    * Get the octocat as ASCII art
    *
    * FROM: <https://docs.github.com/rest/reference/meta#get-octocat>
    */
    pub async fn meta_get_octocat(&self, s: &str) -> Result<String> {
        let url = format!("/octocat?s={}", s.to_string(),);

        self.get(&url).await
    }

    /**
    * List organizations.
    *
    * This function performs a `GET` to the `/organizations` endpoint.
    *
    * Lists all organizations, in the order that they were created on GitHub.
    *
    * **Note:** Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of organizations.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#list-organizations>
    */
    pub async fn orgs_list(
        &self,
        since: i64,
        per_page: i64,
    ) -> Result<Vec<types::OrganizationSimple>> {
        let url = format!(
            "/organizations?per_page={}&since={}",
            format!("{}", per_page),
            format!("{}", since),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}` endpoint.
    *
    * To see many of the organization response values, you need to be an authenticated organization owner with the `admin:org` scope. When the value of `two_factor_requirement_enabled` is `true`, the organization requires all members, billing managers, and outside collaborators to enable [two-factor authentication](https://help.github.com/articles/securing-your-account-with-two-factor-authentication-2fa/).
    *
    * GitHub Apps with the `Organization plan` permission can use this endpoint to retrieve information about an organization's GitHub plan. See "[Authenticating with GitHub Apps](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/)" for details. For an example response, see 'Response with GitHub plan information' below."
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#get-an-organization>
    */
    pub async fn orgs_get(&self, org: &str) -> Result<types::OrganizationFull> {
        let url = format!(
            "/orgs/{}",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Update an organization.
    *
    * This function performs a `PATCH` to the `/orgs/{org}` endpoint.
    *
    * **Parameter Deprecation Notice:** GitHub will replace and discontinue `members_allowed_repository_creation_type` in favor of more granular permissions. The new input parameters are `members_can_create_public_repositories`, `members_can_create_private_repositories` for all organizations and `members_can_create_internal_repositories` for organizations associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see the [blog post](https://developer.github.com/changes/2019-12-03-internal-visibility-changes).
    *
    * Enables an authenticated organization owner with the `admin:org` scope to update the organization's profile and member privileges.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs/#update-an-organization>
    */
    pub async fn orgs_update(
        &self,
        org: &str,
        body: &types::UpdateOrganizationRequest,
    ) -> Result<types::OrganizationFull> {
        let url = format!(
            "/orgs/{}",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get GitHub Actions permissions for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/actions/permissions` endpoint.
    *
    * Gets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-github-actions-permissions-for-an-organization>
    */
    pub async fn actions_get_github_actions_permissions_organization(
        &self,
        org: &str,
    ) -> Result<types::ActionsOrganizationPermissions> {
        let url = format!(
            "/orgs/{}/actions/permissions",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Set GitHub Actions permissions for an organization.
    *
    * This function performs a `PUT` to the `/orgs/{org}/actions/permissions` endpoint.
    *
    * Sets the GitHub Actions permissions policy for repositories and allowed actions in an organization.
    *
    * If the organization belongs to an enterprise that has set restrictive permissions at the enterprise level, such as `allowed_actions` to `selected` actions, then you cannot override them for the organization.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#set-github-actions-permissions-for-an-organization>
    */
    pub async fn actions_set_github_actions_permissions_organization(
        &self,
        org: &str,
        body: &types::SetGithubActionsPermissionsOrganizationRequest,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/permissions",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List selected repositories enabled for GitHub Actions in an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/actions/permissions/repositories` endpoint.
    *
    * Lists the selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-selected-repositories-enabled-for-github-actions-in-an-organization>
    */
    pub async fn actions_list_selected_repositories_enabled_github_actions_organization(
        &self,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListSelectedRepositoriesEnabledGithubActionsinOrganizationOkResponse>
    {
        let url = format!(
            "/orgs/{}/actions/permissions/repositories?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Set selected repositories enabled for GitHub Actions in an organization.
    *
    * This function performs a `PUT` to the `/orgs/{org}/actions/permissions/repositories` endpoint.
    *
    * Replaces the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#set-selected-repositories-enabled-for-github-actions-in-an-organization>
    */
    pub async fn actions_set_selected_repositories_enabled_github_actions_organization(
        &self,
        org: &str,
        body: &types::SetSelectedRepositoriesEnabledGithubActionsinOrganizationRequest,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/permissions/repositories",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Enable a selected repository for GitHub Actions in an organization.
    *
    * This function performs a `PUT` to the `/orgs/{org}/actions/permissions/repositories/{repository_id}` endpoint.
    *
    * Adds a repository to the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#enable-a-selected-repository-for-github-actions-in-an-organization>
    */
    pub async fn actions_enable_selected_repository_github_actions_organization(
        &self,
        org: &str,
        repository_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/permissions/repositories/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Disable a selected repository for GitHub Actions in an organization.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/actions/permissions/repositories/{repository_id}` endpoint.
    *
    * Removes a repository from the list of selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#disable-a-selected-repository-for-github-actions-in-an-organization>
    */
    pub async fn actions_disable_selected_repository_github_actions_organization(
        &self,
        org: &str,
        repository_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/permissions/repositories/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get allowed actions for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/actions/permissions/selected-actions` endpoint.
    *
    * Gets the selected actions that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization).""
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-allowed-actions-for-an-organization>
    */
    pub async fn actions_get_allowed_actions_organization(
        &self,
        org: &str,
    ) -> Result<types::SelectedActions> {
        let url = format!(
            "/orgs/{}/actions/permissions/selected-actions",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Set allowed actions for an organization.
    *
    * This function performs a `PUT` to the `/orgs/{org}/actions/permissions/selected-actions` endpoint.
    *
    * Sets the actions that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
    *
    * If the organization belongs to an enterprise that has `selected` actions set at the enterprise level, then you cannot override any of the enterprise's allowed actions settings.
    *
    * To use the `patterns_allowed` setting for private repositories, the organization must belong to an enterprise. If the organization does not belong to an enterprise, then the `patterns_allowed` setting only applies to public repositories in the organization.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#set-allowed-actions-for-an-organization>
    */
    pub async fn actions_set_allowed_actions_organization(
        &self,
        org: &str,
        body: &types::SelectedActions,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/permissions/selected-actions",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List self-hosted runner groups for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/actions/runner-groups` endpoint.
    *
    * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
    *
    * Lists all self-hosted runner groups configured in an organization and inherited from an enterprise.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-self-hosted-runner-groups-for-an-organization>
    */
    pub async fn actions_list_self_hosted_runner_groups_for_org(
        &self,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListSelfDataHostedRunnerGroupsOrganizationOkResponse> {
        let url = format!(
            "/orgs/{}/actions/runner-groups?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Create a self-hosted runner group for an organization.
    *
    * This function performs a `POST` to the `/orgs/{org}/actions/runner-groups` endpoint.
    *
    * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub Enterprise Server. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
    *
    * Creates a new self-hosted runner group for an organization.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#create-a-self-hosted-runner-group-for-an-organization>
    */
    pub async fn actions_create_self_hosted_runner_group_for_org(
        &self,
        org: &str,
        body: &types::CreateSelfDataHostedRunnerGroupOrganizationRequest,
    ) -> Result<types::RunnerGroupsOrg> {
        let url = format!(
            "/orgs/{}/actions/runner-groups",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a self-hosted runner group for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}` endpoint.
    *
    * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
    *
    * Gets a specific self-hosted runner group for an organization.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-a-self-hosted-runner-group-for-an-organization>
    */
    pub async fn actions_get_self_hosted_runner_group_for_org(
        &self,
        org: &str,
        runner_group_id: i64,
    ) -> Result<types::RunnerGroupsOrg> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a self-hosted runner group from an organization.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}` endpoint.
    *
    * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
    *
    * Deletes a self-hosted runner group for an organization.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#delete-a-self-hosted-runner-group-from-an-organization>
    */
    pub async fn actions_delete_self_hosted_runner_group_from_org(
        &self,
        org: &str,
        runner_group_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a self-hosted runner group for an organization.
    *
    * This function performs a `PATCH` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}` endpoint.
    *
    * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
    *
    * Updates the `name` and `visibility` of a self-hosted runner group in an organization.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#update-a-self-hosted-runner-group-for-an-organization>
    */
    pub async fn actions_update_self_hosted_runner_group_for_org(
        &self,
        org: &str,
        runner_group_id: i64,
        body: &types::UpdateSelfDataHostedRunnerGroupOrganizationRequest,
    ) -> Result<types::RunnerGroupsOrg> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List repository access to a self-hosted runner group in an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories` endpoint.
    *
    * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub Enterprise Server. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
    *
    * Lists the repositories with access to a self-hosted runner group configured in an organization.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-repository-access-to-a-self-hosted-runner-group-in-an-organization>
    */
    pub async fn actions_list_repo_access_to_self_hosted_runner_group_in_org(
        &self,
        org: &str,
        runner_group_id: i64,
        page: i64,
        per_page: i64,
    ) -> Result<types::GetListRepositoryAccessSelfDataHostedRunnerGroupinOrganizationOkResponse>
    {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/repositories?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Set repository access for a self-hosted runner group in an organization.
    *
    * This function performs a `PUT` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories` endpoint.
    *
    * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
    *
    * Replaces the list of repositories that have access to a self-hosted runner group configured in an organization.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#set-repository-access-to-a-self-hosted-runner-group-in-an-organization>
    */
    pub async fn actions_set_repo_access_to_self_hosted_runner_group_in_org(
        &self,
        org: &str,
        runner_group_id: i64,
        body: &types::SetRepositoryAccessSelfDataHostedRunnerGroupinOrganizationRequest,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/repositories",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Add repository access to a self-hosted runner group in an organization.
    *
    * This function performs a `PUT` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}` endpoint.
    *
    * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
    *
    *
    * Adds a repository to the list of selected repositories that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an organization](#create-a-self-hosted-runner-group-for-an-organization)."
    *
    * You must authenticate using an access token with the `admin:org`
    * scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#add-repository-acess-to-a-self-hosted-runner-group-in-an-organization>
    */
    pub async fn actions_add_repo_access_to_self_hosted_runner_group_in_org(
        &self,
        org: &str,
        runner_group_id: i64,
        repository_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/repositories/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Remove repository access to a self-hosted runner group in an organization.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}` endpoint.
    *
    * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
    *
    *
    * Removes a repository from the list of selected repositories that can access a self-hosted runner group. The runner group must have `visibility` set to `selected`. For more information, see "[Create a self-hosted runner group for an organization](#create-a-self-hosted-runner-group-for-an-organization)."
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#remove-repository-access-to-a-self-hosted-runner-group-in-an-organization>
    */
    pub async fn actions_remove_repo_access_to_self_hosted_runner_group_in_org(
        &self,
        org: &str,
        runner_group_id: i64,
        repository_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/repositories/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List self-hosted runners in a group for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/runners` endpoint.
    *
    * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
    *
    * Lists self-hosted runners that are in a specific organization group.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-self-hosted-runners-in-a-group-for-an-organization>
    */
    pub async fn actions_list_self_hosted_runners_in_group_for_org(
        &self,
        org: &str,
        runner_group_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListSelfDataHostedRunnersinGroupOrganizationOkResponse> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/runners?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Set self-hosted runners in a group for an organization.
    *
    * This function performs a `PUT` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/runners` endpoint.
    *
    * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
    *
    * Replaces the list of self-hosted runners that are part of an organization runner group.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#set-self-hosted-runners-in-a-group-for-an-organization>
    */
    pub async fn actions_set_self_hosted_runners_in_group_for_org(
        &self,
        org: &str,
        runner_group_id: i64,
        body: &types::SetSelfDataHostedRunnersinGroupOrganizationRequest,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/runners",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Add a self-hosted runner to a group for an organization.
    *
    * This function performs a `PUT` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}` endpoint.
    *
    * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
    *
    *
    * Adds a self-hosted runner to a runner group configured in an organization.
    *
    * You must authenticate using an access token with the `admin:org`
    * scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#add-a-self-hosted-runner-to-a-group-for-an-organization>
    */
    pub async fn actions_add_self_hosted_runner_to_group_for_org(
        &self,
        org: &str,
        runner_group_id: i64,
        runner_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/runners/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Remove a self-hosted runner from a group for an organization.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}` endpoint.
    *
    * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
    *
    *
    * Removes a self-hosted runner from a group configured in an organization. The runner is then returned to the default group.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#remove-a-self-hosted-runner-from-a-group-for-an-organization>
    */
    pub async fn actions_remove_self_hosted_runner_from_group_for_org(
        &self,
        org: &str,
        runner_group_id: i64,
        runner_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runner-groups/{}/runners/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_group_id.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List self-hosted runners for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/actions/runners` endpoint.
    *
    * Lists all self-hosted runners configured in an organization.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-self-hosted-runners-for-an-organization>
    */
    pub async fn actions_list_self_hosted_runners_for_org(
        &self,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListSelfDataHostedRunnersOrganizationOkResponse> {
        let url = format!(
            "/orgs/{}/actions/runners?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * List runner applications for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/actions/runners/downloads` endpoint.
    *
    * Lists binaries for the runner application that you can download and run.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-runner-applications-for-an-organization>
    */
    pub async fn actions_list_runner_applications_for_org(
        &self,
        org: &str,
    ) -> Result<Vec<types::RunnerApplication>> {
        let url = format!(
            "/orgs/{}/actions/runners/downloads",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a registration token for an organization.
    *
    * This function performs a `POST` to the `/orgs/{org}/actions/runners/registration-token` endpoint.
    *
    * Returns a token that you can pass to the `config` script. The token expires after one hour.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * #### Example using registration token
    *
    * Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.
    *
    * ```
    * ./config.sh --url https://github.com/octo-org --token TOKEN
    * ```
    *
    * FROM: <https://docs.github.com/rest/reference/actions#create-a-registration-token-for-an-organization>
    */
    pub async fn actions_create_registration_token_for_org(
        &self,
        org: &str,
    ) -> Result<types::AuthenticationToken> {
        let url = format!(
            "/orgs/{}/actions/runners/registration-token",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Create a remove token for an organization.
    *
    * This function performs a `POST` to the `/orgs/{org}/actions/runners/remove-token` endpoint.
    *
    * Returns a token that you can pass to the `config` script to remove a self-hosted runner from an organization. The token expires after one hour.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * #### Example using remove token
    *
    * To remove your self-hosted runner from an organization, replace `TOKEN` with the remove token provided by this
    * endpoint.
    *
    * ```
    * ./config.sh remove --token TOKEN
    * ```
    *
    * FROM: <https://docs.github.com/rest/reference/actions#create-a-remove-token-for-an-organization>
    */
    pub async fn actions_create_remove_token_for_org(
        &self,
        org: &str,
    ) -> Result<types::AuthenticationToken> {
        let url = format!(
            "/orgs/{}/actions/runners/remove-token",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Get a self-hosted runner for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/actions/runners/{runner_id}` endpoint.
    *
    * Gets a specific self-hosted runner configured in an organization.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-a-self-hosted-runner-for-an-organization>
    */
    pub async fn actions_get_self_hosted_runner_for_org(
        &self,
        org: &str,
        runner_id: i64,
    ) -> Result<types::Runner> {
        let url = format!(
            "/orgs/{}/actions/runners/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a self-hosted runner from an organization.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/actions/runners/{runner_id}` endpoint.
    *
    * Forces the removal of a self-hosted runner from an organization. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.
    *
    * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#delete-a-self-hosted-runner-from-an-organization>
    */
    pub async fn actions_delete_self_hosted_runner_from_org(
        &self,
        org: &str,
        runner_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/runners/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List organization secrets.
    *
    * This function performs a `GET` to the `/orgs/{org}/actions/secrets` endpoint.
    *
    * Lists all secrets available in an organization without revealing their encrypted values. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-organization-secrets>
    */
    pub async fn actions_list_org_secrets(
        &self,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListOrganizationSecretsOkResponse> {
        let url = format!(
            "/orgs/{}/actions/secrets?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Get an organization public key.
    *
    * This function performs a `GET` to the `/orgs/{org}/actions/secrets/public-key` endpoint.
    *
    * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-an-organization-public-key>
    */
    pub async fn actions_get_org_public_key(&self, org: &str) -> Result<types::ActionsPublicKey> {
        let url = format!(
            "/orgs/{}/actions/secrets/public-key",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get an organization secret.
    *
    * This function performs a `GET` to the `/orgs/{org}/actions/secrets/{secret_name}` endpoint.
    *
    * Gets a single organization secret without revealing its encrypted value. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-an-organization-secret>
    */
    pub async fn actions_get_org_secret(
        &self,
        org: &str,
        secret_name: &str,
    ) -> Result<types::OrganizationActionsSecret> {
        let url = format!(
            "/orgs/{}/actions/secrets/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Create or update an organization secret.
    *
    * This function performs a `PUT` to the `/orgs/{org}/actions/secrets/{secret_name}` endpoint.
    *
    * Creates or updates an organization secret with an encrypted value. Encrypt your secret using
    * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
    * token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to
    * use this endpoint.
    *
    * #### Example encrypting a secret using Node.js
    *
    * Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
    *
    * ```
    * const sodium = require('tweetsodium');
    *
    * const key = "base64-encoded-public-key";
    * const value = "plain-text-secret";
    *
    * // Convert the message and key to Uint8Array's (Buffer implements that interface)
    * const messageBytes = Buffer.from(value);
    * const keyBytes = Buffer.from(key, 'base64');
    *
    * // Encrypt using LibSodium.
    * const encryptedBytes = sodium.seal(messageBytes, keyBytes);
    *
    * // Base64 the encrypted secret
    * const encrypted = Buffer.from(encryptedBytes).toString('base64');
    *
    * console.log(encrypted);
    * ```
    *
    *
    * #### Example encrypting a secret using Python
    *
    * Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/stable/public/#nacl-public-sealedbox) with Python 3.
    *
    * ```
    * from base64 import b64encode
    * from nacl import encoding, public
    *
    * def encrypt(public_key: str, secret_value: str) -> str:
    *   """Encrypt a Unicode string using the public key."""
    *   public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
    *   sealed_box = public.SealedBox(public_key)
    *   encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
    *   return b64encode(encrypted).decode("utf-8")
    * ```
    *
    * #### Example encrypting a secret using C#
    *
    * Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
    *
    * ```
    * var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
    * var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
    *
    * var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
    *
    * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
    * ```
    *
    * #### Example encrypting a secret using Ruby
    *
    * Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
    *
    * ```ruby
    * require "rbnacl"
    * require "base64"
    *
    * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
    * public_key = RbNaCl::PublicKey.new(key)
    *
    * box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
    * encrypted_secret = box.encrypt("my_secret")
    *
    * # Print the base64 encoded secret
    * puts Base64.strict_encode64(encrypted_secret)
    * ```
    *
    * FROM: <https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret>
    */
    pub async fn actions_create_or_update_org_secret(
        &self,
        org: &str,
        secret_name: &str,
        body: &types::CreateUpdateOrganizationSecretRequest,
    ) -> Result<types::EmptyObject> {
        let url = format!(
            "/orgs/{}/actions/secrets/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete an organization secret.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/actions/secrets/{secret_name}` endpoint.
    *
    * Deletes a secret in an organization using the secret name. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#delete-an-organization-secret>
    */
    pub async fn actions_delete_org_secret(&self, org: &str, secret_name: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/secrets/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List selected repositories for an organization secret.
    *
    * This function performs a `GET` to the `/orgs/{org}/actions/secrets/{secret_name}/repositories` endpoint.
    *
    * Lists all repositories that have been selected when the `visibility` for repository access to a secret is set to `selected`. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-selected-repositories-for-an-organization-secret>
    */
    pub async fn actions_list_selected_repos_for_org_secret(
        &self,
        org: &str,
        secret_name: &str,
        page: i64,
        per_page: i64,
    ) -> Result<types::GetListSelectedRepositoriesOrganizationSecretOkResponse> {
        let url = format!(
            "/orgs/{}/actions/secrets/{}/repositories?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Set selected repositories for an organization secret.
    *
    * This function performs a `PUT` to the `/orgs/{org}/actions/secrets/{secret_name}/repositories` endpoint.
    *
    * Replaces all repositories for an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#set-selected-repositories-for-an-organization-secret>
    */
    pub async fn actions_set_selected_repos_for_org_secret(
        &self,
        org: &str,
        secret_name: &str,
        body: &types::SetSelectedRepositoriesOrganizationSecretRequest,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/secrets/{}/repositories",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Add selected repository to an organization secret.
    *
    * This function performs a `PUT` to the `/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}` endpoint.
    *
    * Adds a repository to an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#add-selected-repository-to-an-organization-secret>
    */
    pub async fn actions_add_selected_repo_to_org_secret(
        &self,
        org: &str,
        secret_name: &str,
        repository_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/secrets/{}/repositories/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Remove selected repository from an organization secret.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}` endpoint.
    *
    * Removes a repository from an organization secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret). You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#remove-selected-repository-from-an-organization-secret>
    */
    pub async fn actions_remove_selected_repo_from_org_secret(
        &self,
        org: &str,
        secret_name: &str,
        repository_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/actions/secrets/{}/repositories/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get the audit log for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/audit-log` endpoint.
    *
    * Gets the audit log for an organization. For more information, see "[Reviewing the audit log for your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/reviewing-the-audit-log-for-your-organization)."
    *
    * To use this endpoint, you must be an organization owner, and you must use an access token with the `admin:org` scope. GitHub Apps must have the `organization_administration` read permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#get-audit-log>
    */
    pub async fn orgs_get_audit_log(
        &self,
        org: &str,
        phrase: &str,
        include: &str,
        after: &str,
        before: &str,
        order: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::AuditLogEvent>> {
        let url = format!("/orgs/{}/audit-log?after={}&before={}&include={}&order={}&page={}&per_page={}&phrase={}",
            progenitor_support::encode_path(&org.to_string()),
after.to_string(), before.to_string(), include.to_string(), order.to_string(), format!("{}", page), format!("{}", per_page), phrase.to_string(),         );

        self.get_all_pages(&url).await
    }

    /**
    * List users blocked by an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/blocks` endpoint.
    *
    * List the users blocked by an organization.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#list-users-blocked-by-an-organization>
    */
    pub async fn orgs_list_blocked_users(&self, org: &str) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/orgs/{}/blocks",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Check if a user is blocked by an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/blocks/{username}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#check-if-a-user-is-blocked-by-an-organization>
    */
    pub async fn orgs_check_blocked_user(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/blocks/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Block a user from an organization.
    *
    * This function performs a `PUT` to the `/orgs/{org}/blocks/{username}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#block-a-user-from-an-organization>
    */
    pub async fn orgs_block_user(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/blocks/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Unblock a user from an organization.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/blocks/{username}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#unblock-a-user-from-an-organization>
    */
    pub async fn orgs_unblock_user(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/blocks/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List SAML SSO authorizations for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/credential-authorizations` endpoint.
    *
    * Listing and deleting credential authorizations is available to organizations with GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products).
    *
    * An authenticated organization owner with the `read:org` scope can list all credential authorizations for an organization that uses SAML single sign-on (SSO). The credentials are either personal access tokens or SSH keys that organization members have authorized for the organization. For more information, see [About authentication with SAML single sign-on](https://help.github.com/en/articles/about-authentication-with-saml-single-sign-on).
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#list-saml-sso-authorizations-for-an-organization>
    */
    pub async fn orgs_list_saml_sso_authorizations(
        &self,
        org: &str,
    ) -> Result<Vec<types::CredentialAuthorization>> {
        let url = format!(
            "/orgs/{}/credential-authorizations",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Remove a SAML SSO authorization for an organization.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/credential-authorizations/{credential_id}` endpoint.
    *
    * Listing and deleting credential authorizations is available to organizations with GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products).
    *
    * An authenticated organization owner with the `admin:org` scope can remove a credential authorization for an organization that uses SAML SSO. Once you remove someone's credential authorization, they will need to create a new personal access token or SSH key and authorize it for the organization they want to access.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#remove-a-saml-sso-authorization-for-an-organization>
    */
    pub async fn orgs_remove_saml_sso_authorization(
        &self,
        org: &str,
        credential_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/credential-authorizations/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&credential_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List public organization events.
    *
    * This function performs a `GET` to the `/orgs/{org}/events` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-public-organization-events>
    */
    pub async fn activity_list_public_org_events(
        &self,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Event>> {
        let url = format!(
            "/orgs/{}/events?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List failed organization invitations.
    *
    * This function performs a `GET` to the `/orgs/{org}/failed_invitations` endpoint.
    *
    * The return hash contains `failed_at` and `failed_reason` fields which represent the time at which the invitation failed and the reason for the failure.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#list-failed-organization-invitations>
    */
    pub async fn orgs_list_failed_invitations(
        &self,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::OrganizationInvitation>> {
        let url = format!(
            "/orgs/{}/failed_invitations?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List organization webhooks.
    *
    * This function performs a `GET` to the `/orgs/{org}/hooks` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#list-organization-webhooks>
    */
    pub async fn orgs_list_webhooks(
        &self,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::OrgHook>> {
        let url = format!(
            "/orgs/{}/hooks?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create an organization webhook.
    *
    * This function performs a `POST` to the `/orgs/{org}/hooks` endpoint.
    *
    * Here's how you can create a hook that posts payloads in JSON format:
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#create-an-organization-webhook>
    */
    pub async fn orgs_create_webhook(
        &self,
        org: &str,
        body: &types::CreateOrganizationWebhookRequest,
    ) -> Result<types::OrgHook> {
        let url = format!(
            "/orgs/{}/hooks",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get an organization webhook.
    *
    * This function performs a `GET` to the `/orgs/{org}/hooks/{hook_id}` endpoint.
    *
    * Returns a webhook configured in an organization. To get only the webhook `config` properties, see "[Get a webhook configuration for an organization](/rest/reference/orgs#get-a-webhook-configuration-for-an-organization)."
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#get-an-organization-webhook>
    */
    pub async fn orgs_get_webhook(&self, org: &str, hook_id: i64) -> Result<types::OrgHook> {
        let url = format!(
            "/orgs/{}/hooks/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete an organization webhook.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/hooks/{hook_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#delete-an-organization-webhook>
    */
    pub async fn orgs_delete_webhook(&self, org: &str, hook_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/hooks/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update an organization webhook.
    *
    * This function performs a `PATCH` to the `/orgs/{org}/hooks/{hook_id}` endpoint.
    *
    * Updates a webhook configured in an organization. When you update a webhook, the `secret` will be overwritten. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for an organization](/rest/reference/orgs#update-a-webhook-configuration-for-an-organization)."
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#update-an-organization-webhook>
    */
    pub async fn orgs_update_webhook(
        &self,
        org: &str,
        hook_id: i64,
        body: &types::UpdateOrganizationWebhookRequest,
    ) -> Result<types::OrgHook> {
        let url = format!(
            "/orgs/{}/hooks/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a webhook configuration for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/hooks/{hook_id}/config` endpoint.
    *
    * Returns the webhook configuration for an organization. To get more information about the webhook, including the `active` state and `events`, use "[Get an organization webhook ](/rest/reference/orgs#get-an-organization-webhook)."
    *
    * Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the `organization_hooks:read` permission.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#get-a-webhook-configuration-for-an-organization>
    */
    pub async fn orgs_get_webhook_config_for_org(
        &self,
        org: &str,
        hook_id: i64,
    ) -> Result<types::WebhookConfig> {
        let url = format!(
            "/orgs/{}/hooks/{}/config",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Update a webhook configuration for an organization.
    *
    * This function performs a `PATCH` to the `/orgs/{org}/hooks/{hook_id}/config` endpoint.
    *
    * Updates the webhook configuration for an organization. To update more information about the webhook, including the `active` state and `events`, use "[Update an organization webhook ](/rest/reference/orgs#update-an-organization-webhook)."
    *
    * Access tokens must have the `admin:org_hook` scope, and GitHub Apps must have the `organization_hooks:write` permission.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#update-a-webhook-configuration-for-an-organization>
    */
    pub async fn orgs_update_webhook_config_for_org(
        &self,
        org: &str,
        hook_id: i64,
        body: &types::UpdateWebhookConfigurationOrganizationRequest,
    ) -> Result<types::WebhookConfig> {
        let url = format!(
            "/orgs/{}/hooks/{}/config",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Ping an organization webhook.
    *
    * This function performs a `POST` to the `/orgs/{org}/hooks/{hook_id}/pings` endpoint.
    *
    * This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the hook.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#ping-an-organization-webhook>
    */
    pub async fn orgs_ping_webhook(&self, org: &str, hook_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/hooks/{}/pings",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Get an organization installation for the authenticated app.
    *
    * This function performs a `GET` to the `/orgs/{org}/installation` endpoint.
    *
    * Enables an authenticated GitHub App to find the organization's installation information.
    *
    * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#get-an-organization-installation-for-the-authenticated-app>
    */
    pub async fn apps_get_org_installation(&self, org: &str) -> Result<types::Installation> {
        let url = format!(
            "/orgs/{}/installation",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List app installations for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/installations` endpoint.
    *
    * Lists all GitHub Apps in an organization. The installation count includes all GitHub Apps installed on repositories in the organization. You must be an organization owner with `admin:read` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#list-app-installations-for-an-organization>
    */
    pub async fn orgs_list_app_installations(
        &self,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListAppInstallationsOrganizationOkResponse> {
        let url = format!(
            "/orgs/{}/installations?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Get interaction restrictions for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/interaction-limits` endpoint.
    *
    * Shows which type of GitHub user can interact with this organization and when the restriction expires. If there is no restrictions, you will see an empty response.
    *
    * FROM: <https://docs.github.com/rest/reference/interactions#get-interaction-restrictions-for-an-organization>
    */
    pub async fn interactions_get_restrictions_for_org(
        &self,
        org: &str,
    ) -> Result<types::GetInteractionRestrictionsOrganizationOkResponse> {
        let url = format!(
            "/orgs/{}/interaction-limits",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Set interaction restrictions for an organization.
    *
    * This function performs a `PUT` to the `/orgs/{org}/interaction-limits` endpoint.
    *
    * Temporarily restricts interactions to a certain type of GitHub user in any public repository in the given organization. You must be an organization owner to set these restrictions. Setting the interaction limit at the organization level will overwrite any interaction limits that are set for individual repositories owned by the organization.
    *
    * FROM: <https://docs.github.com/rest/reference/interactions#set-interaction-restrictions-for-an-organization>
    */
    pub async fn interactions_set_restrictions_for_org(
        &self,
        org: &str,
        body: &types::InteractionLimit,
    ) -> Result<types::InteractionLimitResponse> {
        let url = format!(
            "/orgs/{}/interaction-limits",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove interaction restrictions for an organization.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/interaction-limits` endpoint.
    *
    * Removes all interaction restrictions from public repositories in the given organization. You must be an organization owner to remove restrictions.
    *
    * FROM: <https://docs.github.com/rest/reference/interactions#remove-interaction-restrictions-for-an-organization>
    */
    pub async fn interactions_remove_restrictions_for_org(&self, org: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/interaction-limits",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List pending organization invitations.
    *
    * This function performs a `GET` to the `/orgs/{org}/invitations` endpoint.
    *
    * The return hash contains a `role` field which refers to the Organization Invitation role and will be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be `null`.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#list-pending-organization-invitations>
    */
    pub async fn orgs_list_pending_invitations(
        &self,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::OrganizationInvitation>> {
        let url = format!(
            "/orgs/{}/invitations?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create an organization invitation.
    *
    * This function performs a `POST` to the `/orgs/{org}/invitations` endpoint.
    *
    * Invite people to an organization by using their GitHub user ID or their email address. In order to create invitations in an organization, the authenticated user must be an organization owner.
    *
    * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#create-an-organization-invitation>
    */
    pub async fn orgs_create_invitation(
        &self,
        org: &str,
        body: &types::CreateOrganizationInvitationRequest,
    ) -> Result<types::OrganizationInvitation> {
        let url = format!(
            "/orgs/{}/invitations",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Cancel an organization invitation.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/invitations/{invitation_id}` endpoint.
    *
    * Cancel an organization invitation. In order to cancel an organization invitation, the authenticated user must be an organization owner.
    *
    * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications).
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#cancel-an-organization-invitation>
    */
    pub async fn orgs_cancel_invitation(&self, org: &str, invitation_id: i64) -> Result<()> {
        let url = format!(
            "/orgs/{}/invitations/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&invitation_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List organization invitation teams.
    *
    * This function performs a `GET` to the `/orgs/{org}/invitations/{invitation_id}/teams` endpoint.
    *
    * List all teams associated with an invitation. In order to see invitations in an organization, the authenticated user must be an organization owner.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#list-organization-invitation-teams>
    */
    pub async fn orgs_list_invitation_teams(
        &self,
        org: &str,
        invitation_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Team>> {
        let url = format!(
            "/orgs/{}/invitations/{}/teams?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&invitation_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List organization issues assigned to the authenticated user.
    *
    * This function performs a `GET` to the `/orgs/{org}/issues` endpoint.
    *
    * List issues in an organization assigned to the authenticated user.
    *
    * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
    * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
    * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
    * request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#list-organization-issues-assigned-to-the-authenticated-user>
    */
    pub async fn issues_list_for_org(
        &self,
        org: &str,
        filter: &str,
        state: &str,
        labels: &str,
        sort: &str,
        direction: &str,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Issue>> {
        let url = format!("/orgs/{}/issues?direction={}&filter={}&labels={}&page={}&per_page={}&since={}&sort={}&state={}",
            progenitor_support::encode_path(&org.to_string()),
direction.to_string(), filter.to_string(), labels.to_string(), format!("{}", page), format!("{}", per_page), since.to_rfc3339(), sort.to_string(), state.to_string(),         );

        self.get_all_pages(&url).await
    }

    /**
    * List organization members.
    *
    * This function performs a `GET` to the `/orgs/{org}/members` endpoint.
    *
    * List all users who are members of an organization. If the authenticated user is also a member of this organization then both concealed and public members will be returned.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#list-organization-members>
    */
    pub async fn orgs_list_members(
        &self,
        org: &str,
        filter: &str,
        role: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/orgs/{}/members?filter={}&page={}&per_page={}&role={}",
            progenitor_support::encode_path(&org.to_string()),
            filter.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            role.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Check organization membership for a user.
    *
    * This function performs a `GET` to the `/orgs/{org}/members/{username}` endpoint.
    *
    * Check if a user is, publicly or privately, a member of the organization.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#check-organization-membership-for-a-user>
    */
    pub async fn orgs_check_membership_for_user(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/members/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Remove an organization member.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/members/{username}` endpoint.
    *
    * Removing a user from this list will remove them from all teams and they will no longer have any access to the organization's repositories.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#remove-an-organization-member>
    */
    pub async fn orgs_remove_member(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/members/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get organization membership for a user.
    *
    * This function performs a `GET` to the `/orgs/{org}/memberships/{username}` endpoint.
    *
    * In order to get a user's membership with an organization, the authenticated user must be an organization member. The `state` parameter in the response can be used to identify the user's membership status.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#get-organization-membership-for-a-user>
    */
    pub async fn orgs_get_membership_for_user(
        &self,
        org: &str,
        username: &str,
    ) -> Result<types::OrgMembership> {
        let url = format!(
            "/orgs/{}/memberships/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Set organization membership for a user.
    *
    * This function performs a `PUT` to the `/orgs/{org}/memberships/{username}` endpoint.
    *
    * Only authenticated organization owners can add a member to the organization or update the member's role.
    *
    * *   If the authenticated user is _adding_ a member to the organization, the invited user will receive an email inviting them to the organization. The user's [membership status](https://docs.github.com/rest/reference/orgs#get-organization-membership-for-a-user) will be `pending` until they accept the invitation.
    *     
    * *   Authenticated users can _update_ a user's membership by passing the `role` parameter. If the authenticated user changes a member's role to `admin`, the affected user will receive an email notifying them that they've been made an organization owner. If the authenticated user changes an owner's role to `member`, no email will be sent.
    *
    * **Rate limits**
    *
    * To prevent abuse, the authenticated user is limited to 50 organization invitations per 24 hour period. If the organization is more than one month old or on a paid plan, the limit is 500 invitations per 24 hour period.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#set-organization-membership-for-a-user>
    */
    pub async fn orgs_set_membership_for_user(
        &self,
        org: &str,
        username: &str,
        body: &types::SetOrganizationMembershipUserRequest,
    ) -> Result<types::OrgMembership> {
        let url = format!(
            "/orgs/{}/memberships/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove organization membership for a user.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/memberships/{username}` endpoint.
    *
    * In order to remove a user's membership with an organization, the authenticated user must be an organization owner.
    *
    * If the specified user is an active member of the organization, this will remove them from the organization. If the specified user has been invited to the organization, this will cancel their invitation. The specified user will receive an email notification in both cases.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#remove-organization-membership-for-a-user>
    */
    pub async fn orgs_remove_membership_for_user(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/memberships/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List organization migrations.
    *
    * This function performs a `GET` to the `/orgs/{org}/migrations` endpoint.
    *
    * Lists the most recent migrations.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#list-organization-migrations>
    */
    pub async fn migrations_list_for_org(
        &self,
        org: &str,
        per_page: i64,
        page: i64,
        exclude: &[String],
    ) -> Result<Vec<types::Migration>> {
        let url = format!(
            "/orgs/{}/migrations?exclude={}&page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            exclude.join(" "),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Start an organization migration.
    *
    * This function performs a `POST` to the `/orgs/{org}/migrations` endpoint.
    *
    * Initiates the generation of a migration archive.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#start-an-organization-migration>
    */
    pub async fn migrations_start_for_org(
        &self,
        org: &str,
        body: &types::StartOrganizationMigrationRequest,
    ) -> Result<types::Migration> {
        let url = format!(
            "/orgs/{}/migrations",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get an organization migration status.
    *
    * This function performs a `GET` to the `/orgs/{org}/migrations/{migration_id}` endpoint.
    *
    * Fetches the status of a migration.
    *
    * The `state` of a migration can be one of the following values:
    *
    * *   `pending`, which means the migration hasn't started yet.
    * *   `exporting`, which means the migration is in progress.
    * *   `exported`, which means the migration finished successfully.
    * *   `failed`, which means the migration failed.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#get-an-organization-migration-status>
    */
    pub async fn migrations_get_status_for_org(
        &self,
        org: &str,
        migration_id: i64,
        exclude: &[String],
    ) -> Result<types::Migration> {
        let url = format!(
            "/orgs/{}/migrations/{}?exclude={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&migration_id.to_string()),
            exclude.join(" "),
        );

        self.get(&url).await
    }

    /**
    * Download an organization migration archive.
    *
    * This function performs a `GET` to the `/orgs/{org}/migrations/{migration_id}/archive` endpoint.
    *
    * Fetches the URL to a migration archive.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#download-an-organization-migration-archive>
    */
    pub async fn migrations_download_archive_for_org(
        &self,
        org: &str,
        migration_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/migrations/{}/archive",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&migration_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete an organization migration archive.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/migrations/{migration_id}/archive` endpoint.
    *
    * Deletes a previous migration archive. Migration archives are automatically deleted after seven days.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#delete-an-organization-migration-archive>
    */
    pub async fn migrations_delete_archive_for_org(
        &self,
        org: &str,
        migration_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/migrations/{}/archive",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&migration_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Unlock an organization repository.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock` endpoint.
    *
    * Unlocks a repository that was locked for migration. You should unlock each migrated repository and [delete them](https://docs.github.com/rest/reference/repos#delete-a-repository) when the migration is complete and you no longer need the source data.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#unlock-an-organization-repository>
    */
    pub async fn migrations_unlock_repo_for_org(
        &self,
        org: &str,
        migration_id: i64,
        repo_name: &str,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/migrations/{}/repos/{}/lock",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&migration_id.to_string()),
            progenitor_support::encode_path(&repo_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List repositories in an organization migration.
    *
    * This function performs a `GET` to the `/orgs/{org}/migrations/{migration_id}/repositories` endpoint.
    *
    * List all the repositories for this organization migration.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#list-repositories-in-an-organization-migration>
    */
    pub async fn migrations_list_repos_for_org(
        &self,
        org: &str,
        migration_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/orgs/{}/migrations/{}/repositories?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&migration_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List outside collaborators for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/outside_collaborators` endpoint.
    *
    * List all users who are outside collaborators of an organization.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#list-outside-collaborators-for-an-organization>
    */
    pub async fn orgs_list_outside_collaborators(
        &self,
        org: &str,
        filter: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/orgs/{}/outside_collaborators?filter={}&page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            filter.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Convert an organization member to outside collaborator.
    *
    * This function performs a `PUT` to the `/orgs/{org}/outside_collaborators/{username}` endpoint.
    *
    * When an organization member is converted to an outside collaborator, they'll only have access to the repositories that their current team membership allows. The user will no longer be a member of the organization. For more information, see "[Converting an organization member to an outside collaborator](https://help.github.com/articles/converting-an-organization-member-to-an-outside-collaborator/)".
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#convert-an-organization-member-to-outside-collaborator>
    */
    pub async fn orgs_convert_member_to_outside_collaborator(
        &self,
        org: &str,
        username: &str,
    ) -> Result<types::PutConvertOrganizationMemberOutsideCollaboratorAcceptedResponse> {
        let url = format!(
            "/orgs/{}/outside_collaborators/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Remove outside collaborator from an organization.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/outside_collaborators/{username}` endpoint.
    *
    * Removing a user from this list will remove them from all the organization's repositories.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#remove-outside-collaborator-from-an-organization>
    */
    pub async fn orgs_remove_outside_collaborator(&self, org: &str, username: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/outside_collaborators/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get a package for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/packages/{package_type}/{package_name}` endpoint.
    *
    * Gets a specific package in an organization.
    *
    * To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
    * If `package_type` is not `container`, your token must also include the `repo` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#get-a-package-for-an-organization>
    */
    pub async fn packages_get_package_for_organization(
        &self,
        package_type: &str,
        package_name: &str,
        org: &str,
    ) -> Result<types::Package> {
        let url = format!(
            "/orgs/{}/packages/{}/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a package for an organization.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/packages/{package_type}/{package_name}` endpoint.
    *
    * Deletes an entire package in an organization. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.
    *
    * To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` scope. In addition:
    * - If `package_type` is not `container`, your token must also include the `repo` scope.
    * - If `package_type` is `container`, you must also have admin permissions to the container you want to delete.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#delete-a-package-for-an-organization>
    */
    pub async fn packages_delete_package_for_org(
        &self,
        package_type: &str,
        package_name: &str,
        org: &str,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/packages/{}/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Restore a package for an organization.
    *
    * This function performs a `POST` to the `/orgs/{org}/packages/{package_type}/{package_name}/restore` endpoint.
    *
    * Restores an entire package in an organization.
    *
    * You can restore a deleted package under the following conditions:
    *   - The package was deleted within the last 30 days.
    *   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.
    *
    * To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:write` scope. In addition:
    * - If `package_type` is not `container`, your token must also include the `repo` scope.
    * - If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#restore-a-package-for-an-organization>
    */
    pub async fn packages_restore_package_for_org(
        &self,
        package_type: &str,
        package_name: &str,
        org: &str,
        token: &str,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/packages/{}/{}/restore?token={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            token.to_string(),
        );

        self.post(&url, None).await
    }

    /**
    * Get all package versions for a package owned by an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/packages/{package_type}/{package_name}/versions` endpoint.
    *
    * Returns all package versions for a package owned by an organization.
    *
    * To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
    * If `package_type` is not `container`, your token must also include the `repo` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#get-all-package-versions-for-a-package-owned-by-an-organization>
    */
    pub async fn packages_get_all_package_versions_for_package_owned_by_org(
        &self,
        package_type: &str,
        package_name: &str,
        org: &str,
        page: i64,
        per_page: i64,
        state: &str,
    ) -> Result<Vec<types::PackageVersion>> {
        let url = format!(
            "/orgs/{}/packages/{}/{}/versions?page={}&per_page={}&state={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            state.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a package version for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}` endpoint.
    *
    * Gets a specific package version in an organization.
    *
    * You must authenticate using an access token with the `packages:read` scope.
    * If `package_type` is not `container`, your token must also include the `repo` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#get-a-package-version-for-an-organization>
    */
    pub async fn packages_get_package_version_for_organization(
        &self,
        package_type: &str,
        package_name: &str,
        org: &str,
        package_version_id: i64,
    ) -> Result<types::PackageVersion> {
        let url = format!(
            "/orgs/{}/packages/{}/{}/versions/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            progenitor_support::encode_path(&package_version_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete package version for an organization.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}` endpoint.
    *
    * Deletes a specific package version in an organization. If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.
    *
    * To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` scope. In addition:
    * - If `package_type` is not `container`, your token must also include the `repo` scope.
    * - If `package_type` is `container`, you must also have admin permissions to the container you want to delete.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#delete-a-package-version-for-an-organization>
    */
    pub async fn packages_delete_package_version_for_org(
        &self,
        package_type: &str,
        package_name: &str,
        org: &str,
        package_version_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/packages/{}/{}/versions/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            progenitor_support::encode_path(&package_version_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Restore package version for an organization.
    *
    * This function performs a `POST` to the `/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore` endpoint.
    *
    * Restores a specific package version in an organization.
    *
    * You can restore a deleted package under the following conditions:
    *   - The package was deleted within the last 30 days.
    *   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.
    *
    * To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` and `packages:write` scope. In addition:
    * - If `package_type` is not `container`, your token must also include the `repo` scope.
    * - If `package_type` is `container`, you must also have admin permissions to the container that you want to restore.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#restore-a-package-version-for-an-organization>
    */
    pub async fn packages_restore_package_version_for_org(
        &self,
        package_type: &str,
        package_name: &str,
        org: &str,
        package_version_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/packages/{}/{}/versions/{}/restore",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            progenitor_support::encode_path(&package_version_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * List organization projects.
    *
    * This function performs a `GET` to the `/orgs/{org}/projects` endpoint.
    *
    * Lists the projects in an organization. Returns a `404 Not Found` status if projects are disabled in the organization. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    *
    * FROM: <https://docs.github.com/rest/reference/projects#list-organization-projects>
    */
    pub async fn projects_list_for_org(
        &self,
        org: &str,
        state: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Project>> {
        let url = format!(
            "/orgs/{}/projects?page={}&per_page={}&state={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            state.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create an organization project.
    *
    * This function performs a `POST` to the `/orgs/{org}/projects` endpoint.
    *
    * Creates an organization project board. Returns a `404 Not Found` status if projects are disabled in the organization. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    *
    * FROM: <https://docs.github.com/rest/reference/projects#create-an-organization-project>
    */
    pub async fn projects_create_for_org(
        &self,
        org: &str,
        body: &types::CreateOrganizationProjectRequest,
    ) -> Result<types::Project> {
        let url = format!(
            "/orgs/{}/projects",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List public organization members.
    *
    * This function performs a `GET` to the `/orgs/{org}/public_members` endpoint.
    *
    * Members of an organization can choose to have their membership publicized or not.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#list-public-organization-members>
    */
    pub async fn orgs_list_public_members(
        &self,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/orgs/{}/public_members?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Check public organization membership for a user.
    *
    * This function performs a `GET` to the `/orgs/{org}/public_members/{username}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#check-public-organization-membership-for-a-user>
    */
    pub async fn orgs_check_public_membership_for_user(
        &self,
        org: &str,
        username: &str,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/public_members/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Set public organization membership for the authenticated user.
    *
    * This function performs a `PUT` to the `/orgs/{org}/public_members/{username}` endpoint.
    *
    * The user can publicize their own membership. (A user cannot publicize the membership for another user.)
    *
    * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#set-public-organization-membership-for-the-authenticated-user>
    */
    pub async fn orgs_set_public_membership_for_authenticated_user(
        &self,
        org: &str,
        username: &str,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/public_members/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Remove public organization membership for the authenticated user.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/public_members/{username}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#remove-public-organization-membership-for-the-authenticated-user>
    */
    pub async fn orgs_remove_public_membership_for_authenticated_user(
        &self,
        org: &str,
        username: &str,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/public_members/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List organization repositories.
    *
    * This function performs a `GET` to the `/orgs/{org}/repos` endpoint.
    *
    * Lists repositories for the specified organization.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-organization-repositories>
    */
    pub async fn repos_list_for_org(
        &self,
        org: &str,
        type_: &str,
        sort: &str,
        direction: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/orgs/{}/repos?direction={}&page={}&per_page={}&sort={}&type={}",
            progenitor_support::encode_path(&org.to_string()),
            direction.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            sort.to_string(),
            type_,
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create an organization repository.
    *
    * This function performs a `POST` to the `/orgs/{org}/repos` endpoint.
    *
    * Creates a new repository in the specified organization. The authenticated user must be a member of the organization.
    *
    * **OAuth scope requirements**
    *
    * When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
    *
    * *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
    * *   `repo` scope to create a private repository
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-an-organization-repository>
    */
    pub async fn repos_create_in_org(
        &self,
        org: &str,
        body: &types::CreateOrganizationRepositoryRequest,
    ) -> Result<types::Repository> {
        let url = format!(
            "/orgs/{}/repos",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get GitHub Actions billing for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/settings/billing/actions` endpoint.
    *
    * Gets the summary of the free and paid GitHub Actions minutes used.
    *
    * Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also included in the usage. The usage returned includes any minute multipliers for macOS and Windows runners, and is rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
    *
    * Access tokens must have the `repo` or `admin:org` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/billing#get-github-actions-billing-for-an-organization>
    */
    pub async fn billing_get_github_actions_billing_org(
        &self,
        org: &str,
    ) -> Result<types::ActionsBillingUsage> {
        let url = format!(
            "/orgs/{}/settings/billing/actions",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get GitHub Packages billing for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/settings/billing/packages` endpoint.
    *
    * Gets the free and paid storage used for GitHub Packages in gigabytes.
    *
    * Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
    *
    * Access tokens must have the `repo` or `admin:org` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/billing#get-github-packages-billing-for-an-organization>
    */
    pub async fn billing_get_github_packages_billing_org(
        &self,
        org: &str,
    ) -> Result<types::PackagesBillingUsage> {
        let url = format!(
            "/orgs/{}/settings/billing/packages",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get shared storage billing for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/settings/billing/shared-storage` endpoint.
    *
    * Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
    *
    * Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
    *
    * Access tokens must have the `repo` or `admin:org` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/billing#get-shared-storage-billing-for-an-organization>
    */
    pub async fn billing_get_shared_storage_billing_org(
        &self,
        org: &str,
    ) -> Result<types::CombinedBillingUsage> {
        let url = format!(
            "/orgs/{}/settings/billing/shared-storage",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List IdP groups for an organization.
    *
    * This function performs a `GET` to the `/orgs/{org}/team-sync/groups` endpoint.
    *
    * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * List IdP groups available in an organization. You can limit your page results using the `per_page` parameter. GitHub generates a url-encoded `page` token using a cursor value for where the next page begins. For more information on cursor pagination, see "[Offset and Cursor Pagination explained](https://dev.to/jackmarchant/offset-and-cursor-pagination-explained-b89)."
    *
    * The `per_page` parameter provides pagination for a list of IdP groups the authenticated user can access in an organization. For example, if the user `octocat` wants to see two groups per page in `octo-org` via cURL, it would look like this:
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-idp-groups-for-an-organization>
    */
    pub async fn teams_list_idp_groups_for_org(
        &self,
        org: &str,
        per_page: i64,
        page: &str,
    ) -> Result<types::GroupMapping> {
        let url = format!(
            "/orgs/{}/team-sync/groups?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            page.to_string(),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * List teams.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams` endpoint.
    *
    * Lists all teams in an organization that are visible to the authenticated user.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-teams>
    */
    pub async fn teams_list(
        &self,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Team>> {
        let url = format!(
            "/orgs/{}/teams?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a team.
    *
    * This function performs a `POST` to the `/orgs/{org}/teams` endpoint.
    *
    * To create a team, the authenticated user must be a member or owner of `{org}`. By default, organization members can create teams. Organization owners can limit team creation to organization owners. For more information, see "[Setting team creation permissions](https://help.github.com/en/articles/setting-team-creation-permissions-in-your-organization)."
    *
    * When you create a new team, you automatically become a team maintainer without explicitly adding yourself to the optional array of `maintainers`. For more information, see "[About teams](https://help.github.com/en/github/setting-up-and-managing-organizations-and-teams/about-teams)".
    *
    * FROM: <https://docs.github.com/rest/reference/teams#create-a-team>
    */
    pub async fn teams_create(
        &self,
        org: &str,
        body: &types::CreateTeamRequest,
    ) -> Result<types::TeamFull> {
        let url = format!(
            "/orgs/{}/teams",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a team by name.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}` endpoint.
    *
    * Gets a team using the team's `slug`. GitHub generates the `slug` from the team `name`.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#get-a-team-by-name>
    */
    pub async fn teams_get_by_name(&self, org: &str, team_slug: &str) -> Result<types::TeamFull> {
        let url = format!(
            "/orgs/{}/teams/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a team.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}` endpoint.
    *
    * To delete a team, the authenticated user must be an organization owner or team maintainer.
    *
    * If you are an organization owner, deleting a parent team will delete all of its child teams as well.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#delete-a-team>
    */
    pub async fn teams_delete_in_org(&self, org: &str, team_slug: &str) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a team.
    *
    * This function performs a `PATCH` to the `/orgs/{org}/teams/{team_slug}` endpoint.
    *
    * To edit a team, the authenticated user must either be an organization owner or a team maintainer.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#update-a-team>
    */
    pub async fn teams_update_in_org(
        &self,
        org: &str,
        team_slug: &str,
        body: &types::UpdateTeamRequest,
    ) -> Result<types::TeamFull> {
        let url = format!(
            "/orgs/{}/teams/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List discussions.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/discussions` endpoint.
    *
    * List all discussions on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-discussions>
    */
    pub async fn teams_list_discussions_in_org(
        &self,
        org: &str,
        team_slug: &str,
        direction: &str,
        per_page: i64,
        page: i64,
        pinned: &str,
    ) -> Result<Vec<types::TeamDiscussion>> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions?direction={}&page={}&per_page={}&pinned={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            direction.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            pinned.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a discussion.
    *
    * This function performs a `POST` to the `/orgs/{org}/teams/{team_slug}/discussions` endpoint.
    *
    * Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/{org_id}/team/{team_id}/discussions`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#create-a-discussion>
    */
    pub async fn teams_create_discussion_in_org(
        &self,
        org: &str,
        team_slug: &str,
        body: &types::CreateDiscussionRequest,
    ) -> Result<types::TeamDiscussion> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a discussion.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}` endpoint.
    *
    * Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#get-a-discussion>
    */
    pub async fn teams_get_discussion_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
    ) -> Result<types::TeamDiscussion> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a discussion.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}` endpoint.
    *
    * Delete a discussion from a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#delete-a-discussion>
    */
    pub async fn teams_delete_discussion_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a discussion.
    *
    * This function performs a `PATCH` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}` endpoint.
    *
    * Edits the title and body text of a discussion post. Only the parameters you provide are updated. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#update-a-discussion>
    */
    pub async fn teams_update_discussion_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        body: &types::UpdateDiscussionRequest,
    ) -> Result<types::TeamDiscussion> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List discussion comments.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments` endpoint.
    *
    * List all comments on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-discussion-comments>
    */
    pub async fn teams_list_discussion_comments_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        direction: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::TeamDiscussionComment>> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments?direction={}&page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            direction.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a discussion comment.
    *
    * This function performs a `POST` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments` endpoint.
    *
    * Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#create-a-discussion-comment>
    */
    pub async fn teams_create_discussion_comment_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        body: &types::CreateDiscussionCommentRequest,
    ) -> Result<types::TeamDiscussionComment> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a discussion comment.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}` endpoint.
    *
    * Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#get-a-discussion-comment>
    */
    pub async fn teams_get_discussion_comment_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        comment_number: i64,
    ) -> Result<types::TeamDiscussionComment> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a discussion comment.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}` endpoint.
    *
    * Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#delete-a-discussion-comment>
    */
    pub async fn teams_delete_discussion_comment_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        comment_number: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a discussion comment.
    *
    * This function performs a `PATCH` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}` endpoint.
    *
    * Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/discussions/{discussion_number}/comments/{comment_number}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#update-a-discussion-comment>
    */
    pub async fn teams_update_discussion_comment_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        comment_number: i64,
        body: &types::UpdateDiscussionCommentRequest,
    ) -> Result<types::TeamDiscussionComment> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List reactions for a team discussion comment.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions` endpoint.
    *
    * List the reactions to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments/). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion-comment>
    */
    pub async fn reactions_list_for_team_discussion_comment_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        comment_number: i64,
        content: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
            content.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create reaction for a team discussion comment.
    *
    * This function performs a `POST` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions` endpoint.
    *
    * Create a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion-comment>
    */
    pub async fn reactions_create_for_team_discussion_comment_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        comment_number: i64,
        body: &types::CreateReactionTeamDiscussionCommentRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments/{}/reactions",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete team discussion comment reaction.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}` endpoint.
    *
    * **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.
    *
    * Delete a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#delete-team-discussion-comment-reaction>
    */
    pub async fn reactions_delete_for_team_discussion_comment(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        comment_number: i64,
        reaction_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/comments/{}/reactions/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
            progenitor_support::encode_path(&reaction_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List reactions for a team discussion.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions` endpoint.
    *
    * List the reactions to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion>
    */
    pub async fn reactions_list_for_team_discussion_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        content: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            content.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create reaction for a team discussion.
    *
    * This function performs a `POST` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions` endpoint.
    *
    * Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion>
    */
    pub async fn reactions_create_for_team_discussion_in_org(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        body: &types::CreateReactionTeamDiscussionRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/reactions",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete team discussion reaction.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}` endpoint.
    *
    * **Note:** You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.
    *
    * Delete a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#delete-team-discussion-reaction>
    */
    pub async fn reactions_delete_for_team_discussion(
        &self,
        org: &str,
        team_slug: &str,
        discussion_number: i64,
        reaction_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/discussions/{}/reactions/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&reaction_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List pending team invitations.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/invitations` endpoint.
    *
    * The return hash contains a `role` field which refers to the Organization Invitation role and will be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be `null`.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/invitations`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-pending-team-invitations>
    */
    pub async fn teams_list_pending_invitations_in_org(
        &self,
        org: &str,
        team_slug: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::OrganizationInvitation>> {
        let url = format!(
            "/orgs/{}/teams/{}/invitations?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List team members.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/members` endpoint.
    *
    * Team members will include the members of child teams.
    *
    * To list members in a team, the team must be visible to the authenticated user.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-team-members>
    */
    pub async fn teams_list_members_in_org(
        &self,
        org: &str,
        team_slug: &str,
        role: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/orgs/{}/teams/{}/members?page={}&per_page={}&role={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            role.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get team membership for a user.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/memberships/{username}` endpoint.
    *
    * Team members will include the members of child teams.
    *
    * To get a user's membership with a team, the team must be visible to the authenticated user.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/memberships/{username}`.
    *
    * **Note:**
    * The response contains the `state` of the membership and the member's `role`.
    *
    * The `role` for organization owners is set to `maintainer`. For more information about `maintainer` roles, see see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
    *
    * FROM: <https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user>
    */
    pub async fn teams_get_membership_for_user_in_org(
        &self,
        org: &str,
        team_slug: &str,
        username: &str,
    ) -> Result<types::TeamMembership> {
        let url = format!(
            "/orgs/{}/teams/{}/memberships/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Add or update team membership for a user.
    *
    * This function performs a `PUT` to the `/orgs/{org}/teams/{team_slug}/memberships/{username}` endpoint.
    *
    * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Adds an organization member to a team. An authenticated organization owner or team maintainer can add organization members to a team.
    *
    * **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://help.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
    *
    * An organization owner can add someone who is not part of the team's organization to a team. When an organization owner adds someone to a team who is not an organization member, this endpoint will send an invitation to the person via email. This newly-created membership will be in the "pending" state until the person accepts the invitation, at which point the membership will transition to the "active" state and the user will be added as a member of the team.
    *
    * If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/memberships/{username}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user>
    */
    pub async fn teams_add_or_update_membership_for_user_in_org(
        &self,
        org: &str,
        team_slug: &str,
        username: &str,
        body: &types::AddUpdateTeamMembershipUserRequest,
    ) -> Result<types::TeamMembership> {
        let url = format!(
            "/orgs/{}/teams/{}/memberships/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove team membership for a user.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}/memberships/{username}` endpoint.
    *
    * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * To remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.
    *
    * **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://help.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/memberships/{username}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user>
    */
    pub async fn teams_remove_membership_for_user_in_org(
        &self,
        org: &str,
        team_slug: &str,
        username: &str,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/memberships/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List team projects.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/projects` endpoint.
    *
    * Lists the organization projects for a team.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/projects`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-team-projects>
    */
    pub async fn teams_list_projects_in_org(
        &self,
        org: &str,
        team_slug: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::TeamProject>> {
        let url = format!(
            "/orgs/{}/teams/{}/projects?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Check team permissions for a project.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/projects/{project_id}` endpoint.
    *
    * Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The response includes projects inherited from a parent team.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-project>
    */
    pub async fn teams_check_permissions_for_project_in_org(
        &self,
        org: &str,
        team_slug: &str,
        project_id: i64,
    ) -> Result<types::TeamProject> {
        let url = format!(
            "/orgs/{}/teams/{}/projects/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Add or update team project permissions.
    *
    * This function performs a `PUT` to the `/orgs/{org}/teams/{team_slug}/projects/{project_id}` endpoint.
    *
    * Adds an organization project to a team. To add a project to a team or update the team's permission on a project, the authenticated user must have `admin` permissions for the project. The project and team must be part of the same organization.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#add-or-update-team-project-permissions>
    */
    pub async fn teams_add_or_update_project_permissions_in_org(
        &self,
        org: &str,
        team_slug: &str,
        project_id: i64,
        body: &types::AddUpdateTeamProjectPermissionsRequest,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/projects/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove a project from a team.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}/projects/{project_id}` endpoint.
    *
    * Removes an organization project from a team. An organization owner or a team maintainer can remove any project from the team. To remove a project from a team as an organization member, the authenticated user must have `read` access to both the team and project, or `admin` access to the team or project. This endpoint removes the project from the team, but does not delete the project.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/projects/{project_id}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#remove-a-project-from-a-team>
    */
    pub async fn teams_remove_project_in_org(
        &self,
        org: &str,
        team_slug: &str,
        project_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/projects/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List team repositories.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/repos` endpoint.
    *
    * Lists a team's repositories visible to the authenticated user.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-team-repositories>
    */
    pub async fn teams_list_repos_in_org(
        &self,
        org: &str,
        team_slug: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/orgs/{}/teams/{}/repos?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Check team permissions for a repository.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}` endpoint.
    *
    * Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a repository. Repositories inherited through a parent team will also be checked.
    *
    * You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `application/vnd.github.v3.repository+json` accept header.
    *
    * If a team doesn't have permission for the repository, you will receive a `404 Not Found` response status.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams/#check-team-permissions-for-a-repository>
    */
    pub async fn teams_check_permissions_for_repo_in_org(
        &self,
        org: &str,
        team_slug: &str,
        owner: &str,
        repo: &str,
    ) -> Result<types::TeamRepository> {
        let url = format!(
            "/orgs/{}/teams/{}/repos/{}/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Add or update team repository permissions.
    *
    * This function performs a `PUT` to the `/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}` endpoint.
    *
    * To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is not owned by the organization. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
    *
    * For more information about the permission levels, see "[Repository permission levels for an organization](https://help.github.com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
    *
    * FROM: <https://docs.github.com/rest/reference/teams/#add-or-update-team-repository-permissions>
    */
    pub async fn teams_add_or_update_repo_permissions_in_org(
        &self,
        org: &str,
        team_slug: &str,
        owner: &str,
        repo: &str,
        body: &types::AddUpdateTeamRepositoryPermissionsRequest,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/repos/{}/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove a repository from a team.
    *
    * This function performs a `DELETE` to the `/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}` endpoint.
    *
    * If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. This does not delete the repository, it just removes it from the team.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams/#remove-a-repository-from-a-team>
    */
    pub async fn teams_remove_repo_in_org(
        &self,
        org: &str,
        team_slug: &str,
        owner: &str,
        repo: &str,
    ) -> Result<()> {
        let url = format!(
            "/orgs/{}/teams/{}/repos/{}/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List IdP groups for a team.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/team-sync/group-mappings` endpoint.
    *
    * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * List IdP groups connected to a team on GitHub.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-idp-groups-for-a-team>
    */
    pub async fn teams_list_idp_groups_in_org(
        &self,
        org: &str,
        team_slug: &str,
    ) -> Result<types::GroupMapping> {
        let url = format!(
            "/orgs/{}/teams/{}/team-sync/group-mappings",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Create or update IdP group connections.
    *
    * This function performs a `PATCH` to the `/orgs/{org}/teams/{team_slug}/team-sync/group-mappings` endpoint.
    *
    * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a team, you must include all new and existing groups to avoid replacing existing groups with the new ones. Specifying an empty `groups` array will remove all connections for a team.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `PATCH /organizations/{org_id}/team/{team_id}/team-sync/group-mappings`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#create-or-update-idp-group-connections>
    */
    pub async fn teams_create_or_update_idp_group_connections_in_org(
        &self,
        org: &str,
        team_slug: &str,
        body: &types::CreateUpdateIdpGroupConnectionsRequest,
    ) -> Result<types::GroupMapping> {
        let url = format!(
            "/orgs/{}/teams/{}/team-sync/group-mappings",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List child teams.
    *
    * This function performs a `GET` to the `/orgs/{org}/teams/{team_slug}/teams` endpoint.
    *
    * Lists the child teams of the team specified by `{team_slug}`.
    *
    * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/teams`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-child-teams>
    */
    pub async fn teams_list_child_in_org(
        &self,
        org: &str,
        team_slug: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Team>> {
        let url = format!(
            "/orgs/{}/teams/{}/teams?page={}&per_page={}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&team_slug.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a project card.
    *
    * This function performs a `GET` to the `/projects/columns/cards/{card_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/projects#get-a-project-card>
    */
    pub async fn projects_get_card(&self, card_id: i64) -> Result<types::ProjectCard> {
        let url = format!(
            "/projects/columns/cards/{}",
            progenitor_support::encode_path(&card_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a project card.
    *
    * This function performs a `DELETE` to the `/projects/columns/cards/{card_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/projects#delete-a-project-card>
    */
    pub async fn projects_delete_card(&self, card_id: i64) -> Result<()> {
        let url = format!(
            "/projects/columns/cards/{}",
            progenitor_support::encode_path(&card_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update an existing project card.
    *
    * This function performs a `PATCH` to the `/projects/columns/cards/{card_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/projects#update-a-project-card>
    */
    pub async fn projects_update_card(
        &self,
        card_id: i64,
        body: &types::UpdateExistingProjectCardRequest,
    ) -> Result<types::ProjectCard> {
        let url = format!(
            "/projects/columns/cards/{}",
            progenitor_support::encode_path(&card_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Move a project card.
    *
    * This function performs a `POST` to the `/projects/columns/cards/{card_id}/moves` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/projects#move-a-project-card>
    */
    pub async fn projects_move_card(
        &self,
        card_id: i64,
        body: &types::MoveProjectCardRequest,
    ) -> Result<types::PostMoveProjectCardCreatedResponse> {
        let url = format!(
            "/projects/columns/cards/{}/moves",
            progenitor_support::encode_path(&card_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a project column.
    *
    * This function performs a `GET` to the `/projects/columns/{column_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/projects#get-a-project-column>
    */
    pub async fn projects_get_column(&self, column_id: i64) -> Result<types::ProjectColumn> {
        let url = format!(
            "/projects/columns/{}",
            progenitor_support::encode_path(&column_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a project column.
    *
    * This function performs a `DELETE` to the `/projects/columns/{column_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/projects#delete-a-project-column>
    */
    pub async fn projects_delete_column(&self, column_id: i64) -> Result<()> {
        let url = format!(
            "/projects/columns/{}",
            progenitor_support::encode_path(&column_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update an existing project column.
    *
    * This function performs a `PATCH` to the `/projects/columns/{column_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/projects#update-a-project-column>
    */
    pub async fn projects_update_column(
        &self,
        column_id: i64,
        body: &types::UpdateExistingProjectColumnRequest,
    ) -> Result<types::ProjectColumn> {
        let url = format!(
            "/projects/columns/{}",
            progenitor_support::encode_path(&column_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List project cards.
    *
    * This function performs a `GET` to the `/projects/columns/{column_id}/cards` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/projects#list-project-cards>
    */
    pub async fn projects_list_cards(
        &self,
        column_id: i64,
        archived_state: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::ProjectCard>> {
        let url = format!(
            "/projects/columns/{}/cards?archived_state={}&page={}&per_page={}",
            progenitor_support::encode_path(&column_id.to_string()),
            archived_state.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a project card.
    *
    * This function performs a `POST` to the `/projects/columns/{column_id}/cards` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/projects#create-a-project-card>
    */
    pub async fn projects_create_card(
        &self,
        column_id: i64,
        body: &types::CreateProjectCardRequest,
    ) -> Result<types::ProjectCard> {
        let url = format!(
            "/projects/columns/{}/cards",
            progenitor_support::encode_path(&column_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Move a project column.
    *
    * This function performs a `POST` to the `/projects/columns/{column_id}/moves` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/projects#move-a-project-column>
    */
    pub async fn projects_move_column(
        &self,
        column_id: i64,
        body: &types::MoveProjectColumnRequest,
    ) -> Result<types::PostMoveProjectColumnCreatedResponse> {
        let url = format!(
            "/projects/columns/{}/moves",
            progenitor_support::encode_path(&column_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a project.
    *
    * This function performs a `GET` to the `/projects/{project_id}` endpoint.
    *
    * Gets a project by its `id`. Returns a `404 Not Found` status if projects are disabled. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    *
    * FROM: <https://docs.github.com/rest/reference/projects#get-a-project>
    */
    pub async fn projects_get(&self, project_id: i64) -> Result<types::Project> {
        let url = format!(
            "/projects/{}",
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a project.
    *
    * This function performs a `DELETE` to the `/projects/{project_id}` endpoint.
    *
    * Deletes a project board. Returns a `404 Not Found` status if projects are disabled.
    *
    * FROM: <https://docs.github.com/rest/reference/projects#delete-a-project>
    */
    pub async fn projects_delete(&self, project_id: i64) -> Result<()> {
        let url = format!(
            "/projects/{}",
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a project.
    *
    * This function performs a `PATCH` to the `/projects/{project_id}` endpoint.
    *
    * Updates a project board's information. Returns a `404 Not Found` status if projects are disabled. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    *
    * FROM: <https://docs.github.com/rest/reference/projects#update-a-project>
    */
    pub async fn projects_update(
        &self,
        project_id: i64,
        body: &types::UpdateProjectRequest,
    ) -> Result<types::Project> {
        let url = format!(
            "/projects/{}",
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List project collaborators.
    *
    * This function performs a `GET` to the `/projects/{project_id}/collaborators` endpoint.
    *
    * Lists the collaborators for an organization project. For a project, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners. You must be an organization owner or a project `admin` to list collaborators.
    *
    * FROM: <https://docs.github.com/rest/reference/projects#list-project-collaborators>
    */
    pub async fn projects_list_collaborators(
        &self,
        project_id: i64,
        affiliation: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/projects/{}/collaborators?affiliation={}&page={}&per_page={}",
            progenitor_support::encode_path(&project_id.to_string()),
            affiliation.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Add project collaborator.
    *
    * This function performs a `PUT` to the `/projects/{project_id}/collaborators/{username}` endpoint.
    *
    * Adds a collaborator to an organization project and sets their permission level. You must be an organization owner or a project `admin` to add a collaborator.
    *
    * FROM: <https://docs.github.com/rest/reference/projects#add-project-collaborator>
    */
    pub async fn projects_add_collaborator(
        &self,
        project_id: i64,
        username: &str,
        body: &types::AddProjectCollaboratorRequest,
    ) -> Result<()> {
        let url = format!(
            "/projects/{}/collaborators/{}",
            progenitor_support::encode_path(&project_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove user as a collaborator.
    *
    * This function performs a `DELETE` to the `/projects/{project_id}/collaborators/{username}` endpoint.
    *
    * Removes a collaborator from an organization project. You must be an organization owner or a project `admin` to remove a collaborator.
    *
    * FROM: <https://docs.github.com/rest/reference/projects#remove-project-collaborator>
    */
    pub async fn projects_remove_collaborator(
        &self,
        project_id: i64,
        username: &str,
    ) -> Result<()> {
        let url = format!(
            "/projects/{}/collaborators/{}",
            progenitor_support::encode_path(&project_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get project permission for a user.
    *
    * This function performs a `GET` to the `/projects/{project_id}/collaborators/{username}/permission` endpoint.
    *
    * Returns the collaborator's permission level for an organization project. Possible values for the `permission` key: `admin`, `write`, `read`, `none`. You must be an organization owner or a project `admin` to review a user's permission level.
    *
    * FROM: <https://docs.github.com/rest/reference/projects#get-project-permission-for-a-user>
    */
    pub async fn projects_get_permission_for_user(
        &self,
        project_id: i64,
        username: &str,
    ) -> Result<types::RepositoryCollaboratorPermission> {
        let url = format!(
            "/projects/{}/collaborators/{}/permission",
            progenitor_support::encode_path(&project_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List project columns.
    *
    * This function performs a `GET` to the `/projects/{project_id}/columns` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/projects#list-project-columns>
    */
    pub async fn projects_list_columns(
        &self,
        project_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::ProjectColumn>> {
        let url = format!(
            "/projects/{}/columns?page={}&per_page={}",
            progenitor_support::encode_path(&project_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a project column.
    *
    * This function performs a `POST` to the `/projects/{project_id}/columns` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/projects#create-a-project-column>
    */
    pub async fn projects_create_column(
        &self,
        project_id: i64,
        body: &types::CreateProjectColumnRequest,
    ) -> Result<types::ProjectColumn> {
        let url = format!(
            "/projects/{}/columns",
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get rate limit status for the authenticated user.
    *
    * This function performs a `GET` to the `/rate_limit` endpoint.
    *
    * **Note:** Accessing this endpoint does not count against your REST API rate limit.
    *
    * **Note:** The `rate` object is deprecated. If you're writing new API client code or updating existing code, you should use the `core` object instead of the `rate` object. The `core` object contains the same information that is present in the `rate` object.
    *
    * FROM: <https://docs.github.com/rest/reference/rate-limit#get-rate-limit-status-for-the-authenticated-user>
    */
    pub async fn rate_limit_get(&self) -> Result<types::RateLimitOverview> {
        let url = "/rate_limit".to_string();
        self.get(&url).await
    }

    /**
    * Delete a reaction (Legacy).
    *
    * This function performs a `DELETE` to the `/reactions/{reaction_id}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Reactions API. We recommend migrating your existing code to use the new delete reactions endpoints. For more information, see this [blog post](https://developer.github.com/changes/2020-02-26-new-delete-reactions-endpoints/).
    *
    * OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), when deleting a [team discussion](https://docs.github.com/rest/reference/teams#discussions) or [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments).
    *
    * FROM: <https://docs.github.com/rest/reference/reactions/#delete-a-reaction-legacy>
    */
    pub async fn reactions_delete_legacy(&self, reaction_id: i64) -> Result<()> {
        let url = format!(
            "/reactions/{}",
            progenitor_support::encode_path(&reaction_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}` endpoint.
    *
    * When you pass the `scarlet-witch-preview` media type, requests to get a repository will also return the repository's code of conduct if it can be detected from the repository's code of conduct file.
    *
    * The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-repository>
    */
    pub async fn repos_get(&self, owner: &str, repo: &str) -> Result<types::FullRepository> {
        let url = format!(
            "/repos/{}/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a repository.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}` endpoint.
    *
    * Deleting a repository requires admin access. If OAuth is used, the `delete_repo` scope is required.
    *
    * If an organization owner has configured the organization to prevent members from deleting organization-owned
    * repositories, you will get a `403 Forbidden` response.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-a-repository>
    */
    pub async fn repos_delete(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a repository.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}` endpoint.
    *
    * **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.github.com/rest/reference/repos#replace-all-repository-topics) endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/repos/#update-a-repository>
    */
    pub async fn repos_update(
        &self,
        owner: &str,
        repo: &str,
        body: &types::UpdateRepositoryRequest,
    ) -> Result<types::FullRepository> {
        let url = format!(
            "/repos/{}/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List artifacts for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/artifacts` endpoint.
    *
    * Lists all artifacts for a repository. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-artifacts-for-a-repository>
    */
    pub async fn actions_list_artifacts_for_repo(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListArtifactsRepositoryOkResponse> {
        let url = format!(
            "/repos/{}/{}/actions/artifacts?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Get an artifact.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/artifacts/{artifact_id}` endpoint.
    *
    * Gets a specific artifact for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-an-artifact>
    */
    pub async fn actions_get_artifact(
        &self,
        owner: &str,
        repo: &str,
        artifact_id: i64,
    ) -> Result<types::Artifact> {
        let url = format!(
            "/repos/{}/{}/actions/artifacts/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&artifact_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete an artifact.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/actions/artifacts/{artifact_id}` endpoint.
    *
    * Deletes an artifact for a workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#delete-an-artifact>
    */
    pub async fn actions_delete_artifact(
        &self,
        owner: &str,
        repo: &str,
        artifact_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/artifacts/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&artifact_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Download an artifact.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}` endpoint.
    *
    * Gets a redirect URL to download an archive for a repository. This URL expires after 1 minute. Look for `Location:` in
    * the response header to find the URL for the download. The `:archive_format` must be `zip`. Anyone with read access to
    * the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope.
    * GitHub Apps must have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#download-an-artifact>
    */
    pub async fn actions_download_artifact(
        &self,
        owner: &str,
        repo: &str,
        artifact_id: i64,
        archive_format: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/artifacts/{}/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&artifact_id.to_string()),
            progenitor_support::encode_path(&archive_format.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get a job for a workflow run.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/jobs/{job_id}` endpoint.
    *
    * Gets a specific job in a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-a-job-for-a-workflow-run>
    */
    pub async fn actions_get_job_for_workflow_run(
        &self,
        owner: &str,
        repo: &str,
        job_id: i64,
    ) -> Result<types::Job> {
        let url = format!(
            "/repos/{}/{}/actions/jobs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&job_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Download job logs for a workflow run.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/jobs/{job_id}/logs` endpoint.
    *
    * Gets a redirect URL to download a plain text file of logs for a workflow job. This link expires after 1 minute. Look
    * for `Location:` in the response header to find the URL for the download. Anyone with read access to the repository can
    * use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must
    * have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#download-job-logs-for-a-workflow-run>
    */
    pub async fn actions_download_job_logs_for_workflow_run(
        &self,
        owner: &str,
        repo: &str,
        job_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/jobs/{}/logs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&job_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get GitHub Actions permissions for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/permissions` endpoint.
    *
    * Gets the GitHub Actions permissions policy for a repository, including whether GitHub Actions is enabled and the actions allowed to run in the repository.
    *
    * You must authenticate using an access token with the `repo` scope to use this
    * endpoint. GitHub Apps must have the `administration` repository permission to use this API.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-github-actions-permissions-for-a-repository>
    */
    pub async fn actions_get_github_actions_permissions_repository(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::ActionsRepositoryPermissions> {
        let url = format!(
            "/repos/{}/{}/actions/permissions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Set GitHub Actions permissions for a repository.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/actions/permissions` endpoint.
    *
    * Sets the GitHub Actions permissions policy for enabling GitHub Actions and allowed actions in the repository.
    *
    * If the repository belongs to an organization or enterprise that has set restrictive permissions at the organization or enterprise levels, such as `allowed_actions` to `selected` actions, then you cannot override them for the repository.
    *
    * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#set-github-actions-permissions-for-a-repository>
    */
    pub async fn actions_set_github_actions_permissions_repository(
        &self,
        owner: &str,
        repo: &str,
        body: &types::SetGithubActionsPermissionsRepositoryRequest,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/permissions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get allowed actions for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/permissions/selected-actions` endpoint.
    *
    * Gets the settings for selected actions that are allowed in a repository. To use this endpoint, the repository policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."
    *
    * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-allowed-actions-for-a-repository>
    */
    pub async fn actions_get_allowed_actions_repository(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::SelectedActions> {
        let url = format!(
            "/repos/{}/{}/actions/permissions/selected-actions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Set allowed actions for a repository.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/actions/permissions/selected-actions` endpoint.
    *
    * Sets the actions that are allowed in a repository. To use this endpoint, the repository permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."
    *
    * If the repository belongs to an organization or enterprise that has `selected` actions set at the organization or enterprise levels, then you cannot override any of the allowed actions settings.
    *
    * To use the `patterns_allowed` setting for private repositories, the repository must belong to an enterprise. If the repository does not belong to an enterprise, then the `patterns_allowed` setting only applies to public repositories.
    *
    * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#set-allowed-actions-for-a-repository>
    */
    pub async fn actions_set_allowed_actions_repository(
        &self,
        owner: &str,
        repo: &str,
        body: &types::SelectedActions,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/permissions/selected-actions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List self-hosted runners for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runners` endpoint.
    *
    * Lists all self-hosted runners configured in a repository. You must authenticate using an access token with the `repo` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-self-hosted-runners-for-a-repository>
    */
    pub async fn actions_list_self_hosted_runners_for_repo(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListSelfDataHostedRunnersRepositoryOkResponse> {
        let url = format!(
            "/repos/{}/{}/actions/runners?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * List runner applications for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runners/downloads` endpoint.
    *
    * Lists binaries for the runner application that you can download and run.
    *
    * You must authenticate using an access token with the `repo` scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-runner-applications-for-a-repository>
    */
    pub async fn actions_list_runner_applications_for_repo(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<Vec<types::RunnerApplication>> {
        let url = format!(
            "/repos/{}/{}/actions/runners/downloads",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a registration token for a repository.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/actions/runners/registration-token` endpoint.
    *
    * Returns a token that you can pass to the `config` script. The token expires after one hour. You must authenticate
    * using an access token with the `repo` scope to use this endpoint.
    *
    * #### Example using registration token
    *  
    * Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.
    *
    * ```
    * ./config.sh --url https://github.com/octo-org/octo-repo-artifacts --token TOKEN
    * ```
    *
    * FROM: <https://docs.github.com/rest/reference/actions#create-a-registration-token-for-a-repository>
    */
    pub async fn actions_create_registration_token_for_repo(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::AuthenticationToken> {
        let url = format!(
            "/repos/{}/{}/actions/runners/registration-token",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Create a remove token for a repository.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/actions/runners/remove-token` endpoint.
    *
    * Returns a token that you can pass to remove a self-hosted runner from a repository. The token expires after one hour.
    * You must authenticate using an access token with the `repo` scope to use this endpoint.
    *
    * #### Example using remove token
    *  
    * To remove your self-hosted runner from a repository, replace TOKEN with the remove token provided by this endpoint.
    *
    * ```
    * ./config.sh remove --token TOKEN
    * ```
    *
    * FROM: <https://docs.github.com/rest/reference/actions#create-a-remove-token-for-a-repository>
    */
    pub async fn actions_create_remove_token_for_repo(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::AuthenticationToken> {
        let url = format!(
            "/repos/{}/{}/actions/runners/remove-token",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Get a self-hosted runner for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runners/{runner_id}` endpoint.
    *
    * Gets a specific self-hosted runner configured in a repository.
    *
    * You must authenticate using an access token with the `repo` scope to use this
    * endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-a-self-hosted-runner-for-a-repository>
    */
    pub async fn actions_get_self_hosted_runner_for_repo(
        &self,
        owner: &str,
        repo: &str,
        runner_id: i64,
    ) -> Result<types::Runner> {
        let url = format!(
            "/repos/{}/{}/actions/runners/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a self-hosted runner from a repository.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/actions/runners/{runner_id}` endpoint.
    *
    * Forces the removal of a self-hosted runner from a repository. You can use this endpoint to completely remove the runner when the machine you were using no longer exists.
    *
    * You must authenticate using an access token with the `repo`
    * scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#delete-a-self-hosted-runner-from-a-repository>
    */
    pub async fn actions_delete_self_hosted_runner_from_repo(
        &self,
        owner: &str,
        repo: &str,
        runner_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/runners/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&runner_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List workflow runs for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs` endpoint.
    *
    * Lists all workflow runs for a repository. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
    *
    * Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-workflow-runs-for-a-repository>
    */
    pub async fn actions_list_workflow_runs_for_repo(
        &self,
        owner: &str,
        repo: &str,
        actor: &str,
        branch: &str,
        event: &str,
        status: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListWorkflowRunsRepositoryOkResponse> {
        let url = format!(
            "/repos/{}/{}/actions/runs?actor={}&branch={}&event={}&page={}&per_page={}&status={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            actor.to_string(),
            branch.to_string(),
            event.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            status.to_string(),
        );

        self.get(&url).await
    }

    /**
    * Get a workflow run.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs/{run_id}` endpoint.
    *
    * Gets a specific workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-a-workflow-run>
    */
    pub async fn actions_get_workflow_run(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
    ) -> Result<types::WorkflowRun> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a workflow run.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/actions/runs/{run_id}` endpoint.
    *
    * Delete a specific workflow run. Anyone with write access to the repository can use this endpoint. If the repository is
    * private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:write` permission to use
    * this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#delete-a-workflow-run>
    */
    pub async fn actions_delete_workflow_run(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get the review history for a workflow run.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/approvals` endpoint.
    *
    * Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-the-review-history-for-a-workflow-run>
    */
    pub async fn actions_get_reviews_for_run(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
    ) -> Result<Vec<types::EnvironmentApprovals>> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/approvals",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Approve a workflow run for a fork pull request.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/approve` endpoint.
    *
    * **Note:** This endpoint is currently in beta and is subject to change.
    *
    * Approves a workflow run for a pull request from a public fork of a first time contributor. For more information, see ["Approving workflow runs from public forks](https://docs.github.com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)."
    *
    * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#approve-a-workflow-run-for-a-fork-pull-request>
    */
    pub async fn actions_approve_workflow_run(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
    ) -> Result<types::EmptyObject> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/approve",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * List workflow run artifacts.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/artifacts` endpoint.
    *
    * Lists artifacts for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-workflow-run-artifacts>
    */
    pub async fn actions_list_workflow_run_artifacts(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListWorkflowRunArtifactsOkResponse> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/artifacts?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Cancel a workflow run.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/cancel` endpoint.
    *
    * Cancels a workflow run using its `id`. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#cancel-a-workflow-run>
    */
    pub async fn actions_cancel_workflow_run(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
    ) -> Result<types::PostCancelWorkflowRunAcceptedResponse> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/cancel",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * List jobs for a workflow run.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/jobs` endpoint.
    *
    * Lists jobs for a workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-jobs-for-a-workflow-run>
    */
    pub async fn actions_list_jobs_for_workflow_run(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
        filter: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListJobsWorkflowRunOkResponse> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/jobs?filter={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
            filter.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Download workflow run logs.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/logs` endpoint.
    *
    * Gets a redirect URL to download an archive of log files for a workflow run. This link expires after 1 minute. Look for
    * `Location:` in the response header to find the URL for the download. Anyone with read access to the repository can use
    * this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have
    * the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#download-workflow-run-logs>
    */
    pub async fn actions_download_workflow_run_logs(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/logs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete workflow run logs.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/logs` endpoint.
    *
    * Deletes all logs for a workflow run. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#delete-workflow-run-logs>
    */
    pub async fn actions_delete_workflow_run_logs(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/logs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get pending deployments for a workflow run.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments` endpoint.
    *
    * Get all deployment environments for a workflow run that are waiting for protection rules to pass.
    *
    * Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-pending-deployments-for-a-workflow-run>
    */
    pub async fn actions_get_pending_deployments_for_run(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
    ) -> Result<Vec<types::PendingDeployment>> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/pending_deployments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Review pending deployments for a workflow run.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments` endpoint.
    *
    * Approve or reject pending deployments that are waiting on approval by a required reviewer.
    *
    * Anyone with read access to the repository contents and deployments can use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#review-pending-deployments-for-a-workflow-run>
    */
    pub async fn actions_review_pending_deployments_for_run(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
        body: &types::ReviewPendingDeploymentsWorkflowRunRequest,
    ) -> Result<Vec<types::Deployment>> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/pending_deployments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Re-run a workflow.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/rerun` endpoint.
    *
    * Re-runs your workflow run using its `id`. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#re-run-a-workflow>
    */
    pub async fn actions_re_run_workflow(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
    ) -> Result<types::PostReRunWorkflowCreatedResponse> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/rerun",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Get workflow run usage.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/runs/{run_id}/timing` endpoint.
    *
    * Gets the number of billable minutes and total run time for a specific workflow run. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
    *
    * Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-workflow-run-usage>
    */
    pub async fn actions_get_workflow_run_usage(
        &self,
        owner: &str,
        repo: &str,
        run_id: i64,
    ) -> Result<types::WorkflowRunUsage> {
        let url = format!(
            "/repos/{}/{}/actions/runs/{}/timing",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&run_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List repository secrets.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/secrets` endpoint.
    *
    * Lists all secrets available in a repository without revealing their encrypted values. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-repository-secrets>
    */
    pub async fn actions_list_repo_secrets(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListRepositorySecretsOkResponse> {
        let url = format!(
            "/repos/{}/{}/actions/secrets?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Get a repository public key.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/secrets/public-key` endpoint.
    *
    * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `secrets` repository permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-a-repository-public-key>
    */
    pub async fn actions_get_repo_public_key(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::ActionsPublicKey> {
        let url = format!(
            "/repos/{}/{}/actions/secrets/public-key",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get a repository secret.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/secrets/{secret_name}` endpoint.
    *
    * Gets a single repository secret without revealing its encrypted value. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-a-repository-secret>
    */
    pub async fn actions_get_repo_secret(
        &self,
        owner: &str,
        repo: &str,
        secret_name: &str,
    ) -> Result<types::ActionsSecret> {
        let url = format!(
            "/repos/{}/{}/actions/secrets/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Create or update a repository secret.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/actions/secrets/{secret_name}` endpoint.
    *
    * Creates or updates a repository secret with an encrypted value. Encrypt your secret using
    * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
    * token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use
    * this endpoint.
    *
    * #### Example encrypting a secret using Node.js
    *
    * Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
    *
    * ```
    * const sodium = require('tweetsodium');
    *
    * const key = "base64-encoded-public-key";
    * const value = "plain-text-secret";
    *
    * // Convert the message and key to Uint8Array's (Buffer implements that interface)
    * const messageBytes = Buffer.from(value);
    * const keyBytes = Buffer.from(key, 'base64');
    *
    * // Encrypt using LibSodium.
    * const encryptedBytes = sodium.seal(messageBytes, keyBytes);
    *
    * // Base64 the encrypted secret
    * const encrypted = Buffer.from(encryptedBytes).toString('base64');
    *
    * console.log(encrypted);
    * ```
    *
    *
    * #### Example encrypting a secret using Python
    *
    * Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/stable/public/#nacl-public-sealedbox) with Python 3.
    *
    * ```
    * from base64 import b64encode
    * from nacl import encoding, public
    *
    * def encrypt(public_key: str, secret_value: str) -> str:
    *   """Encrypt a Unicode string using the public key."""
    *   public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
    *   sealed_box = public.SealedBox(public_key)
    *   encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
    *   return b64encode(encrypted).decode("utf-8")
    * ```
    *
    * #### Example encrypting a secret using C#
    *
    * Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
    *
    * ```
    * var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
    * var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
    *
    * var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
    *
    * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
    * ```
    *
    * #### Example encrypting a secret using Ruby
    *
    * Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
    *
    * ```ruby
    * require "rbnacl"
    * require "base64"
    *
    * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
    * public_key = RbNaCl::PublicKey.new(key)
    *
    * box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
    * encrypted_secret = box.encrypt("my_secret")
    *
    * # Print the base64 encoded secret
    * puts Base64.strict_encode64(encrypted_secret)
    * ```
    *
    * FROM: <https://docs.github.com/rest/reference/actions#create-or-update-a-repository-secret>
    */
    pub async fn actions_create_or_update_repo_secret(
        &self,
        owner: &str,
        repo: &str,
        secret_name: &str,
        body: &types::CreateUpdateRepositorySecretRequest,
    ) -> Result<types::PutCreateUpdateRepositorySecretCreatedResponse> {
        let url = format!(
            "/repos/{}/{}/actions/secrets/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete a repository secret.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/actions/secrets/{secret_name}` endpoint.
    *
    * Deletes a secret in a repository using the secret name. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#delete-a-repository-secret>
    */
    pub async fn actions_delete_repo_secret(
        &self,
        owner: &str,
        repo: &str,
        secret_name: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/secrets/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List repository workflows.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/workflows` endpoint.
    *
    * Lists the workflows in a repository. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-repository-workflows>
    */
    pub async fn actions_list_repo_workflows(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListRepositoryWorkflowsOkResponse> {
        let url = format!(
            "/repos/{}/{}/actions/workflows?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Get a workflow.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/workflows/{workflow_id}` endpoint.
    *
    * Gets a specific workflow. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-a-workflow>
    */
    pub async fn actions_get_workflow(
        &self,
        owner: &str,
        repo: &str,
        workflow_id: &str,
    ) -> Result<types::Workflow> {
        let url = format!(
            "/repos/{}/{}/actions/workflows/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&workflow_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Disable a workflow.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable` endpoint.
    *
    * Disables a workflow and sets the `state` of the workflow to `disabled_manually`. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.
    *
    * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#disable-a-workflow>
    */
    pub async fn actions_disable_workflow(
        &self,
        owner: &str,
        repo: &str,
        workflow_id: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/workflows/{}/disable",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&workflow_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Create a workflow dispatch event.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches` endpoint.
    *
    * You can use this endpoint to manually trigger a GitHub Actions workflow run. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.
    *
    * You must configure your GitHub Actions workflow to run when the [`workflow_dispatch` webhook](/developers/webhooks-and-events/webhook-events-and-payloads#workflow_dispatch) event occurs. The `inputs` are configured in the workflow file. For more information about how to configure the `workflow_dispatch` event in the workflow file, see "[Events that trigger workflows](/actions/reference/events-that-trigger-workflows#workflow_dispatch)."
    *
    * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint. For more information, see "[Creating a personal access token for the command line](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line)."
    *
    * FROM: <https://docs.github.com/rest/reference/actions#create-a-workflow-dispatch-event>
    */
    pub async fn actions_create_workflow_dispatch(
        &self,
        owner: &str,
        repo: &str,
        workflow_id: &str,
        body: &types::CreateWorkflowDispatchEventRequest,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/workflows/{}/dispatches",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&workflow_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Enable a workflow.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable` endpoint.
    *
    * Enables a workflow and sets the `state` of the workflow to `active`. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.
    *
    * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#enable-a-workflow>
    */
    pub async fn actions_enable_workflow(
        &self,
        owner: &str,
        repo: &str,
        workflow_id: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/actions/workflows/{}/enable",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&workflow_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * List workflow runs.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs` endpoint.
    *
    * List all workflow runs for a workflow. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
    *
    * Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-workflow-runs>
    */
    pub async fn actions_list_workflow_runs(
        &self,
        owner: &str,
        repo: &str,
        workflow_id: &str,
        actor: &str,
        branch: &str,
        event: &str,
        status: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListWorkflowRunsOkResponse> {
        let url = format!("/repos/{}/{}/actions/workflows/{}/runs?actor={}&branch={}&event={}&page={}&per_page={}&status={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&workflow_id.to_string()),
actor.to_string(), branch.to_string(), event.to_string(), format!("{}", page), format!("{}", per_page), status.to_string(),         );

        self.get(&url).await
    }

    /**
    * Get workflow usage.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing` endpoint.
    *
    * Gets the number of billable minutes used by a specific workflow during the current billing cycle. Billable minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are also included in the usage. The usage does not include the multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
    *
    * You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-workflow-usage>
    */
    pub async fn actions_get_workflow_usage(
        &self,
        owner: &str,
        repo: &str,
        workflow_id: &str,
    ) -> Result<types::WorkflowUsage> {
        let url = format!(
            "/repos/{}/{}/actions/workflows/{}/timing",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&workflow_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List assignees.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/assignees` endpoint.
    *
    * Lists the [available assignees](https://help.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#list-assignees>
    */
    pub async fn issues_list_assignees(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/repos/{}/{}/assignees?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Check if a user can be assigned.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/assignees/{assignee}` endpoint.
    *
    * Checks if a user has permission to be assigned to an issue in this repository.
    *
    * If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.
    *
    * Otherwise a `404` status code is returned.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#check-if-a-user-can-be-assigned>
    */
    pub async fn issues_check_user_can_be_assigned(
        &self,
        owner: &str,
        repo: &str,
        assignee: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/assignees/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&assignee.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Enable automated security fixes.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/automated-security-fixes` endpoint.
    *
    * Enables automated security fixes for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring automated security fixes](https://help.github.com/en/articles/configuring-automated-security-fixes)".
    *
    * FROM: <https://docs.github.com/rest/reference/repos#enable-automated-security-fixes>
    */
    pub async fn repos_enable_automated_security_fixes(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/automated-security-fixes",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Disable automated security fixes.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/automated-security-fixes` endpoint.
    *
    * Disables automated security fixes for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring automated security fixes](https://help.github.com/en/articles/configuring-automated-security-fixes)".
    *
    * FROM: <https://docs.github.com/rest/reference/repos#disable-automated-security-fixes>
    */
    pub async fn repos_disable_automated_security_fixes(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/automated-security-fixes",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List branches.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/branches` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-branches>
    */
    pub async fn repos_list_branches(
        &self,
        owner: &str,
        repo: &str,
        protected: bool,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::ShortBranch>> {
        let url = format!(
            "/repos/{}/{}/branches?page={}&per_page={}&protected={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            format!("{}", protected),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a branch.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-branch>
    */
    pub async fn repos_get_branch(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<types::BranchWithProtection> {
        let url = format!(
            "/repos/{}/{}/branches/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get branch protection.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-branch-protection>
    */
    pub async fn repos_get_branch_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<types::BranchProtection> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Update branch protection.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/branches/{branch}/protection` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Protecting a branch requires admin or owner permissions to the repository.
    *
    * **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
    *
    * **Note**: The list of users, apps, and teams in total is limited to 100 items.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#update-branch-protection>
    */
    pub async fn repos_update_branch_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::UpdateBranchProtectionRequest,
    ) -> Result<types::ProtectedBranch> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete branch protection.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-branch-protection>
    */
    pub async fn repos_delete_branch_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get admin branch protection.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-admin-branch-protection>
    */
    pub async fn repos_get_admin_branch_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<types::ProtectedBranchAdminEnforced> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/enforce_admins",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Set admin branch protection.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Adding admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#set-admin-branch-protection>
    */
    pub async fn repos_set_admin_branch_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<types::ProtectedBranchAdminEnforced> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/enforce_admins",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Delete admin branch protection.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Removing admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-admin-branch-protection>
    */
    pub async fn repos_delete_admin_branch_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/enforce_admins",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get pull request review protection.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-pull-request-review-protection>
    */
    pub async fn repos_get_pull_request_review_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<types::ProtectedBranchPullRequestReview> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_pull_request_reviews",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete pull request review protection.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-pull-request-review-protection>
    */
    pub async fn repos_delete_pull_request_review_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_pull_request_reviews",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update pull request review protection.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Updating pull request review enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
    *
    * **Note**: Passing new arrays of `users` and `teams` replaces their previous values.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#update-pull-request-review-protection>
    */
    pub async fn repos_update_pull_request_review_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::UpdatePullRequestReviewProtectionRequest,
    ) -> Result<types::ProtectedBranchPullRequestReview> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_pull_request_reviews",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get commit signature protection.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * When authenticated with admin or owner permissions to the repository, you can use this endpoint to check whether a branch requires signed commits. An enabled status of `true` indicates you must sign commits on this branch. For more information, see [Signing commits with GPG](https://help.github.com/articles/signing-commits-with-gpg) in GitHub Help.
    *
    * **Note**: You must enable branch protection to require signed commits.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-commit-signature-protection>
    */
    pub async fn repos_get_commit_signature_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<types::ProtectedBranchAdminEnforced> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_signatures",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Create commit signature protection.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * When authenticated with admin or owner permissions to the repository, you can use this endpoint to require signed commits on a branch. You must enable branch protection to require signed commits.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-commit-signature-protection>
    */
    pub async fn repos_create_commit_signature_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<types::ProtectedBranchAdminEnforced> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_signatures",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Delete commit signature protection.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * When authenticated with admin or owner permissions to the repository, you can use this endpoint to disable required signed commits on a branch. You must enable branch protection to require signed commits.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-commit-signature-protection>
    */
    pub async fn repos_delete_commit_signature_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_signatures",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get status checks protection.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-status-checks-protection>
    */
    pub async fn repos_get_status_checks_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<types::StatusCheckPolicy> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_status_checks",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Remove status check protection.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#remove-status-check-protection>
    */
    pub async fn repos_remove_status_check_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_status_checks",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update status check protection.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Updating required status checks requires admin or owner permissions to the repository and branch protection to be enabled.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#update-status-check-potection>
    */
    pub async fn repos_update_status_check_protection(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::UpdateStatusCheckProtectionRequest,
    ) -> Result<types::StatusCheckPolicy> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_status_checks",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get all status check contexts.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-all-status-check-contexts>
    */
    pub async fn repos_get_all_status_check_contexts(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<Vec<String>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_status_checks/contexts",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Set status check contexts.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#set-status-check-contexts>
    */
    pub async fn repos_set_status_check_contexts(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::SetStatusCheckContextsRequest,
    ) -> Result<Vec<String>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_status_checks/contexts",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Add status check contexts.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#add-status-check-contexts>
    */
    pub async fn repos_add_status_check_contexts(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::AddStatusCheckContextsRequest,
    ) -> Result<Vec<String>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_status_checks/contexts",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove status check contexts.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#remove-status-check-contexts>
    */
    pub async fn repos_remove_status_check_contexts(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::RemoveStatusCheckContextsRequest,
    ) -> Result<Vec<String>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/required_status_checks/contexts",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get access restrictions.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Lists who has access to this protected branch.
    *
    * **Note**: Users, apps, and teams `restrictions` are only available for organization-owned repositories.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-access-restrictions>
    */
    pub async fn repos_get_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<types::BranchRestrictionPolicy> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete access restrictions.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Disables the ability to restrict who can push to this branch.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-access-restrictions>
    */
    pub async fn repos_delete_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get apps with access to the protected branch.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Lists the GitHub Apps that have push access to this branch. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-apps-with-access-to-the-protected-branch>
    */
    pub async fn repos_get_apps_with_access_to_protected_branch(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<Vec<types::Integration>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/apps",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Set app access restrictions.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Replaces the list of apps that have push access to this branch. This removes all apps that previously had push access and grants push access to the new list of apps. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.
    *
    * | Type    | Description                                                                                                                                                |
    * | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
    * | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    *
    * FROM: <https://docs.github.com/rest/reference/repos#set-app-access-restrictions>
    */
    pub async fn repos_set_app_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::SetAppAccessRestrictionsRequest,
    ) -> Result<Vec<types::Integration>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/apps",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Add app access restrictions.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Grants the specified apps push access for this branch. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.
    *
    * | Type    | Description                                                                                                                                                |
    * | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
    * | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    *
    * FROM: <https://docs.github.com/rest/reference/repos#add-app-access-restrictions>
    */
    pub async fn repos_add_app_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::AddAppAccessRestrictionsRequest,
    ) -> Result<Vec<types::Integration>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/apps",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove app access restrictions.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Removes the ability of an app to push to this branch. Only installed GitHub Apps with `write` access to the `contents` permission can be added as authorized actors on a protected branch.
    *
    * | Type    | Description                                                                                                                                                |
    * | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
    * | `array` | The GitHub Apps that have push access to this branch. Use the app's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    *
    * FROM: <https://docs.github.com/rest/reference/repos#remove-app-access-restrictions>
    */
    pub async fn repos_remove_app_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::RemoveAppAccessRestrictionsRequest,
    ) -> Result<Vec<types::Integration>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/apps",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get teams with access to the protected branch.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Lists the teams who have push access to this branch. The list includes child teams.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-teams-with-access-to-the-protected-branch>
    */
    pub async fn repos_get_teams_with_access_to_protected_branch(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<Vec<types::Team>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/teams",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Set team access restrictions.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Replaces the list of teams that have push access to this branch. This removes all teams that previously had push access and grants push access to the new list of teams. Team restrictions include child teams.
    *
    * | Type    | Description                                                                                                                                |
    * | ------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
    * | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    *
    * FROM: <https://docs.github.com/rest/reference/repos#set-team-access-restrictions>
    */
    pub async fn repos_set_team_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::SetTeamAccessRestrictionsRequest,
    ) -> Result<Vec<types::Team>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/teams",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Add team access restrictions.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Grants the specified teams push access for this branch. You can also give push access to child teams.
    *
    * | Type    | Description                                                                                                                                |
    * | ------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
    * | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    *
    * FROM: <https://docs.github.com/rest/reference/repos#add-team-access-restrictions>
    */
    pub async fn repos_add_team_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::AddTeamAccessRestrictionsRequest,
    ) -> Result<Vec<types::Team>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/teams",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove team access restrictions.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Removes the ability of a team to push to this branch. You can also remove push access for child teams.
    *
    * | Type    | Description                                                                                                                                         |
    * | ------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
    * | `array` | Teams that should no longer have push access. Use the team's `slug`. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    *
    * FROM: <https://docs.github.com/rest/reference/repos#remove-team-access-restrictions>
    */
    pub async fn repos_remove_team_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::RemoveTeamAccessRestrictionsRequest,
    ) -> Result<Vec<types::Team>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/teams",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get users with access to the protected branch.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Lists the people who have push access to this branch.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-users-with-access-to-the-protected-branch>
    */
    pub async fn repos_get_users_with_access_to_protected_branch(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/users",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Set user access restrictions.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Replaces the list of people that have push access to this branch. This removes all people that previously had push access and grants push access to the new list of people.
    *
    * | Type    | Description                                                                                                                   |
    * | ------- | ----------------------------------------------------------------------------------------------------------------------------- |
    * | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    *
    * FROM: <https://docs.github.com/rest/reference/repos#set-user-access-restrictions>
    */
    pub async fn repos_set_user_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::SetUserAccessRestrictionsRequest,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/users",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Add user access restrictions.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Grants the specified people push access for this branch.
    *
    * | Type    | Description                                                                                                                   |
    * | ------- | ----------------------------------------------------------------------------------------------------------------------------- |
    * | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    *
    * FROM: <https://docs.github.com/rest/reference/repos#add-user-access-restrictions>
    */
    pub async fn repos_add_user_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::AddUserAccessRestrictionsRequest,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/users",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove user access restrictions.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Removes the ability of a user to push to this branch.
    *
    * | Type    | Description                                                                                                                                   |
    * | ------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
    * | `array` | Usernames of the people who should no longer have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    *
    * FROM: <https://docs.github.com/rest/reference/repos#remove-user-access-restrictions>
    */
    pub async fn repos_remove_user_access_restrictions(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::RemoveUserAccessRestrictionsRequest,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/repos/{}/{}/branches/{}/protection/restrictions/users",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.delete(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Rename a branch.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/branches/{branch}/rename` endpoint.
    *
    * Renames a branch in a repository.
    *
    * **Note:** Although the API responds immediately, the branch rename process might take some extra time to complete in the background. You won't be able to push to the old branch name while the rename process is in progress. For more information, see "[Renaming a branch](https://docs.github.com/github/administering-a-repository/renaming-a-branch)".
    *
    * The permissions required to use this endpoint depends on whether you are renaming the default branch.
    *
    * To rename a non-default branch:
    *
    * * Users must have push access.
    * * GitHub Apps must have the `contents:write` repository permission.
    *
    * To rename the default branch:
    *
    * * Users must have admin or owner permissions.
    * * GitHub Apps must have the `administration:write` repository permission.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#rename-a-branch>
    */
    pub async fn repos_rename_branch(
        &self,
        owner: &str,
        repo: &str,
        branch: &str,
        body: &types::RenameBranchRequest,
    ) -> Result<types::BranchWithProtection> {
        let url = format!(
            "/repos/{}/{}/branches/{}/rename",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&branch.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Create a check run.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/check-runs` endpoint.
    *
    * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
    *
    * Creates a new check run for a specific commit in a repository. Your GitHub App must have the `checks:write` permission to create check runs.
    *
    * In a check suite, GitHub limits the number of check runs with the same name to 1000. Once these check runs exceed 1000, GitHub will start to automatically delete older check runs.
    *
    * FROM: <https://docs.github.com/rest/reference/checks#create-a-check-run>
    */
    pub async fn checks_create(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateCheckRunRequest,
    ) -> Result<types::CheckRun> {
        let url = format!(
            "/repos/{}/{}/check-runs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a check run.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/check-runs/{check_run_id}` endpoint.
    *
    * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
    *
    * Gets a single check run using its `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
    *
    * FROM: <https://docs.github.com/rest/reference/checks#get-a-check-run>
    */
    pub async fn checks_get(
        &self,
        owner: &str,
        repo: &str,
        check_run_id: i64,
    ) -> Result<types::CheckRun> {
        let url = format!(
            "/repos/{}/{}/check-runs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&check_run_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Update a check run.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/check-runs/{check_run_id}` endpoint.
    *
    * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
    *
    * Updates a check run for a specific commit in a repository. Your GitHub App must have the `checks:write` permission to edit check runs.
    *
    * FROM: <https://docs.github.com/rest/reference/checks#update-a-check-run>
    */
    pub async fn checks_update(
        &self,
        owner: &str,
        repo: &str,
        check_run_id: i64,
        body: &types::UpdateCheckRunRequest,
    ) -> Result<types::CheckRun> {
        let url = format!(
            "/repos/{}/{}/check-runs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&check_run_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List check run annotations.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/check-runs/{check_run_id}/annotations` endpoint.
    *
    * Lists annotations for a check run using the annotation `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get annotations for a check run. OAuth Apps and authenticated users must have the `repo` scope to get annotations for a check run in a private repository.
    *
    * FROM: <https://docs.github.com/rest/reference/checks#list-check-run-annotations>
    */
    pub async fn checks_list_annotations(
        &self,
        owner: &str,
        repo: &str,
        check_run_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::CheckAnnotation>> {
        let url = format!(
            "/repos/{}/{}/check-runs/{}/annotations?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&check_run_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a check suite.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/check-suites` endpoint.
    *
    * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.
    *
    * By default, check suites are automatically created when you create a [check run](https://docs.github.com/rest/reference/checks#check-runs). You only need to use this endpoint for manually creating check suites when you've disabled automatic creation using "[Update repository preferences for check suites](https://docs.github.com/rest/reference/checks#update-repository-preferences-for-check-suites)". Your GitHub App must have the `checks:write` permission to create check suites.
    *
    * FROM: <https://docs.github.com/rest/reference/checks#create-a-check-suite>
    */
    pub async fn checks_create_suite(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateCheckSuiteRequest,
    ) -> Result<types::CheckSuite> {
        let url = format!(
            "/repos/{}/{}/check-suites",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Update repository preferences for check suites.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/check-suites/preferences` endpoint.
    *
    * Changes the default automatic flow when creating check suites. By default, a check suite is automatically created each time code is pushed to a repository. When you disable the automatic creation of check suites, you can manually [Create a check suite](https://docs.github.com/rest/reference/checks#create-a-check-suite). You must have admin permissions in the repository to set preferences for check suites.
    *
    * FROM: <https://docs.github.com/rest/reference/checks#update-repository-preferences-for-check-suites>
    */
    pub async fn checks_set_suites_preferences(
        &self,
        owner: &str,
        repo: &str,
        body: &types::UpdateRepositoryPreferencesCheckSuitesRequest,
    ) -> Result<types::CheckSuitePreference> {
        let url = format!(
            "/repos/{}/{}/check-suites/preferences",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a check suite.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/check-suites/{check_suite_id}` endpoint.
    *
    * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.
    *
    * Gets a single check suite using its `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check suites. OAuth Apps and authenticated users must have the `repo` scope to get check suites in a private repository.
    *
    * FROM: <https://docs.github.com/rest/reference/checks#get-a-check-suite>
    */
    pub async fn checks_get_suite(
        &self,
        owner: &str,
        repo: &str,
        check_suite_id: i64,
    ) -> Result<types::CheckSuite> {
        let url = format!(
            "/repos/{}/{}/check-suites/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&check_suite_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List check runs in a check suite.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs` endpoint.
    *
    * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
    *
    * Lists check runs for a check suite using its `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
    *
    * FROM: <https://docs.github.com/rest/reference/checks#list-check-runs-in-a-check-suite>
    */
    pub async fn checks_list_for_suite(
        &self,
        owner: &str,
        repo: &str,
        check_suite_id: i64,
        check_name: &str,
        status: &str,
        filter: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListCheckRunsinCheckSuiteOkResponse> {
        let url = format!("/repos/{}/{}/check-suites/{}/check-runs?check_name={}&filter={}&page={}&per_page={}&status={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&check_suite_id.to_string()),
check_name.to_string(), filter.to_string(), format!("{}", page), format!("{}", per_page), status.to_string(),         );

        self.get(&url).await
    }

    /**
    * Rerequest a check suite.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest` endpoint.
    *
    * Triggers GitHub to rerequest an existing check suite, without pushing new code to a repository. This endpoint will trigger the [`check_suite` webhook](https://docs.github.com/webhooks/event-payloads/#check_suite) event with the action `rerequested`. When a check suite is `rerequested`, its `status` is reset to `queued` and the `conclusion` is cleared.
    *
    * To rerequest a check suite, your GitHub App must have the `checks:read` permission on a private repository or pull access to a public repository.
    *
    * FROM: <https://docs.github.com/rest/reference/checks#rerequest-a-check-suite>
    */
    pub async fn checks_rerequest_suite(
        &self,
        owner: &str,
        repo: &str,
        check_suite_id: i64,
    ) -> Result<types::PostRerequestCheckSuiteCreatedResponse> {
        let url = format!(
            "/repos/{}/{}/check-suites/{}/rerequest",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&check_suite_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * List code scanning alerts for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/code-scanning/alerts` endpoint.
    *
    * Lists all open code scanning alerts for the default branch (usually `main`
    * or `master`). You must use an access token with the `security_events` scope to use
    * this endpoint. GitHub Apps must have the `security_events` read permission to use
    * this endpoint.
    *
    * The response includes a `most_recent_instance` object.
    * This provides details of the most recent instance of this alert
    * for the default branch or for the specified Git reference
    * (if you used `ref` in the request).
    *
    * FROM: <https://docs.github.com/rest/reference/code-scanning#list-code-scanning-alerts-for-a-repository>
    */
    pub async fn code_scanning_list_alerts_for_repo(
        &self,
        owner: &str,
        repo: &str,
        tool_name: &str,
        tool_guid: &str,
        page: i64,
        per_page: i64,
        ref_: &str,
        state: &str,
    ) -> Result<Vec<types::CodeScanningAlertItems>> {
        let url = format!("/repos/{}/{}/code-scanning/alerts?page={}&per_page={}&ref={}&state={}&tool_guid={}&tool_name={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
format!("{}", page), format!("{}", per_page), ref_, state.to_string(), tool_guid.to_string(), tool_name.to_string(),         );

        self.get_all_pages(&url).await
    }

    /**
    * Get a code scanning alert.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}` endpoint.
    *
    * Gets a single code scanning alert. You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` read permission to use this endpoint.
    *
    * **Deprecation notice**:
    * The instances field is deprecated and will, in future, not be included in the response for this endpoint. The example response reflects this change. The same information can now be retrieved via a GET request to the URL specified by `instances_url`.
    *
    * FROM: <https://docs.github.com/rest/reference/code-scanning#get-a-code-scanning-alert>
    */
    pub async fn code_scanning_get_alert(
        &self,
        owner: &str,
        repo: &str,
        alert_number: &str,
    ) -> Result<types::CodeScanningAlert> {
        let url = format!(
            "/repos/{}/{}/code-scanning/alerts/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&alert_number.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Update a code scanning alert.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}` endpoint.
    *
    * Updates the status of a single code scanning alert. You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` write permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/code-scanning#update-a-code-scanning-alert>
    */
    pub async fn code_scanning_update_alert(
        &self,
        owner: &str,
        repo: &str,
        alert_number: &str,
        body: &types::UpdateCodeScanningAlertRequest,
    ) -> Result<types::CodeScanningAlert> {
        let url = format!(
            "/repos/{}/{}/code-scanning/alerts/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&alert_number.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List instances of a code scanning alert.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances` endpoint.
    *
    * Lists all instances of the specified code scanning alert. You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` read permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/code-scanning#list-instances-of-a-code-scanning-alert>
    */
    pub async fn code_scanning_list_alert_instances(
        &self,
        owner: &str,
        repo: &str,
        alert_number: &str,
        page: i64,
        per_page: i64,
        ref_: &str,
    ) -> Result<Vec<types::CodeScanningAlertInstance>> {
        let url = format!(
            "/repos/{}/{}/code-scanning/alerts/{}/instances?page={}&per_page={}&ref={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&alert_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            ref_,
        );

        self.get_all_pages(&url).await
    }

    /**
    * List code scanning analyses for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/code-scanning/analyses` endpoint.
    *
    * Lists the details of all code scanning analyses for a repository,
    * starting with the most recent.
    * The response is paginated and you can use the `page` and `per_page` parameters
    * to list the analyses you're interested in.
    * By default 30 analyses are listed per page.
    *
    * The `rules_count` field in the response give the number of rules
    * that were run in the analysis.
    * For very old analyses this data is not available,
    * and `0` is returned in this field.
    *
    * You must use an access token with the `security_events` scope to use this endpoint.
    * GitHub Apps must have the `security_events` read permission to use this endpoint.
    *
    * **Deprecation notice**:
    * The `tool_name` field is deprecated and will, in future, not be included in the response for this endpoint. The example response reflects this change. The tool name can now be found inside the `tool` field.
    *
    * FROM: <https://docs.github.com/rest/reference/code-scanning#list-code-scanning-analyses-for-a-repository>
    */
    pub async fn code_scanning_list_recent_analyses(
        &self,
        owner: &str,
        repo: &str,
        tool_name: &str,
        tool_guid: &str,
        page: i64,
        per_page: i64,
        ref_: &str,
        sarif_id: &str,
    ) -> Result<Vec<types::CodeScanningAnalysis>> {
        let url = format!("/repos/{}/{}/code-scanning/analyses?page={}&per_page={}&ref={}&sarif_id={}&tool_guid={}&tool_name={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
format!("{}", page), format!("{}", per_page), ref_, sarif_id.to_string(), tool_guid.to_string(), tool_name.to_string(),         );

        self.get_all_pages(&url).await
    }

    /**
    * Get a code scanning analysis for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}` endpoint.
    *
    * Gets a specified code scanning analysis for a repository.
    * You must use an access token with the `security_events` scope to use this endpoint.
    * GitHub Apps must have the `security_events` read permission to use this endpoint.
    *
    * The default JSON response contains fields that describe the analysis.
    * This includes the Git reference and commit SHA to which the analysis relates,
    * the datetime of the analysis, the name of the code scanning tool,
    * and the number of alerts.
    *
    * The `rules_count` field in the default response give the number of rules
    * that were run in the analysis.
    * For very old analyses this data is not available,
    * and `0` is returned in this field.
    *
    * If you use the Accept header `application/sarif+json`,
    * the response contains the analysis data that was uploaded.
    * This is formatted as
    * [SARIF version 2.1.0](https://docs.oasis-open.org/sarif/sarif/v2.1.0/cs01/sarif-v2.1.0-cs01.html).
    *
    * **Deprecation notice**:
    * The `tool_name` field is deprecated and will, in future, not be included in the response for this endpoint. The example response reflects this change. The tool name can now be found inside the `tool` field.
    *
    * FROM: <https://docs.github.com/rest/reference/code-scanning#get-a-code-scanning-analysis-for-a-repository>
    */
    pub async fn code_scanning_get_analysis(
        &self,
        owner: &str,
        repo: &str,
        analysis_id: i64,
    ) -> Result<types::CodeScanningAnalysis> {
        let url = format!(
            "/repos/{}/{}/code-scanning/analyses/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&analysis_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a code scanning analysis from a repository.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}` endpoint.
    *
    * Deletes a specified code scanning analysis from a repository. For
    * private repositories, you must use an access token with the `repo` scope. For public repositories,
    * you must use an access token with `public_repo` and `repo:security_events` scopes.
    * GitHub Apps must have the `security_events` write permission to use this endpoint.
    *
    * You can delete one analysis at a time.
    * To delete a series of analyses, start with the most recent analysis and work backwards.
    * Conceptually, the process is similar to the undo function in a text editor.
    *
    * When you list the analyses for a repository,
    * one or more will be identified as deletable in the response:
    *
    * ```
    * "deletable": true
    * ```
    *
    * An analysis is deletable when it's the most recent in a set of analyses.
    * Typically, a repository will have multiple sets of analyses
    * for each enabled code scanning tool,
    * where a set is determined by a unique combination of analysis values:
    *
    * * `ref`
    * * `tool`
    * * `analysis_key`
    * * `environment`
    *
    * If you attempt to delete an analysis that is not the most recent in a set,
    * you'll get a 400 response with the message:
    *
    * ```
    * Analysis specified is not deletable.
    * ```
    *
    * The response from a successful `DELETE` operation provides you with
    * two alternative URLs for deleting the next analysis in the set
    * (see the example default response below).
    * Use the `next_analysis_url` URL if you want to avoid accidentally deleting the final analysis
    * in the set. This is a useful option if you want to preserve at least one analysis
    * for the specified tool in your repository.
    * Use the `confirm_delete_url` URL if you are content to remove all analyses for a tool.
    * When you delete the last analysis in a set the value of `next_analysis_url` and `confirm_delete_url`
    * in the 200 response is `null`.
    *
    * As an example of the deletion process,
    * let's imagine that you added a workflow that configured a particular code scanning tool
    * to analyze the code in a repository. This tool has added 15 analyses:
    * 10 on the default branch, and another 5 on a topic branch.
    * You therefore have two separate sets of analyses for this tool.
    * You've now decided that you want to remove all of the analyses for the tool.
    * To do this you must make 15 separate deletion requests.
    * To start, you must find the deletable analysis for one of the sets,
    * step through deleting the analyses in that set,
    * and then repeat the process for the second set.
    * The procedure therefore consists of a nested loop:
    *
    * **Outer loop**:
    * * List the analyses for the repository, filtered by tool.
    * * Parse this list to find a deletable analysis. If found:
    *
    *   **Inner loop**:
    *   * Delete the identified analysis.
    *   * Parse the response for the value of `confirm_delete_url` and, if found, use this in the next iteration.
    *
    * The above process assumes that you want to remove all trace of the tool's analyses from the GitHub user interface, for the specified repository, and it therefore uses the `confirm_delete_url` value. Alternatively, you could use the `next_analysis_url` value, which would leave the last analysis in each set undeleted to avoid removing a tool's analysis entirely.
    *
    * FROM: <https://docs.github.com/rest/reference/code-scanning#delete-a-code-scanning-analysis-from-a-repository>
    */
    pub async fn code_scanning_delete_analysis(
        &self,
        owner: &str,
        repo: &str,
        analysis_id: i64,
        confirm_delete: &str,
    ) -> Result<types::CodeScanningAnalysisDeletion> {
        let url = format!(
            "/repos/{}/{}/code-scanning/analyses/{}?confirm_delete={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&analysis_id.to_string()),
            confirm_delete.to_string(),
        );

        self.delete(&url, None).await
    }

    /**
    * Upload an analysis as SARIF data.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/code-scanning/sarifs` endpoint.
    *
    * Uploads SARIF data containing the results of a code scanning analysis to make the results available in a repository. You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` write permission to use this endpoint.
    *
    * There are two places where you can upload code scanning results.
    *  - If you upload to a pull request, for example `--ref refs/pull/42/merge` or `--ref refs/pull/42/head`, then the results appear as alerts in a pull request check. For more information, see "[Triaging code scanning alerts in pull requests](/code-security/secure-coding/triaging-code-scanning-alerts-in-pull-requests)."
    *  - If you upload to a branch, for example `--ref refs/heads/my-branch`, then the results appear in the **Security** tab for your repository. For more information, see "[Managing code scanning alerts for your repository](/code-security/secure-coding/managing-code-scanning-alerts-for-your-repository#viewing-the-alerts-for-a-repository)."
    *
    * You must compress the SARIF-formatted analysis data that you want to upload, using `gzip`, and then encode it as a Base64 format string. For example:
    *
    * ```
    * gzip -c analysis-data.sarif | base64 -w0
    * ```
    *
    * SARIF upload supports a maximum of 5000 results per analysis run. Any results over this limit are ignored and any SARIF uploads with more than 25,000 results are rejected. Typically, but not necessarily, a SARIF file contains a single run of a single tool. If a code scanning tool generates too many results, you should update the analysis configuration to run only the most important rules or queries.
    *
    * The `202 Accepted`, response includes an `id` value.
    * You can use this ID to check the status of the upload by using this for the `/sarifs/{sarif_id}` endpoint.
    * For more information, see "[Get information about a SARIF upload](/rest/reference/code-scanning#get-information-about-a-sarif-upload)."
    *
    * FROM: <https://docs.github.com/rest/reference/code-scanning#upload-a-sarif-file>
    */
    pub async fn code_scanning_upload_sarif(
        &self,
        owner: &str,
        repo: &str,
        body: &types::UploadAnalysisasSarifDataRequest,
    ) -> Result<types::CodeScanningSarifsReceipt> {
        let url = format!(
            "/repos/{}/{}/code-scanning/sarifs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get information about a SARIF upload.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}` endpoint.
    *
    * Gets information about a SARIF upload, including the status and the URL of the analysis that was uploaded so that you can retrieve details of the analysis. For more information, see "[Get a code scanning analysis for a repository](/rest/reference/code-scanning#get-a-code-scanning-analysis-for-a-repository)." You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` read permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/code-scanning#list-recent-code-scanning-analyses-for-a-repository>
    */
    pub async fn code_scanning_get_sarif(
        &self,
        owner: &str,
        repo: &str,
        sarif_id: &str,
    ) -> Result<types::CodeScanningSarifsStatus> {
        let url = format!(
            "/repos/{}/{}/code-scanning/sarifs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&sarif_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List repository collaborators.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/collaborators` endpoint.
    *
    * For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
    *
    * Team members will include the members of child teams.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-repository-collaborators>
    */
    pub async fn repos_list_collaborators(
        &self,
        owner: &str,
        repo: &str,
        affiliation: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Collaborator>> {
        let url = format!(
            "/repos/{}/{}/collaborators?affiliation={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            affiliation.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Check if a user is a repository collaborator.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/collaborators/{username}` endpoint.
    *
    * For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
    *
    * Team members will include the members of child teams.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#check-if-a-user-is-a-repository-collaborator>
    */
    pub async fn repos_check_collaborator(
        &self,
        owner: &str,
        repo: &str,
        username: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/collaborators/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Add a repository collaborator.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/collaborators/{username}` endpoint.
    *
    * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
    *
    * For more information the permission levels, see "[Repository permission levels for an organization](https://help.github.com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
    *
    * Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
    *
    * The invitee will receive a notification that they have been invited to the repository, which they must accept or decline. They may do this via the notifications page, the email they receive, or by using the [repository invitations API endpoints](https://docs.github.com/rest/reference/repos#invitations).
    *
    * **Rate limits**
    *
    * To prevent abuse, you are limited to sending 50 invitations to a repository per 24 hour period. Note there is no limit if you are inviting organization members to an organization repository.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#add-a-repository-collaborator>
    */
    pub async fn repos_add_collaborator(
        &self,
        owner: &str,
        repo: &str,
        username: &str,
        body: &types::AddRepositoryCollaboratorRequest,
    ) -> Result<types::RepositoryInvitation> {
        let url = format!(
            "/repos/{}/{}/collaborators/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove a repository collaborator.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/collaborators/{username}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#remove-a-repository-collaborator>
    */
    pub async fn repos_remove_collaborator(
        &self,
        owner: &str,
        repo: &str,
        username: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/collaborators/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get repository permissions for a user.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/collaborators/{username}/permission` endpoint.
    *
    * Checks the repository permission of a collaborator. The possible repository permissions are `admin`, `write`, `read`, and `none`.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-repository-permissions-for-a-user>
    */
    pub async fn repos_get_collaborator_permission_level(
        &self,
        owner: &str,
        repo: &str,
        username: &str,
    ) -> Result<types::RepositoryCollaboratorPermission> {
        let url = format!(
            "/repos/{}/{}/collaborators/{}/permission",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List commit comments for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/comments` endpoint.
    *
    * Commit Comments use [these custom media types](https://docs.github.com/rest/reference/repos#custom-media-types). You can read more about the use of media types in the API [here](https://docs.github.com/rest/overview/media-types/).
    *
    * Comments are ordered by ascending ID.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-commit-comments-for-a-repository>
    */
    pub async fn repos_list_commit_comments_for_repo(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::CommitComment>> {
        let url = format!(
            "/repos/{}/{}/comments?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a commit comment.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/comments/{comment_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-commit-comment>
    */
    pub async fn repos_get_commit_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
    ) -> Result<types::CommitComment> {
        let url = format!(
            "/repos/{}/{}/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a commit comment.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/comments/{comment_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-a-commit-comment>
    */
    pub async fn repos_delete_commit_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a commit comment.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/comments/{comment_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#update-a-commit-comment>
    */
    pub async fn repos_update_commit_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        body: &types::UpdateCommitCommentRequest,
    ) -> Result<types::CommitComment> {
        let url = format!(
            "/repos/{}/{}/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List reactions for a commit comment.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/comments/{comment_id}/reactions` endpoint.
    *
    * List the reactions to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#list-reactions-for-a-commit-comment>
    */
    pub async fn reactions_list_for_commit_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        content: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/repos/{}/{}/comments/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
            content.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create reaction for a commit comment.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/comments/{comment_id}/reactions` endpoint.
    *
    * Create a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments). A response with an HTTP `200` status means that you already added the reaction type to this commit comment.
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#create-reaction-for-a-commit-comment>
    */
    pub async fn reactions_create_for_commit_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        body: &types::CreateReactionCommitCommentRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/repos/{}/{}/comments/{}/reactions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete a commit comment reaction.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}` endpoint.
    *
    * **Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.
    *
    * Delete a reaction to a [commit comment](https://docs.github.com/rest/reference/repos#comments).
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#delete-a-commit-comment-reaction>
    */
    pub async fn reactions_delete_for_commit_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        reaction_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/comments/{}/reactions/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
            progenitor_support::encode_path(&reaction_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List commits.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/commits` endpoint.
    *
    * **Signature verification object**
    *
    * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
    *
    * | Name | Type | Description |
    * | ---- | ---- | ----------- |
    * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    * | `signature` | `string` | The signature that was extracted from the commit. |
    * | `payload` | `string` | The value that was signed. |
    *
    * These are the possible values for `reason` in the `verification` object:
    *
    * | Value | Description |
    * | ----- | ----------- |
    * | `expired_key` | The key that made the signature is expired. |
    * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    * | `gpgverify_error` | There was an error communicating with the signature verification service. |
    * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    * | `unsigned` | The object does not include a signature. |
    * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    * | `no_user` | No user was associated with the `committer` email address in the commit. |
    * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
    * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    * | `malformed_signature` | There was an error parsing the signature. |
    * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-commits>
    */
    pub async fn repos_list_commits(
        &self,
        owner: &str,
        repo: &str,
        sha: &str,
        path: &str,
        author: &str,
        since: DateTime<Utc>,
        until: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Commit>> {
        let url = format!(
            "/repos/{}/{}/commits?author={}&page={}&path={}&per_page={}&sha={}&since={}&until={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            author.to_string(),
            format!("{}", page),
            path.to_string(),
            format!("{}", per_page),
            sha.to_string(),
            since.to_rfc3339(),
            until.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List branches for HEAD commit.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head` endpoint.
    *
    * Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-branches-for-head-commit>
    */
    pub async fn repos_list_branches_for_head_commit(
        &self,
        owner: &str,
        repo: &str,
        commit_sha: &str,
    ) -> Result<Vec<types::BranchShort>> {
        let url = format!(
            "/repos/{}/{}/commits/{}/branches-where-head",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&commit_sha.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List commit comments.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{commit_sha}/comments` endpoint.
    *
    * Use the `:commit_sha` to specify the commit that will have its comments listed.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-commit-comments>
    */
    pub async fn repos_list_comments_for_commit(
        &self,
        owner: &str,
        repo: &str,
        commit_sha: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::CommitComment>> {
        let url = format!(
            "/repos/{}/{}/commits/{}/comments?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&commit_sha.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a commit comment.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/commits/{commit_sha}/comments` endpoint.
    *
    * Create a comment for a commit using its `:commit_sha`.
    *
    * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-a-commit-comment>
    */
    pub async fn repos_create_commit_comment(
        &self,
        owner: &str,
        repo: &str,
        commit_sha: &str,
        body: &types::CreateCommitCommentRequest,
    ) -> Result<types::CommitComment> {
        let url = format!(
            "/repos/{}/{}/commits/{}/comments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&commit_sha.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List pull requests associated with a commit.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{commit_sha}/pulls` endpoint.
    *
    * Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, additionally returns open pull requests associated with the commit. The results may include open and closed pull requests. Additional preview headers may be required to see certain details for associated pull requests, such as whether a pull request is in a draft state. For more information about previews that might affect this endpoint, see the [List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests) endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-pull-requests-associated-with-a-commit>
    */
    pub async fn repos_list_pull_requests_associated_with_commit(
        &self,
        owner: &str,
        repo: &str,
        commit_sha: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::PullRequestSimple>> {
        let url = format!(
            "/repos/{}/{}/commits/{}/pulls?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&commit_sha.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a commit.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{ref}` endpoint.
    *
    * Returns the contents of a single commit reference. You must have `read` access for the repository to use this endpoint.
    *
    * **Note:** If there are more than 300 files in the commit diff, the response will include pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains the static commit information, and the only changes are to the file listing.
    *
    * You can pass the appropriate [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to  fetch `diff` and `patch` formats. Diffs with binary data will have no `patch` property.
    *
    * To return only the SHA-1 hash of the commit reference, you can provide the `sha` custom [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) in the `Accept` header. You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.
    *
    * **Signature verification object**
    *
    * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
    *
    * | Name | Type | Description |
    * | ---- | ---- | ----------- |
    * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    * | `signature` | `string` | The signature that was extracted from the commit. |
    * | `payload` | `string` | The value that was signed. |
    *
    * These are the possible values for `reason` in the `verification` object:
    *
    * | Value | Description |
    * | ----- | ----------- |
    * | `expired_key` | The key that made the signature is expired. |
    * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    * | `gpgverify_error` | There was an error communicating with the signature verification service. |
    * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    * | `unsigned` | The object does not include a signature. |
    * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    * | `no_user` | No user was associated with the `committer` email address in the commit. |
    * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
    * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    * | `malformed_signature` | There was an error parsing the signature. |
    * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-commit>
    */
    pub async fn repos_get_commit(
        &self,
        owner: &str,
        repo: &str,
        page: i64,
        per_page: i64,
        ref_: &str,
    ) -> Result<types::Commit> {
        let url = format!(
            "/repos/{}/{}/commits/{}?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * List check runs for a Git reference.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{ref}/check-runs` endpoint.
    *
    * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
    *
    * Lists check runs for a commit ref. The `ref` can be a SHA, branch name, or a tag name. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
    *
    * FROM: <https://docs.github.com/rest/reference/checks#list-check-runs-for-a-git-reference>
    */
    pub async fn checks_list_for_ref(
        &self,
        owner: &str,
        repo: &str,
        ref_: &str,
        check_name: &str,
        status: &str,
        filter: &str,
        per_page: i64,
        page: i64,
        app_id: i64,
    ) -> Result<types::GetListCheckRunsGitReferenceOkResponse> {
        let url = format!("/repos/{}/{}/commits/{}/check-runs?app_id={}&check_name={}&filter={}&page={}&per_page={}&status={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
format!("{}", app_id), check_name.to_string(), filter.to_string(), format!("{}", page), format!("{}", per_page), status.to_string(),         );

        self.get(&url).await
    }

    /**
    * List check suites for a Git reference.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{ref}/check-suites` endpoint.
    *
    * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.
    *
    * Lists check suites for a commit `ref`. The `ref` can be a SHA, branch name, or a tag name. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to list check suites. OAuth Apps and authenticated users must have the `repo` scope to get check suites in a private repository.
    *
    * FROM: <https://docs.github.com/rest/reference/checks#list-check-suites-for-a-git-reference>
    */
    pub async fn checks_list_suites_for_ref(
        &self,
        owner: &str,
        repo: &str,
        ref_: &str,
        app_id: i64,
        check_name: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListCheckSuitesGitReferenceOkResponse> {
        let url = format!(
            "/repos/{}/{}/commits/{}/check-suites?app_id={}&check_name={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
            format!("{}", app_id),
            check_name.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Get the combined status for a specific reference.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{ref}/status` endpoint.
    *
    * Users with pull access in a repository can access a combined view of commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name.
    *
    * The most recent status for each context is returned, up to 100. This field [paginates](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination) if there are over 100 contexts.
    *
    * Additionally, a combined `state` is returned. The `state` is one of:
    *
    * *   **failure** if any of the contexts report as `error` or `failure`
    * *   **pending** if there are no statuses or a context is `pending`
    * *   **success** if the latest status for all contexts is `success`
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-the-combined-status-for-a-specific-reference>
    */
    pub async fn repos_get_combined_status_for_ref(
        &self,
        owner: &str,
        repo: &str,
        ref_: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::CombinedCommitStatus> {
        let url = format!(
            "/repos/{}/{}/commits/{}/status?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * List commit statuses for a reference.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/commits/{ref}/statuses` endpoint.
    *
    * Users with pull access in a repository can view commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first status in the list will be the latest one.
    *
    * This resource is also available via a legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-commit-statuses-for-a-reference>
    */
    pub async fn repos_list_commit_statuses_for_ref(
        &self,
        owner: &str,
        repo: &str,
        ref_: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Status>> {
        let url = format!(
            "/repos/{}/{}/commits/{}/statuses?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get the code of conduct for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/community/code_of_conduct` endpoint.
    *
    * Returns the contents of the repository's code of conduct file, if one is detected.
    *
    * A code of conduct is detected if there is a file named `CODE_OF_CONDUCT` in the root directory of the repository. GitHub detects which code of conduct it is using fuzzy matching.
    *
    * FROM: <https://docs.github.com/rest/reference/codes-of-conduct#get-the-code-of-conduct-for-a-repository>
    */
    pub async fn codes_of_conduct_get_for_repo(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::CodeofConduct> {
        let url = format!(
            "/repos/{}/{}/community/code_of_conduct",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get community profile metrics.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/community/profile` endpoint.
    *
    * This endpoint will return all community profile metrics, including an
    * overall health score, repository description, the presence of documentation, detected
    * code of conduct, detected license, and the presence of ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE,
    * README, and CONTRIBUTING files.
    *
    * The `health_percentage` score is defined as a percentage of how many of
    * these four documents are present: README, CONTRIBUTING, LICENSE, and
    * CODE_OF_CONDUCT. For example, if all four documents are present, then
    * the `health_percentage` is `100`. If only one is present, then the
    * `health_percentage` is `25`.
    *
    * `content_reports_enabled` is only returned for organization-owned repositories.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-community-profile-metrics>
    */
    pub async fn repos_get_community_profile_metrics(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::CommunityProfile> {
        let url = format!(
            "/repos/{}/{}/community/profile",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Compare two commits.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/compare/{basehead}` endpoint.
    *
    * The `basehead` param is comprised of two parts: `base` and `head`. Both must be branch names in `repo`. To compare branches across other repositories in the same network as `repo`, use the format `<USERNAME>:branch`.
    *
    * The response from the API is equivalent to running the `git log base..head` command; however, commits are returned in chronological order. Pass the appropriate [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.
    *
    * The response also includes details on the files that were changed between the two commits. This includes the status of the change (for example, if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.
    *
    * **Working with large comparisons**
    *
    * To process a response with a large number of commits, you can use (`per_page` or `page`) to paginate the results. When using paging, the list of changed files is only returned with page 1, but includes all changed files for the entire comparison. For more information on working with pagination, see "[Traversing with pagination](/rest/guides/traversing-with-pagination)."
    *
    * When calling this API without any paging parameters (`per_page` or `page`), the returned list is limited to 250 commits and the last commit in the list is the most recent of the entire comparison. When a paging parameter is specified, the first commit in the returned list of each page is the earliest.
    *
    * **Signature verification object**
    *
    * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
    *
    * | Name | Type | Description |
    * | ---- | ---- | ----------- |
    * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    * | `signature` | `string` | The signature that was extracted from the commit. |
    * | `payload` | `string` | The value that was signed. |
    *
    * These are the possible values for `reason` in the `verification` object:
    *
    * | Value | Description |
    * | ----- | ----------- |
    * | `expired_key` | The key that made the signature is expired. |
    * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    * | `gpgverify_error` | There was an error communicating with the signature verification service. |
    * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    * | `unsigned` | The object does not include a signature. |
    * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    * | `no_user` | No user was associated with the `committer` email address in the commit. |
    * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
    * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    * | `malformed_signature` | There was an error parsing the signature. |
    * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    *
    * FROM: <https://docs.github.com/rest/reference/repos#compare-two-commits>
    */
    pub async fn repos_compare_commits(
        &self,
        owner: &str,
        repo: &str,
        page: i64,
        per_page: i64,
        basehead: &str,
    ) -> Result<types::CommitComparison> {
        let url = format!(
            "/repos/{}/{}/compare/{}?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&basehead.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Create a content attachment.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/content_references/{content_reference_id}/attachments` endpoint.
    *
    * Creates an attachment under a content reference URL in the body or comment of an issue or pull request. Use the `id` and `repository` `full_name` of the content reference from the [`content_reference` event](https://docs.github.com/webhooks/event-payloads/#content_reference) to create an attachment.
    *
    * The app must create a content attachment within six hours of the content reference URL being posted. See "[Using content attachments](https://docs.github.com/apps/using-content-attachments/)" for details about content attachments.
    *
    * You must use an [installation access token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#create-a-content-attachment>
    */
    pub async fn apps_create_content_attachment(
        &self,
        owner: &str,
        repo: &str,
        content_reference_id: i64,
        body: &types::CreateContentAttachmentRequest,
    ) -> Result<types::ContentReferenceAttachment> {
        let url = format!(
            "/repos/{}/{}/content_references/{}/attachments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&content_reference_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get repository content.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/contents/{path}` endpoint.
    *
    * Gets the contents of a file or directory in a repository. Specify the file path or directory in `:path`. If you omit
    * `:path`, you will receive the contents of the repository's root directory. See the description below regarding what the API response includes for directories.
    *
    * Files and symlinks support [a custom media type](https://docs.github.com/rest/reference/repos#custom-media-types) for
    * retrieving the raw content or rendered HTML (when supported). All content types support [a custom media
    * type](https://docs.github.com/rest/reference/repos#custom-media-types) to ensure the content is returned in a consistent
    * object format.
    *
    * **Note**:
    * *   To get a repository's contents recursively, you can [recursively get the tree](https://docs.github.com/rest/reference/git#trees).
    * *   This API has an upper limit of 1,000 files for a directory. If you need to retrieve more files, use the [Git Trees
    * API](https://docs.github.com/rest/reference/git#get-a-tree).
    * *   This API supports files up to 1 megabyte in size.
    *
    * #### If the content is a directory
    * The response will be an array of objects, one object for each item in the directory.
    * When listing the contents of a directory, submodules have their "type" specified as "file". Logically, the value
    * _should_ be "submodule". This behavior exists in API v3 [for backwards compatibility purposes](https://git.io/v1YCW).
    * In the next major version of the API, the type will be returned as "submodule".
    *
    * #### If the content is a symlink
    * If the requested `:path` points to a symlink, and the symlink's target is a normal file in the repository, then the
    * API responds with the content of the file (in the format shown in the example. Otherwise, the API responds with an object
    * describing the symlink itself.
    *
    * #### If the content is a submodule
    * The `submodule_git_url` identifies the location of the submodule repository, and the `sha` identifies a specific
    * commit within the submodule repository. Git uses the given URL when cloning the submodule repository, and checks out
    * the submodule at that specific commit.
    *
    * If the submodule repository is not hosted on github.com, the Git URLs (`git_url` and `_links["git"]`) and the
    * github.com URLs (`html_url` and `_links["html"]`) will have null values.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-repository-content>
    */
    pub async fn repos_get_content(
        &self,
        owner: &str,
        repo: &str,
        path: &str,
        ref_: &str,
    ) -> Result<types::GetRepositoryContentOkResponse> {
        let url = format!(
            "/repos/{}/{}/contents/{}?ref={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&path.to_string()),
            ref_,
        );

        self.get(&url).await
    }

    /**
    * Create or update file contents.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/contents/{path}` endpoint.
    *
    * Creates a new file or replaces an existing file in a repository.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-or-update-file-contents>
    */
    pub async fn repos_create_or_update_file_contents(
        &self,
        owner: &str,
        repo: &str,
        path: &str,
        body: &types::CreateUpdateFileContentsRequest,
    ) -> Result<types::FileCommit> {
        let url = format!(
            "/repos/{}/{}/contents/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&path.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete a file.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/contents/{path}` endpoint.
    *
    * Deletes a file in a repository.
    *
    * You can provide an additional `committer` parameter, which is an object containing information about the committer. Or, you can provide an `author` parameter, which is an object containing information about the author.
    *
    * The `author` section is optional and is filled in with the `committer` information if omitted. If the `committer` information is omitted, the authenticated user's information is used.
    *
    * You must provide values for both `name` and `email`, whether you choose to use `author` or `committer`. Otherwise, you'll receive a `422` status code.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-a-file>
    */
    pub async fn repos_delete_file(
        &self,
        owner: &str,
        repo: &str,
        path: &str,
        body: &types::DeleteFileRequest,
    ) -> Result<types::FileCommit> {
        let url = format!(
            "/repos/{}/{}/contents/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&path.to_string()),
        );

        self.delete(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List repository contributors.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/contributors` endpoint.
    *
    * Lists contributors to the specified repository and sorts them by the number of commits per contributor in descending order. This endpoint may return information that is a few hours old because the GitHub REST API v3 caches contributor data to improve performance.
    *
    * GitHub identifies contributors by author email address. This endpoint groups contribution counts by GitHub user, which includes all associated email addresses. To improve performance, only the first 500 author email addresses in the repository link to GitHub users. The rest will appear as anonymous contributors without associated GitHub user information.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-repository-contributors>
    */
    pub async fn repos_list_contributors(
        &self,
        owner: &str,
        repo: &str,
        anon: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Contributor>> {
        let url = format!(
            "/repos/{}/{}/contributors?anon={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            anon.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List deployments.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/deployments` endpoint.
    *
    * Simple filtering of deployments is available via query parameters:
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-deployments>
    */
    pub async fn repos_list_deployments(
        &self,
        owner: &str,
        repo: &str,
        sha: &str,
        ref_: &str,
        task: &str,
        environment: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Deployment>> {
        let url = format!(
            "/repos/{}/{}/deployments?environment={}&page={}&per_page={}&ref={}&sha={}&task={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            environment.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            ref_,
            sha.to_string(),
            task.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a deployment.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/deployments` endpoint.
    *
    * Deployments offer a few configurable parameters with certain defaults.
    *
    * The `ref` parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and verify them
    * before we merge a pull request.
    *
    * The `environment` parameter allows deployments to be issued to different runtime environments. Teams often have
    * multiple environments for verifying their applications, such as `production`, `staging`, and `qa`. This parameter
    * makes it easier to track which environments have requested deployments. The default environment is `production`.
    *
    * The `auto_merge` parameter is used to ensure that the requested ref is not behind the repository's default branch. If
    * the ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If the merge succeeds,
    * the API will return a successful merge commit. If merge conflicts prevent the merge from succeeding, the API will
    * return a failure response.
    *
    * By default, [commit statuses](https://docs.github.com/rest/reference/repos#statuses) for every submitted context must be in a `success`
    * state. The `required_contexts` parameter allows you to specify a subset of contexts that must be `success`, or to
    * specify contexts that have not yet been submitted. You are not required to use commit statuses to deploy. If you do
    * not require any contexts or create any commit statuses, the deployment will always succeed.
    *
    * The `payload` parameter is available for any extra information that a deployment system might need. It is a JSON text
    * field that will be passed on when a deployment event is dispatched.
    *
    * The `task` parameter is used by the deployment system to allow different execution paths. In the web world this might
    * be `deploy:migrations` to run schema changes on the system. In the compiled world this could be a flag to compile an
    * application with debugging enabled.
    *
    * Users with `repo` or `repo_deployment` scopes can create a deployment for a given ref.
    *
    * #### Merged branch response
    * You will see this response when GitHub automatically merges the base branch into the topic branch instead of creating
    * a deployment. This auto-merge happens when:
    * *   Auto-merge option is enabled in the repository
    * *   Topic branch does not include the latest changes on the base branch, which is `master` in the response example
    * *   There are no merge conflicts
    *
    * If there are no new commits in the base branch, a new request to create a deployment should give a successful
    * response.
    *
    * #### Merge conflict response
    * This error happens when the `auto_merge` option is enabled and when the default branch (in this case `master`), can't
    * be merged into the branch that's being deployed (in this case `topic-branch`), due to merge conflicts.
    *
    * #### Failed commit status checks
    * This error happens when the `required_contexts` parameter indicates that one or more contexts need to have a `success`
    * status for the commit to be deployed, but one or more of the required contexts do not have a state of `success`.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-a-deployment>
    */
    pub async fn repos_create_deployment(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateDeploymentRequest,
    ) -> Result<types::Deployment> {
        let url = format!(
            "/repos/{}/{}/deployments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a deployment.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/deployments/{deployment_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-deployment>
    */
    pub async fn repos_get_deployment(
        &self,
        owner: &str,
        repo: &str,
        deployment_id: i64,
    ) -> Result<types::Deployment> {
        let url = format!(
            "/repos/{}/{}/deployments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&deployment_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a deployment.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/deployments/{deployment_id}` endpoint.
    *
    * To ensure there can always be an active deployment, you can only delete an _inactive_ deployment. Anyone with `repo` or `repo_deployment` scopes can delete an inactive deployment.
    *
    * To set a deployment as inactive, you must:
    *
    * *   Create a new deployment that is active so that the system has a record of the current state, then delete the previously active deployment.
    * *   Mark the active deployment as inactive by adding any non-successful deployment status.
    *
    * For more information, see "[Create a deployment](https://docs.github.com/rest/reference/repos/#create-a-deployment)" and "[Create a deployment status](https://docs.github.com/rest/reference/repos#create-a-deployment-status)."
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-a-deployment>
    */
    pub async fn repos_delete_deployment(
        &self,
        owner: &str,
        repo: &str,
        deployment_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/deployments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&deployment_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List deployment statuses.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/deployments/{deployment_id}/statuses` endpoint.
    *
    * Users with pull access can view deployment statuses for a deployment:
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-deployment-statuses>
    */
    pub async fn repos_list_deployment_statuses(
        &self,
        owner: &str,
        repo: &str,
        deployment_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::DeploymentStatus>> {
        let url = format!(
            "/repos/{}/{}/deployments/{}/statuses?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&deployment_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a deployment status.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/deployments/{deployment_id}/statuses` endpoint.
    *
    * Users with `push` access can create deployment statuses for a given deployment.
    *
    * GitHub Apps require `read & write` access to "Deployments" and `read-only` access to "Repo contents" (for private repos). OAuth Apps require the `repo_deployment` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-a-deployment-status>
    */
    pub async fn repos_create_deployment_status(
        &self,
        owner: &str,
        repo: &str,
        deployment_id: i64,
        body: &types::CreateDeploymentStatusRequest,
    ) -> Result<types::DeploymentStatus> {
        let url = format!(
            "/repos/{}/{}/deployments/{}/statuses",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&deployment_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a deployment status.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}` endpoint.
    *
    * Users with pull access can view a deployment status for a deployment:
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-deployment-status>
    */
    pub async fn repos_get_deployment_status(
        &self,
        owner: &str,
        repo: &str,
        deployment_id: i64,
        status_id: i64,
    ) -> Result<types::DeploymentStatus> {
        let url = format!(
            "/repos/{}/{}/deployments/{}/statuses/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&deployment_id.to_string()),
            progenitor_support::encode_path(&status_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Create a repository dispatch event.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/dispatches` endpoint.
    *
    * You can use this endpoint to trigger a webhook event called `repository_dispatch` when you want activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook. You must configure your GitHub Actions workflow or GitHub App to run when the `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."
    *
    * The `client_payload` parameter is available for any extra information that your workflow might need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched. For example, the `client_payload` can include a message that a user would like to send using a GitHub Actions workflow. Or the `client_payload` can be used as a test to debug your workflow.
    *
    * This endpoint requires write access to the repository by providing either:
    *
    *   - Personal access tokens with `repo` scope. For more information, see "[Creating a personal access token for the command line](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line)" in the GitHub Help documentation.
    *   - GitHub Apps with both `metadata:read` and `contents:read&write` permissions.
    *
    * This input example shows how you can use the `client_payload` as a test to debug your workflow.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-a-repository-dispatch-event>
    */
    pub async fn repos_create_dispatch_event(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateRepositoryDispatchEventRequest,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/dispatches",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get all environments.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/environments` endpoint.
    *
    * Get all environments for a repository.
    *
    * Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-all-environments>
    */
    pub async fn repos_get_all_environments(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::GetAllEnvironmentsOkResponse> {
        let url = format!(
            "/repos/{}/{}/environments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get an environment.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/environments/{environment_name}` endpoint.
    *
    * Anyone with read access to the repository can use this endpoint. If the repository is private, you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-an-environment>
    */
    pub async fn repos_get_environment(
        &self,
        owner: &str,
        repo: &str,
        environment_name: &str,
    ) -> Result<types::Environment> {
        let url = format!(
            "/repos/{}/{}/environments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Create or update an environment.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/environments/{environment_name}` endpoint.
    *
    * Create or update an environment with protection rules, such as required reviewers. For more information about environment protection rules, see "[Environments](/actions/reference/environments#environment-protection-rules)."
    *
    * **Note:** Although you can use this operation to specify that only branches that match specified name patterns can deploy to this environment, you must use the UI to set the name patterns. For more information, see "[Environments](/actions/reference/environments#deployment-branches)."
    *
    * **Note:** To create or update secrets for an environment, see "[Secrets](/rest/reference/actions#secrets)."
    *
    * You must authenticate using an access token with the repo scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-or-update-an-environment>
    */
    pub async fn repos_create_or_update_environment(
        &self,
        owner: &str,
        repo: &str,
        environment_name: &str,
        body: &types::CreateUpdateEnvironmentRequest,
    ) -> Result<types::Environment> {
        let url = format!(
            "/repos/{}/{}/environments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete an environment.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/environments/{environment_name}` endpoint.
    *
    * You must authenticate using an access token with the repo scope to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-an-environment>
    */
    pub async fn repos_delete_an_environment(
        &self,
        owner: &str,
        repo: &str,
        environment_name: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/environments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List repository events.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/events` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-repository-events>
    */
    pub async fn activity_list_repo_events(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Event>> {
        let url = format!(
            "/repos/{}/{}/events?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List forks.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/forks` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-forks>
    */
    pub async fn repos_list_forks(
        &self,
        owner: &str,
        repo: &str,
        sort: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/repos/{}/{}/forks?page={}&per_page={}&sort={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            sort.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a fork.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/forks` endpoint.
    *
    * Create a fork for the authenticated user.
    *
    * **Note**: Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the git objects. If this takes longer than 5 minutes, be sure to contact [GitHub Support](https://support.github.com/contact) or [GitHub Premium Support](https://premium.githubsupport.com).
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-a-fork>
    */
    pub async fn repos_create_fork(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateForkRequest,
    ) -> Result<types::FullRepository> {
        let url = format!(
            "/repos/{}/{}/forks",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Create a blob.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/git/blobs` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/git#create-a-blob>
    */
    pub async fn git_create_blob(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateBlobRequest,
    ) -> Result<types::ShortBlob> {
        let url = format!(
            "/repos/{}/{}/git/blobs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a blob.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/git/blobs/{file_sha}` endpoint.
    *
    * The `content` in the response will always be Base64 encoded.
    *
    * _Note_: This API supports blobs up to 100 megabytes in size.
    *
    * FROM: <https://docs.github.com/rest/reference/git#get-a-blob>
    */
    pub async fn git_get_blob(
        &self,
        owner: &str,
        repo: &str,
        file_sha: &str,
    ) -> Result<types::Blob> {
        let url = format!(
            "/repos/{}/{}/git/blobs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&file_sha.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Create a commit.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/git/commits` endpoint.
    *
    * Creates a new Git [commit object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
    *
    * **Signature verification object**
    *
    * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
    *
    * | Name | Type | Description |
    * | ---- | ---- | ----------- |
    * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    * | `signature` | `string` | The signature that was extracted from the commit. |
    * | `payload` | `string` | The value that was signed. |
    *
    * These are the possible values for `reason` in the `verification` object:
    *
    * | Value | Description |
    * | ----- | ----------- |
    * | `expired_key` | The key that made the signature is expired. |
    * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    * | `gpgverify_error` | There was an error communicating with the signature verification service. |
    * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    * | `unsigned` | The object does not include a signature. |
    * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    * | `no_user` | No user was associated with the `committer` email address in the commit. |
    * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
    * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    * | `malformed_signature` | There was an error parsing the signature. |
    * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    *
    * FROM: <https://docs.github.com/rest/reference/git#create-a-commit>
    */
    pub async fn git_create_commit(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateCommitRequest,
    ) -> Result<types::GitCommit> {
        let url = format!(
            "/repos/{}/{}/git/commits",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a commit.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/git/commits/{commit_sha}` endpoint.
    *
    * Gets a Git [commit object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects).
    *
    * **Signature verification object**
    *
    * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
    *
    * | Name | Type | Description |
    * | ---- | ---- | ----------- |
    * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    * | `signature` | `string` | The signature that was extracted from the commit. |
    * | `payload` | `string` | The value that was signed. |
    *
    * These are the possible values for `reason` in the `verification` object:
    *
    * | Value | Description |
    * | ----- | ----------- |
    * | `expired_key` | The key that made the signature is expired. |
    * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    * | `gpgverify_error` | There was an error communicating with the signature verification service. |
    * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    * | `unsigned` | The object does not include a signature. |
    * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    * | `no_user` | No user was associated with the `committer` email address in the commit. |
    * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
    * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    * | `malformed_signature` | There was an error parsing the signature. |
    * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    *
    * FROM: <https://docs.github.com/rest/reference/git#get-a-commit>
    */
    pub async fn git_get_commit(
        &self,
        owner: &str,
        repo: &str,
        commit_sha: &str,
    ) -> Result<types::GitCommit> {
        let url = format!(
            "/repos/{}/{}/git/commits/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&commit_sha.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List matching references.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/git/matching-refs/{ref}` endpoint.
    *
    * Returns an array of references from your Git database that match the supplied name. The `:ref` in the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't exist in the repository, but existing refs start with `:ref`, they will be returned as an array.
    *
    * When you use this endpoint without providing a `:ref`, it will return an array of all the references from your Git database, including notes and stashes if they exist on the server. Anything in the namespace is returned, not just `heads` and `tags`.
    *
    * **Note:** You need to explicitly [request a pull request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
    *
    * If you request matching references for a branch named `feature` but the branch `feature` doesn't exist, the response can still include other matching head refs that start with the word `feature`, such as `featureA` and `featureB`.
    *
    * FROM: <https://docs.github.com/rest/reference/git#list-matching-references>
    */
    pub async fn git_list_matching_refs(
        &self,
        owner: &str,
        repo: &str,
        ref_: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::GitRef>> {
        let url = format!(
            "/repos/{}/{}/git/matching-refs/{}?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a reference.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/git/ref/{ref}` endpoint.
    *
    * Returns a single reference from your Git database. The `:ref` in the URL must be formatted as `heads/<branch name>` for branches and `tags/<tag name>` for tags. If the `:ref` doesn't match an existing ref, a `404` is returned.
    *
    * **Note:** You need to explicitly [request a pull request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) to trigger a test merge commit, which checks the mergeability of pull requests. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
    *
    * FROM: <https://docs.github.com/rest/reference/git#get-a-reference>
    */
    pub async fn git_get_ref(&self, owner: &str, repo: &str, ref_: &str) -> Result<types::GitRef> {
        let url = format!(
            "/repos/{}/{}/git/ref/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Create a reference.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/git/refs` endpoint.
    *
    * Creates a reference for your repository. You are unable to create new references for empty repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories without branches.
    *
    * FROM: <https://docs.github.com/rest/reference/git#create-a-reference>
    */
    pub async fn git_create_ref(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateReferenceRequest,
    ) -> Result<types::GitRef> {
        let url = format!(
            "/repos/{}/{}/git/refs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete a reference.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/git/refs/{ref}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/git#delete-a-reference>
    */
    pub async fn git_delete_ref(&self, owner: &str, repo: &str, ref_: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/git/refs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a reference.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/git/refs/{ref}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/git#update-a-reference>
    */
    pub async fn git_update_ref(
        &self,
        owner: &str,
        repo: &str,
        ref_: &str,
        body: &types::UpdateReferenceRequest,
    ) -> Result<types::GitRef> {
        let url = format!(
            "/repos/{}/{}/git/refs/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Create a tag object.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/git/tags` endpoint.
    *
    * Note that creating a tag object does not create the reference that makes a tag in Git. If you want to create an annotated tag in Git, you have to do this call to create the tag object, and then [create](https://docs.github.com/rest/reference/git#create-a-reference) the `refs/tags/[tag]` reference. If you want to create a lightweight tag, you only have to [create](https://docs.github.com/rest/reference/git#create-a-reference) the tag reference - this call would be unnecessary.
    *
    * **Signature verification object**
    *
    * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
    *
    * | Name | Type | Description |
    * | ---- | ---- | ----------- |
    * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    * | `signature` | `string` | The signature that was extracted from the commit. |
    * | `payload` | `string` | The value that was signed. |
    *
    * These are the possible values for `reason` in the `verification` object:
    *
    * | Value | Description |
    * | ----- | ----------- |
    * | `expired_key` | The key that made the signature is expired. |
    * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    * | `gpgverify_error` | There was an error communicating with the signature verification service. |
    * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    * | `unsigned` | The object does not include a signature. |
    * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    * | `no_user` | No user was associated with the `committer` email address in the commit. |
    * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
    * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    * | `malformed_signature` | There was an error parsing the signature. |
    * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    *
    * FROM: <https://docs.github.com/rest/reference/git#create-a-tag-object>
    */
    pub async fn git_create_tag(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateTagObjectRequest,
    ) -> Result<types::GitTag> {
        let url = format!(
            "/repos/{}/{}/git/tags",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a tag.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/git/tags/{tag_sha}` endpoint.
    *
    * **Signature verification object**
    *
    * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
    *
    * | Name | Type | Description |
    * | ---- | ---- | ----------- |
    * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    * | `signature` | `string` | The signature that was extracted from the commit. |
    * | `payload` | `string` | The value that was signed. |
    *
    * These are the possible values for `reason` in the `verification` object:
    *
    * | Value | Description |
    * | ----- | ----------- |
    * | `expired_key` | The key that made the signature is expired. |
    * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    * | `gpgverify_error` | There was an error communicating with the signature verification service. |
    * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    * | `unsigned` | The object does not include a signature. |
    * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    * | `no_user` | No user was associated with the `committer` email address in the commit. |
    * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
    * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    * | `malformed_signature` | There was an error parsing the signature. |
    * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    *
    * FROM: <https://docs.github.com/rest/reference/git#get-a-tag>
    */
    pub async fn git_get_tag(
        &self,
        owner: &str,
        repo: &str,
        tag_sha: &str,
    ) -> Result<types::GitTag> {
        let url = format!(
            "/repos/{}/{}/git/tags/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&tag_sha.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Create a tree.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/git/trees` endpoint.
    *
    * The tree creation API accepts nested entries. If you specify both a tree and a nested path modifying that tree, this endpoint will overwrite the contents of the tree with the new path contents, and create a new tree structure.
    *
    * If you use this endpoint to add, delete, or modify the file contents in a tree, you will need to commit the tree and then update a branch to point to the commit. For more information see "[Create a commit](https://docs.github.com/rest/reference/git#create-a-commit)" and "[Update a reference](https://docs.github.com/rest/reference/git#update-a-reference)."
    *
    * FROM: <https://docs.github.com/rest/reference/git#create-a-tree>
    */
    pub async fn git_create_tree(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateTreeRequest,
    ) -> Result<types::GitTree> {
        let url = format!(
            "/repos/{}/{}/git/trees",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a tree.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/git/trees/{tree_sha}` endpoint.
    *
    * Returns a single tree using the SHA1 value for that tree.
    *
    * If `truncated` is `true` in the response then the number of items in the `tree` array exceeded our maximum limit. If you need to fetch more items, use the non-recursive method of fetching trees, and fetch one sub-tree at a time.
    *
    * FROM: <https://docs.github.com/rest/reference/git#get-a-tree>
    */
    pub async fn git_get_tree(
        &self,
        owner: &str,
        repo: &str,
        tree_sha: &str,
        recursive: &str,
    ) -> Result<types::GitTree> {
        let url = format!(
            "/repos/{}/{}/git/trees/{}?recursive={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&tree_sha.to_string()),
            recursive.to_string(),
        );

        self.get(&url).await
    }

    /**
    * List repository webhooks.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/hooks` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-repository-webhooks>
    */
    pub async fn repos_list_webhooks(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Hook>> {
        let url = format!(
            "/repos/{}/{}/hooks?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a repository webhook.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/hooks` endpoint.
    *
    * Repositories can have multiple webhooks installed. Each webhook should have a unique `config`. Multiple webhooks can
    * share the same `config` as long as those webhooks do not have any `events` that overlap.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-a-repository-webhook>
    */
    pub async fn repos_create_webhook(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateRepositoryWebhookRequest,
    ) -> Result<types::Hook> {
        let url = format!(
            "/repos/{}/{}/hooks",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a repository webhook.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/hooks/{hook_id}` endpoint.
    *
    * Returns a webhook configured in a repository. To get only the webhook `config` properties, see "[Get a webhook configuration for a repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository)."
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-repository-webhook>
    */
    pub async fn repos_get_webhook(
        &self,
        owner: &str,
        repo: &str,
        hook_id: i64,
    ) -> Result<types::Hook> {
        let url = format!(
            "/repos/{}/{}/hooks/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a repository webhook.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/hooks/{hook_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-a-repository-webhook>
    */
    pub async fn repos_delete_webhook(&self, owner: &str, repo: &str, hook_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/hooks/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a repository webhook.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/hooks/{hook_id}` endpoint.
    *
    * Updates a webhook configured in a repository. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for a repository](/rest/reference/repos#update-a-webhook-configuration-for-a-repository)."
    *
    * FROM: <https://docs.github.com/rest/reference/repos#update-a-repository-webhook>
    */
    pub async fn repos_update_webhook(
        &self,
        owner: &str,
        repo: &str,
        hook_id: i64,
        body: &types::UpdateRepositoryWebhookRequest,
    ) -> Result<types::Hook> {
        let url = format!(
            "/repos/{}/{}/hooks/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a webhook configuration for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/hooks/{hook_id}/config` endpoint.
    *
    * Returns the webhook configuration for a repository. To get more information about the webhook, including the `active` state and `events`, use "[Get a repository webhook](/rest/reference/orgs#get-a-repository-webhook)."
    *
    * Access tokens must have the `read:repo_hook` or `repo` scope, and GitHub Apps must have the `repository_hooks:read` permission.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-webhook-configuration-for-a-repository>
    */
    pub async fn repos_get_webhook_config_for_repo(
        &self,
        owner: &str,
        repo: &str,
        hook_id: i64,
    ) -> Result<types::WebhookConfig> {
        let url = format!(
            "/repos/{}/{}/hooks/{}/config",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Update a webhook configuration for a repository.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/hooks/{hook_id}/config` endpoint.
    *
    * Updates the webhook configuration for a repository. To update more information about the webhook, including the `active` state and `events`, use "[Update a repository webhook](/rest/reference/orgs#update-a-repository-webhook)."
    *
    * Access tokens must have the `write:repo_hook` or `repo` scope, and GitHub Apps must have the `repository_hooks:write` permission.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#update-a-webhook-configuration-for-a-repository>
    */
    pub async fn repos_update_webhook_config_for_repo(
        &self,
        owner: &str,
        repo: &str,
        hook_id: i64,
        body: &types::UpdateWebhookConfigurationRepositoryRequest,
    ) -> Result<types::WebhookConfig> {
        let url = format!(
            "/repos/{}/{}/hooks/{}/config",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Ping a repository webhook.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/hooks/{hook_id}/pings` endpoint.
    *
    * This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the hook.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#ping-a-repository-webhook>
    */
    pub async fn repos_ping_webhook(&self, owner: &str, repo: &str, hook_id: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/hooks/{}/pings",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Test the push repository webhook.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/hooks/{hook_id}/tests` endpoint.
    *
    * This will trigger the hook with the latest push to the current repository if the hook is subscribed to `push` events. If the hook is not subscribed to `push` events, the server will respond with 204 but no test POST will be generated.
    *
    * **Note**: Previously `/repos/:owner/:repo/hooks/:hook_id/test`
    *
    * FROM: <https://docs.github.com/rest/reference/repos#test-the-push-repository-webhook>
    */
    pub async fn repos_test_push_webhook(
        &self,
        owner: &str,
        repo: &str,
        hook_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/hooks/{}/tests",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&hook_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Get an import status.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/import` endpoint.
    *
    * View the progress of an import.
    *
    * **Import status**
    *
    * This section includes details about the possible values of the `status` field of the Import Progress response.
    *
    * An import that does not have errors will progress through these steps:
    *
    * *   `detecting` - the "detection" step of the import is in progress because the request did not include a `vcs` parameter. The import is identifying the type of source control present at the URL.
    * *   `importing` - the "raw" step of the import is in progress. This is where commit data is fetched from the original repository. The import progress response will include `commit_count` (the total number of raw commits that will be imported) and `percent` (0 - 100, the current progress through the import).
    * *   `mapping` - the "rewrite" step of the import is in progress. This is where SVN branches are converted to Git branches, and where author updates are applied. The import progress response does not include progress information.
    * *   `pushing` - the "push" step of the import is in progress. This is where the importer updates the repository on GitHub. The import progress response will include `push_percent`, which is the percent value reported by `git push` when it is "Writing objects".
    * *   `complete` - the import is complete, and the repository is ready on GitHub.
    *
    * If there are problems, you will see one of these in the `status` field:
    *
    * *   `auth_failed` - the import requires authentication in order to connect to the original repository. To update authentication for the import, please see the [Update an import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
    * *   `error` - the import encountered an error. The import progress response will include the `failed_step` and an error message. Contact [GitHub Support](https://support.github.com/contact) or [GitHub Premium Support](https://premium.githubsupport.com) for more information.
    * *   `detection_needs_auth` - the importer requires authentication for the originating repository to continue detection. To update authentication for the import, please see the [Update an import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
    * *   `detection_found_nothing` - the importer didn't recognize any source control at the URL. To resolve, [Cancel the import](https://docs.github.com/rest/reference/migrations#cancel-an-import) and [retry](https://docs.github.com/rest/reference/migrations#start-an-import) with the correct URL.
    * *   `detection_found_multiple` - the importer found several projects or repositories at the provided URL. When this is the case, the Import Progress response will also include a `project_choices` field with the possible project choices as values. To update project choice, please see the [Update an import](https://docs.github.com/rest/reference/migrations#update-an-import) section.
    *
    * **The project_choices field**
    *
    * When multiple projects are found at the provided URL, the response hash will include a `project_choices` field, the value of which is an array of hashes each representing a project choice. The exact key/value pairs of the project hashes will differ depending on the version control type.
    *
    * **Git LFS related fields**
    *
    * This section includes details about Git LFS related fields that may be present in the Import Progress response.
    *
    * *   `use_lfs` - describes whether the import has been opted in or out of using Git LFS. The value can be `opt_in`, `opt_out`, or `undecided` if no action has been taken.
    * *   `has_large_files` - the boolean value describing whether files larger than 100MB were found during the `importing` step.
    * *   `large_files_size` - the total size in gigabytes of files larger than 100MB found in the originating repository.
    * *   `large_files_count` - the total number of files larger than 100MB found in the originating repository. To see a list of these files, make a "Get Large Files" request.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#get-an-import-status>
    */
    pub async fn migrations_get_import_status(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::Import> {
        let url = format!(
            "/repos/{}/{}/import",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Start an import.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/import` endpoint.
    *
    * Start a source import to a GitHub repository using GitHub Importer.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#start-an-import>
    */
    pub async fn migrations_start_import(
        &self,
        owner: &str,
        repo: &str,
        body: &types::StartImportRequest,
    ) -> Result<types::Import> {
        let url = format!(
            "/repos/{}/{}/import",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Cancel an import.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/import` endpoint.
    *
    * Stop an import for a repository.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#cancel-an-import>
    */
    pub async fn migrations_cancel_import(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/import",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update an import.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/import` endpoint.
    *
    * An import can be updated with credentials or a project choice by passing in the appropriate parameters in this API
    * request. If no parameters are provided, the import will be restarted.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#update-an-import>
    */
    pub async fn migrations_update_import(
        &self,
        owner: &str,
        repo: &str,
        body: &types::UpdateImportRequest,
    ) -> Result<types::Import> {
        let url = format!(
            "/repos/{}/{}/import",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get commit authors.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/import/authors` endpoint.
    *
    * Each type of source control system represents authors in a different way. For example, a Git commit author has a display name and an email address, but a Subversion commit author just has a username. The GitHub Importer will make the author information valid, but the author might not be correct. For example, it will change the bare Subversion username `hubot` into something like `hubot <hubot@12341234-abab-fefe-8787-fedcba987654>`.
    *
    * This endpoint and the [Map a commit author](https://docs.github.com/rest/reference/migrations#map-a-commit-author) endpoint allow you to provide correct Git author information.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#get-commit-authors>
    */
    pub async fn migrations_get_commit_authors(
        &self,
        owner: &str,
        repo: &str,
        since: i64,
    ) -> Result<Vec<types::PorterAuthor>> {
        let url = format!(
            "/repos/{}/{}/import/authors?since={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", since),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Map a commit author.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/import/authors/{author_id}` endpoint.
    *
    * Update an author's identity for the import. Your application can continue updating authors any time before you push new commits to the repository.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#map-a-commit-author>
    */
    pub async fn migrations_map_commit_author(
        &self,
        owner: &str,
        repo: &str,
        author_id: i64,
        body: &types::MapCommitAuthorRequest,
    ) -> Result<types::PorterAuthor> {
        let url = format!(
            "/repos/{}/{}/import/authors/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&author_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get large files.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/import/large_files` endpoint.
    *
    * List files larger than 100MB found during the import
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#get-large-files>
    */
    pub async fn migrations_get_large_files(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<Vec<types::PorterLargeFile>> {
        let url = format!(
            "/repos/{}/{}/import/large_files",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Update Git LFS preference.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/import/lfs` endpoint.
    *
    * You can import repositories from Subversion, Mercurial, and TFS that include files larger than 100MB. This ability is powered by [Git LFS](https://git-lfs.github.com). You can learn more about our LFS feature and working with large files [on our help site](https://help.github.com/articles/versioning-large-files/).
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#update-git-lfs-preference>
    */
    pub async fn migrations_set_lfs_preference(
        &self,
        owner: &str,
        repo: &str,
        body: &types::UpdateGitLfsPreferenceRequest,
    ) -> Result<types::Import> {
        let url = format!(
            "/repos/{}/{}/import/lfs",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a repository installation for the authenticated app.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/installation` endpoint.
    *
    * Enables an authenticated GitHub App to find the repository's installation information. The installation's account type will be either an organization or a user account, depending which account the repository belongs to.
    *
    * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#get-a-repository-installation-for-the-authenticated-app>
    */
    pub async fn apps_get_repo_installation(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::Installation> {
        let url = format!(
            "/repos/{}/{}/installation",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get interaction restrictions for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/interaction-limits` endpoint.
    *
    * Shows which type of GitHub user can interact with this repository and when the restriction expires. If there are no restrictions, you will see an empty response.
    *
    * FROM: <https://docs.github.com/rest/reference/interactions#get-interaction-restrictions-for-a-repository>
    */
    pub async fn interactions_get_restrictions_for_repo(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::GetInteractionRestrictionsRepositoryOkResponse> {
        let url = format!(
            "/repos/{}/{}/interaction-limits",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Set interaction restrictions for a repository.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/interaction-limits` endpoint.
    *
    * Temporarily restricts interactions to a certain type of GitHub user within the given repository. You must have owner or admin access to set these restrictions. If an interaction limit is set for the user or organization that owns this repository, you will receive a `409 Conflict` response and will not be able to use this endpoint to change the interaction limit for a single repository.
    *
    * FROM: <https://docs.github.com/rest/reference/interactions#set-interaction-restrictions-for-a-repository>
    */
    pub async fn interactions_set_restrictions_for_repo(
        &self,
        owner: &str,
        repo: &str,
        body: &types::InteractionLimit,
    ) -> Result<types::InteractionLimitResponse> {
        let url = format!(
            "/repos/{}/{}/interaction-limits",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove interaction restrictions for a repository.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/interaction-limits` endpoint.
    *
    * Removes all interaction restrictions from the given repository. You must have owner or admin access to remove restrictions. If the interaction limit is set for the user or organization that owns this repository, you will receive a `409 Conflict` response and will not be able to use this endpoint to change the interaction limit for a single repository.
    *
    * FROM: <https://docs.github.com/rest/reference/interactions#remove-interaction-restrictions-for-a-repository>
    */
    pub async fn interactions_remove_restrictions_for_repo(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/interaction-limits",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List repository invitations.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/invitations` endpoint.
    *
    * When authenticating as a user with admin rights to a repository, this endpoint will list all currently open repository invitations.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-repository-invitations>
    */
    pub async fn repos_list_invitations(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::RepositoryInvitation>> {
        let url = format!(
            "/repos/{}/{}/invitations?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Delete a repository invitation.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/invitations/{invitation_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-a-repository-invitation>
    */
    pub async fn repos_delete_invitation(
        &self,
        owner: &str,
        repo: &str,
        invitation_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/invitations/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&invitation_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a repository invitation.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/invitations/{invitation_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#update-a-repository-invitation>
    */
    pub async fn repos_update_invitation(
        &self,
        owner: &str,
        repo: &str,
        invitation_id: i64,
        body: &types::UpdateRepositoryInvitationRequest,
    ) -> Result<types::RepositoryInvitation> {
        let url = format!(
            "/repos/{}/{}/invitations/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&invitation_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List repository issues.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/issues` endpoint.
    *
    * List issues in a repository.
    *
    * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
    * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
    * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
    * request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#list-repository-issues>
    */
    pub async fn issues_list_for_repo(
        &self,
        owner: &str,
        repo: &str,
        milestone: &str,
        state: &str,
        assignee: &str,
        creator: &str,
        mentioned: &str,
        labels: &str,
        sort: &str,
        direction: &str,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::IssueSimple>> {
        let url = format!("/repos/{}/{}/issues?assignee={}&creator={}&direction={}&labels={}&mentioned={}&milestone={}&page={}&per_page={}&since={}&sort={}&state={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
assignee.to_string(), creator.to_string(), direction.to_string(), labels.to_string(), mentioned.to_string(), milestone.to_string(), format!("{}", page), format!("{}", per_page), since.to_rfc3339(), sort.to_string(), state.to_string(),         );

        self.get_all_pages(&url).await
    }

    /**
    * Create an issue.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/issues` endpoint.
    *
    * Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://help.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.
    *
    * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-abuse-rate-limits)" for details.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#create-an-issue>
    */
    pub async fn issues_create(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateIssueRequest,
    ) -> Result<types::Issue> {
        let url = format!(
            "/repos/{}/{}/issues",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List issue comments for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/comments` endpoint.
    *
    * By default, Issue Comments are ordered by ascending ID.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#list-issue-comments-for-a-repository>
    */
    pub async fn issues_list_comments_for_repo(
        &self,
        owner: &str,
        repo: &str,
        sort: &str,
        direction: &str,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::IssueComment>> {
        let url = format!(
            "/repos/{}/{}/issues/comments?direction={}&page={}&per_page={}&since={}&sort={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            direction.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
            sort.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get an issue comment.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/comments/{comment_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#get-an-issue-comment>
    */
    pub async fn issues_get_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
    ) -> Result<types::IssueComment> {
        let url = format!(
            "/repos/{}/{}/issues/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete an issue comment.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/issues/comments/{comment_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#delete-an-issue-comment>
    */
    pub async fn issues_delete_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/issues/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update an issue comment.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/issues/comments/{comment_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#update-an-issue-comment>
    */
    pub async fn issues_update_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        body: &types::UpdateIssueCommentRequest,
    ) -> Result<types::IssueComment> {
        let url = format!(
            "/repos/{}/{}/issues/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List reactions for an issue comment.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions` endpoint.
    *
    * List the reactions to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#list-reactions-for-an-issue-comment>
    */
    pub async fn reactions_list_for_issue_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        content: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/repos/{}/{}/issues/comments/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
            content.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create reaction for an issue comment.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions` endpoint.
    *
    * Create a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments). A response with an HTTP `200` status means that you already added the reaction type to this issue comment.
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#create-reaction-for-an-issue-comment>
    */
    pub async fn reactions_create_for_issue_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        body: &types::CreateReactionIssueCommentRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/repos/{}/{}/issues/comments/{}/reactions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete an issue comment reaction.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}` endpoint.
    *
    * **Note:** You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.
    *
    * Delete a reaction to an [issue comment](https://docs.github.com/rest/reference/issues#comments).
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#delete-an-issue-comment-reaction>
    */
    pub async fn reactions_delete_for_issue_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        reaction_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/issues/comments/{}/reactions/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
            progenitor_support::encode_path(&reaction_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List issue events for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/events` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#list-issue-events-for-a-repository>
    */
    pub async fn issues_list_events_for_repo(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::IssueEvent>> {
        let url = format!(
            "/repos/{}/{}/issues/events?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get an issue event.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/events/{event_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#get-an-issue-event>
    */
    pub async fn issues_get_event(
        &self,
        owner: &str,
        repo: &str,
        event_id: i64,
    ) -> Result<types::IssueEvent> {
        let url = format!(
            "/repos/{}/{}/issues/events/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&event_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get an issue.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/{issue_number}` endpoint.
    *
    * The API returns a [`301 Moved Permanently` status](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
    * [transferred](https://help.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If
    * the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
    * returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read
    * access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe
    * to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.
    *
    * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
    * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
    * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
    * request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#get-an-issue>
    */
    pub async fn issues_get(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
    ) -> Result<types::Issue> {
        let url = format!(
            "/repos/{}/{}/issues/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Update an issue.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/issues/{issue_number}` endpoint.
    *
    * Issue owners and users with push access can edit an issue.
    *
    * FROM: <https://docs.github.com/rest/reference/issues/#update-an-issue>
    */
    pub async fn issues_update(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        body: &types::UpdateIssueRequest,
    ) -> Result<types::Issue> {
        let url = format!(
            "/repos/{}/{}/issues/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Add assignees to an issue.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/issues/{issue_number}/assignees` endpoint.
    *
    * Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#add-assignees-to-an-issue>
    */
    pub async fn issues_add_assignees(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        body: &types::AddAssigneesIssueRequest,
    ) -> Result<types::IssueSimple> {
        let url = format!(
            "/repos/{}/{}/issues/{}/assignees",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove assignees from an issue.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/issues/{issue_number}/assignees` endpoint.
    *
    * Removes one or more assignees from an issue.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#remove-assignees-from-an-issue>
    */
    pub async fn issues_remove_assignees(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        body: &types::RemoveAssigneesFromIssueRequest,
    ) -> Result<types::IssueSimple> {
        let url = format!(
            "/repos/{}/{}/issues/{}/assignees",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.delete(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List issue comments.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/{issue_number}/comments` endpoint.
    *
    * Issue Comments are ordered by ascending ID.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#list-issue-comments>
    */
    pub async fn issues_list_comments(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::IssueComment>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/comments?page={}&per_page={}&since={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create an issue comment.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/issues/{issue_number}/comments` endpoint.
    *
    * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-abuse-rate-limits)" for details.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#create-an-issue-comment>
    */
    pub async fn issues_create_comment(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        body: &types::CreateIssueCommentRequest,
    ) -> Result<types::IssueComment> {
        let url = format!(
            "/repos/{}/{}/issues/{}/comments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List issue events.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/{issue_number}/events` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#list-issue-events>
    */
    pub async fn issues_list_events(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::IssueEventforIssue>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/events?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List labels for an issue.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/{issue_number}/labels` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#list-labels-for-an-issue>
    */
    pub async fn issues_list_labels_on_issue(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Label>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/labels?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Set labels for an issue.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/issues/{issue_number}/labels` endpoint.
    *
    * Removes any previous labels and sets the new labels for an issue.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#set-labels-for-an-issue>
    */
    pub async fn issues_set_labels(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        body: &types::SetLabelsIssueRequest,
    ) -> Result<Vec<types::Label>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/labels",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Add labels to an issue.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/issues/{issue_number}/labels` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#add-labels-to-an-issue>
    */
    pub async fn issues_add_labels(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        body: &types::AddLabelsIssueRequest,
    ) -> Result<Vec<types::Label>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/labels",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove all labels from an issue.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/issues/{issue_number}/labels` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#remove-all-labels-from-an-issue>
    */
    pub async fn issues_remove_all_labels(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/issues/{}/labels",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Remove a label from an issue.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}` endpoint.
    *
    * Removes the specified label from the issue, and returns the remaining labels on the issue. This endpoint returns a `404 Not Found` status if the label does not exist.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#remove-a-label-from-an-issue>
    */
    pub async fn issues_remove_label(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        name: &str,
    ) -> Result<Vec<types::Label>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/labels/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
            progenitor_support::encode_path(&name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Lock an issue.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/issues/{issue_number}/lock` endpoint.
    *
    * Users with push access can lock an issue or pull request's conversation.
    *
    * Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
    *
    * FROM: <https://docs.github.com/rest/reference/issues#lock-an-issue>
    */
    pub async fn issues_lock(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        body: &types::LockIssueRequest,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/issues/{}/lock",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Unlock an issue.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/issues/{issue_number}/lock` endpoint.
    *
    * Users with push access can unlock an issue's conversation.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#unlock-an-issue>
    */
    pub async fn issues_unlock(&self, owner: &str, repo: &str, issue_number: i64) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/issues/{}/lock",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List reactions for an issue.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/{issue_number}/reactions` endpoint.
    *
    * List the reactions to an [issue](https://docs.github.com/rest/reference/issues).
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#list-reactions-for-an-issue>
    */
    pub async fn reactions_list_for_issue(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        content: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
            content.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create reaction for an issue.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/issues/{issue_number}/reactions` endpoint.
    *
    * Create a reaction to an [issue](https://docs.github.com/rest/reference/issues/). A response with an HTTP `200` status means that you already added the reaction type to this issue.
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#create-reaction-for-an-issue>
    */
    pub async fn reactions_create_for_issue(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        body: &types::CreateReactionIssueRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/repos/{}/{}/issues/{}/reactions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete an issue reaction.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}` endpoint.
    *
    * **Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.
    *
    * Delete a reaction to an [issue](https://docs.github.com/rest/reference/issues/).
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#delete-an-issue-reaction>
    */
    pub async fn reactions_delete_for_issue(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        reaction_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/issues/{}/reactions/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
            progenitor_support::encode_path(&reaction_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List timeline events for an issue.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/issues/{issue_number}/timeline` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#list-timeline-events-for-an-issue>
    */
    pub async fn issues_list_events_for_timeline(
        &self,
        owner: &str,
        repo: &str,
        issue_number: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::TimelineIssueEvents>> {
        let url = format!(
            "/repos/{}/{}/issues/{}/timeline?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&issue_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List deploy keys.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/keys` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-deploy-keys>
    */
    pub async fn repos_list_deploy_keys(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::DeployKey>> {
        let url = format!(
            "/repos/{}/{}/keys?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a deploy key.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/keys` endpoint.
    *
    * You can create a read-only deploy key.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-a-deploy-key>
    */
    pub async fn repos_create_deploy_key(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateDeployKeyRequest,
    ) -> Result<types::DeployKey> {
        let url = format!(
            "/repos/{}/{}/keys",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a deploy key.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/keys/{key_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-deploy-key>
    */
    pub async fn repos_get_deploy_key(
        &self,
        owner: &str,
        repo: &str,
        key_id: i64,
    ) -> Result<types::DeployKey> {
        let url = format!(
            "/repos/{}/{}/keys/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&key_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a deploy key.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/keys/{key_id}` endpoint.
    *
    * Deploy keys are immutable. If you need to update a key, remove the key and create a new one instead.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-a-deploy-key>
    */
    pub async fn repos_delete_deploy_key(
        &self,
        owner: &str,
        repo: &str,
        key_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/keys/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&key_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List labels for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/labels` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#list-labels-for-a-repository>
    */
    pub async fn issues_list_labels_for_repo(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Label>> {
        let url = format!(
            "/repos/{}/{}/labels?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a label.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/labels` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#create-a-label>
    */
    pub async fn issues_create_label(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateLabelRequest,
    ) -> Result<types::Label> {
        let url = format!(
            "/repos/{}/{}/labels",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a label.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/labels/{name}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#get-a-label>
    */
    pub async fn issues_get_label(
        &self,
        owner: &str,
        repo: &str,
        name: &str,
    ) -> Result<types::Label> {
        let url = format!(
            "/repos/{}/{}/labels/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&name.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a label.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/labels/{name}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#delete-a-label>
    */
    pub async fn issues_delete_label(&self, owner: &str, repo: &str, name: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/labels/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a label.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/labels/{name}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#update-a-label>
    */
    pub async fn issues_update_label(
        &self,
        owner: &str,
        repo: &str,
        name: &str,
        body: &types::UpdateLabelRequest,
    ) -> Result<types::Label> {
        let url = format!(
            "/repos/{}/{}/labels/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&name.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List repository languages.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/languages` endpoint.
    *
    * Lists languages for the specified repository. The value shown for each language is the number of bytes of code written in that language.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-repository-languages>
    */
    pub async fn repos_list_languages(&self, owner: &str, repo: &str) -> Result<types::Language> {
        let url = format!(
            "/repos/{}/{}/languages",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get the license for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/license` endpoint.
    *
    * This method returns the contents of the repository's license file, if one is detected.
    *
    * Similar to [Get repository content](https://docs.github.com/rest/reference/repos#get-repository-content), this method also supports [custom media types](https://docs.github.com/rest/overview/media-types) for retrieving the raw license content or rendered license HTML.
    *
    * FROM: <https://docs.github.com/rest/reference/licenses/#get-the-license-for-a-repository>
    */
    pub async fn licenses_get_for_repo(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::LicenseContent> {
        let url = format!(
            "/repos/{}/{}/license",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Merge a branch.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/merges` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#merge-a-branch>
    */
    pub async fn repos_merge(
        &self,
        owner: &str,
        repo: &str,
        body: &types::MergeBranchRequest,
    ) -> Result<types::Commit> {
        let url = format!(
            "/repos/{}/{}/merges",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List milestones.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/milestones` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#list-milestones>
    */
    pub async fn issues_list_milestones(
        &self,
        owner: &str,
        repo: &str,
        state: &str,
        sort: &str,
        direction: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Milestone>> {
        let url = format!(
            "/repos/{}/{}/milestones?direction={}&page={}&per_page={}&sort={}&state={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            direction.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            sort.to_string(),
            state.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a milestone.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/milestones` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#create-a-milestone>
    */
    pub async fn issues_create_milestone(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateMilestoneRequest,
    ) -> Result<types::Milestone> {
        let url = format!(
            "/repos/{}/{}/milestones",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a milestone.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/milestones/{milestone_number}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#get-a-milestone>
    */
    pub async fn issues_get_milestone(
        &self,
        owner: &str,
        repo: &str,
        milestone_number: i64,
    ) -> Result<types::Milestone> {
        let url = format!(
            "/repos/{}/{}/milestones/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&milestone_number.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a milestone.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/milestones/{milestone_number}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#delete-a-milestone>
    */
    pub async fn issues_delete_milestone(
        &self,
        owner: &str,
        repo: &str,
        milestone_number: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/milestones/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&milestone_number.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a milestone.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/milestones/{milestone_number}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#update-a-milestone>
    */
    pub async fn issues_update_milestone(
        &self,
        owner: &str,
        repo: &str,
        milestone_number: i64,
        body: &types::UpdateMilestoneRequest,
    ) -> Result<types::Milestone> {
        let url = format!(
            "/repos/{}/{}/milestones/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&milestone_number.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List labels for issues in a milestone.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/milestones/{milestone_number}/labels` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/issues#list-labels-for-issues-in-a-milestone>
    */
    pub async fn issues_list_labels_for_milestone(
        &self,
        owner: &str,
        repo: &str,
        milestone_number: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Label>> {
        let url = format!(
            "/repos/{}/{}/milestones/{}/labels?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&milestone_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List repository notifications for the authenticated user.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/notifications` endpoint.
    *
    * List all notifications for the current user.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-repository-notifications-for-the-authenticated-user>
    */
    pub async fn activity_list_repo_notifications_for_authenticated_user(
        &self,
        owner: &str,
        repo: &str,
        all: bool,
        participating: bool,
        since: DateTime<Utc>,
        before: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Thread>> {
        let url = format!("/repos/{}/{}/notifications?all={}&before={}&page={}&participating={}&per_page={}&since={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
format!("{}", all), before.to_rfc3339(), format!("{}", page), format!("{}", participating), format!("{}", per_page), since.to_rfc3339(),         );

        self.get_all_pages(&url).await
    }

    /**
    * Mark repository notifications as read.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/notifications` endpoint.
    *
    * Marks all notifications in a repository as "read" removes them from the [default view on GitHub](https://github.com/notifications). If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List repository notifications for the authenticated user](https://docs.github.com/rest/reference/activity#list-repository-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#mark-repository-notifications-as-read>
    */
    pub async fn activity_mark_repo_notifications_as_read(
        &self,
        owner: &str,
        repo: &str,
        body: &types::MarkRepositoryNotificationsasReadRequest,
    ) -> Result<types::PutMarkRepositoryNotificationsasReadAcceptedResponse> {
        let url = format!(
            "/repos/{}/{}/notifications",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a GitHub Pages site.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pages` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-github-pages-site>
    */
    pub async fn repos_get_pages(&self, owner: &str, repo: &str) -> Result<types::Page> {
        let url = format!(
            "/repos/{}/{}/pages",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Update information about a GitHub Pages site.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/pages` endpoint.
    *
    * Updates information for a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).
    *
    * FROM: <https://docs.github.com/rest/reference/repos#update-information-about-a-github-pages-site>
    */
    pub async fn repos_update_information_about_pages_site(
        &self,
        owner: &str,
        repo: &str,
        body: &types::UpdateInformationAboutGithubPagesSiteRequest,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/pages",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Create a GitHub Pages site.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/pages` endpoint.
    *
    * Configures a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages)."
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-a-github-pages-site>
    */
    pub async fn repos_create_pages_site(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateGithubPagesSiteRequest,
    ) -> Result<types::Page> {
        let url = format!(
            "/repos/{}/{}/pages",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete a GitHub Pages site.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/pages` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-a-github-pages-site>
    */
    pub async fn repos_delete_pages_site(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/pages",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List GitHub Pages builds.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pages/builds` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-github-pages-builds>
    */
    pub async fn repos_list_pages_builds(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::PageBuild>> {
        let url = format!(
            "/repos/{}/{}/pages/builds?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Request a GitHub Pages build.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/pages/builds` endpoint.
    *
    * You can request that your site be built from the latest revision on the default branch. This has the same effect as pushing a commit to your default branch, but does not require an additional commit. Manually triggering page builds can be helpful when diagnosing build warnings and failures.
    *
    * Build requests are limited to one concurrent build per repository and one concurrent build per requester. If you request a build while another is still in progress, the second request will be queued until the first completes.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#request-a-github-pages-build>
    */
    pub async fn repos_request_pages_build(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::PageBuildStatus> {
        let url = format!(
            "/repos/{}/{}/pages/builds",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Get latest Pages build.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pages/builds/latest` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-latest-pages-build>
    */
    pub async fn repos_get_latest_pages_build(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::PageBuild> {
        let url = format!(
            "/repos/{}/{}/pages/builds/latest",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get GitHub Pages build.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pages/builds/{build_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-github-pages-build>
    */
    pub async fn repos_get_pages_build(
        &self,
        owner: &str,
        repo: &str,
        build_id: i64,
    ) -> Result<types::PageBuild> {
        let url = format!(
            "/repos/{}/{}/pages/builds/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&build_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get a DNS health check for GitHub Pages.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pages/health` endpoint.
    *
    * Gets a health check of the DNS settings for the `CNAME` record configured for a repository's GitHub Pages.
    *
    * The first request to this endpoint returns a `202 Accepted` status and starts an asynchronous background task to get the results for the domain. After the background task completes, subsequent requests to this endpoint return a `200 OK` status with the health check results in the response.
    *
    * Users must have admin or owner permissions. GitHub Apps must have the `pages:write` and `administration:write` permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-dns-health-check-for-github-pages>
    */
    pub async fn repos_get_pages_health_check(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::PagesHealthCheck> {
        let url = format!(
            "/repos/{}/{}/pages/health",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List repository projects.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/projects` endpoint.
    *
    * Lists the projects in a repository. Returns a `404 Not Found` status if projects are disabled in the repository. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    *
    * FROM: <https://docs.github.com/rest/reference/projects#list-repository-projects>
    */
    pub async fn projects_list_for_repo(
        &self,
        owner: &str,
        repo: &str,
        state: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Project>> {
        let url = format!(
            "/repos/{}/{}/projects?page={}&per_page={}&state={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            state.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a repository project.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/projects` endpoint.
    *
    * Creates a repository project board. Returns a `404 Not Found` status if projects are disabled in the repository. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    *
    * FROM: <https://docs.github.com/rest/reference/projects#create-a-repository-project>
    */
    pub async fn projects_create_for_repo(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateRepositoryProjectRequest,
    ) -> Result<types::Project> {
        let url = format!(
            "/repos/{}/{}/projects",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List pull requests.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls` endpoint.
    *
    * Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#list-pull-requests>
    */
    pub async fn pulls_list(
        &self,
        owner: &str,
        repo: &str,
        state: &str,
        head: &str,
        base: &str,
        sort: &str,
        direction: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::PullRequestSimple>> {
        let url = format!(
            "/repos/{}/{}/pulls?base={}&direction={}&head={}&page={}&per_page={}&sort={}&state={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            base.to_string(),
            direction.to_string(),
            head.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            sort.to_string(),
            state.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a pull request.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/pulls` endpoint.
    *
    * Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * To open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.
    *
    * You can create a new pull request.
    *
    * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#create-a-pull-request>
    */
    pub async fn pulls_create(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreatePullRequestRequest,
    ) -> Result<types::PullRequest> {
        let url = format!(
            "/repos/{}/{}/pulls",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List review comments in a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/comments` endpoint.
    *
    * Lists review comments for all pull requests in a repository. By default, review comments are in ascending order by ID.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#list-review-comments-in-a-repository>
    */
    pub async fn pulls_list_review_comments_for_repo(
        &self,
        owner: &str,
        repo: &str,
        sort: &str,
        direction: &str,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::PullRequestReviewComment>> {
        let url = format!(
            "/repos/{}/{}/pulls/comments?direction={}&page={}&per_page={}&since={}&sort={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            direction.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
            sort.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a review comment for a pull request.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/comments/{comment_id}` endpoint.
    *
    * Provides details for a review comment.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#get-a-review-comment-for-a-pull-request>
    */
    pub async fn pulls_get_review_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
    ) -> Result<types::PullRequestReviewComment> {
        let url = format!(
            "/repos/{}/{}/pulls/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a review comment for a pull request.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/pulls/comments/{comment_id}` endpoint.
    *
    * Deletes a review comment.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#delete-a-review-comment-for-a-pull-request>
    */
    pub async fn pulls_delete_review_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/pulls/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a review comment for a pull request.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/pulls/comments/{comment_id}` endpoint.
    *
    * Enables you to edit a review comment.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#update-a-review-comment-for-a-pull-request>
    */
    pub async fn pulls_update_review_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        body: &types::UpdateReviewCommentPullRequestRequest,
    ) -> Result<types::PullRequestReviewComment> {
        let url = format!(
            "/repos/{}/{}/pulls/comments/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List reactions for a pull request review comment.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions` endpoint.
    *
    * List the reactions to a [pull request review comment](https://docs.github.com/rest/reference/pulls#review-comments).
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#list-reactions-for-a-pull-request-review-comment>
    */
    pub async fn reactions_list_for_pull_request_review_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        content: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/repos/{}/{}/pulls/comments/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
            content.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create reaction for a pull request review comment.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions` endpoint.
    *
    * Create a reaction to a [pull request review comment](https://docs.github.com/rest/reference/pulls#comments). A response with an HTTP `200` status means that you already added the reaction type to this pull request review comment.
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#create-reaction-for-a-pull-request-review-comment>
    */
    pub async fn reactions_create_for_pull_request_review_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        body: &types::CreateReactionPullRequestReviewCommentRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/repos/{}/{}/pulls/comments/{}/reactions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete a pull request comment reaction.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}` endpoint.
    *
    * **Note:** You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`
    *
    * Delete a reaction to a [pull request review comment](https://docs.github.com/rest/reference/pulls#review-comments).
    *
    * FROM: <https://docs.github.com/rest/reference/reactions#delete-a-pull-request-comment-reaction>
    */
    pub async fn reactions_delete_for_pull_request_comment(
        &self,
        owner: &str,
        repo: &str,
        comment_id: i64,
        reaction_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/pulls/comments/{}/reactions/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
            progenitor_support::encode_path(&reaction_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get a pull request.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}` endpoint.
    *
    * Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Lists details of a pull request by providing its number.
    *
    * When you get, [create](https://docs.github.com/rest/reference/pulls/#create-a-pull-request), or [edit](https://docs.github.com/rest/reference/pulls#update-a-pull-request) a pull request, GitHub creates a merge commit to test whether the pull request can be automatically merged into the base branch. This test commit is not added to the base branch or the head branch. You can review the status of the test commit using the `mergeable` key. For more information, see "[Checking mergeability of pull requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
    *
    * The value of the `mergeable` attribute can be `true`, `false`, or `null`. If the value is `null`, then GitHub has started a background job to compute the mergeability. After giving the job time to complete, resubmit the request. When the job finishes, you will see a non-`null` value for the `mergeable` attribute in the response. If `mergeable` is `true`, then `merge_commit_sha` will be the SHA of the _test_ merge commit.
    *
    * The value of the `merge_commit_sha` attribute changes depending on the state of the pull request. Before merging a pull request, the `merge_commit_sha` attribute holds the SHA of the _test_ merge commit. After merging a pull request, the `merge_commit_sha` attribute changes depending on how you merged the pull request:
    *
    * *   If merged as a [merge commit](https://help.github.com/articles/about-merge-methods-on-github/), `merge_commit_sha` represents the SHA of the merge commit.
    * *   If merged via a [squash](https://help.github.com/articles/about-merge-methods-on-github/#squashing-your-merge-commits), `merge_commit_sha` represents the SHA of the squashed commit on the base branch.
    * *   If [rebased](https://help.github.com/articles/about-merge-methods-on-github/#rebasing-and-merging-your-commits), `merge_commit_sha` represents the commit that the base branch was updated to.
    *
    * Pass the appropriate [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#get-a-pull-request>
    */
    pub async fn pulls_get(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
    ) -> Result<types::PullRequest> {
        let url = format!(
            "/repos/{}/{}/pulls/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Update a pull request.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/pulls/{pull_number}` endpoint.
    *
    * Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * To open or update a pull request in a public repository, you must have write access to the head or the source branch. For organization-owned repositories, you must be a member of the organization that owns the repository to open or update a pull request.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls/#update-a-pull-request>
    */
    pub async fn pulls_update(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        body: &types::UpdatePullRequestRequest,
    ) -> Result<types::PullRequest> {
        let url = format!(
            "/repos/{}/{}/pulls/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List review comments on a pull request.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/comments` endpoint.
    *
    * Lists all review comments for a pull request. By default, review comments are in ascending order by ID.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#list-review-comments-on-a-pull-request>
    */
    pub async fn pulls_list_review_comments(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        sort: &str,
        direction: &str,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::PullRequestReviewComment>> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/comments?direction={}&page={}&per_page={}&since={}&sort={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            direction.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
            sort.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a review comment for a pull request.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/pulls/{pull_number}/comments` endpoint.
    *
    *
    * Creates a review comment in the pull request diff. To add a regular comment to a pull request timeline, see "[Create an issue comment](https://docs.github.com/rest/reference/issues#create-an-issue-comment)." We recommend creating a review comment using `line`, `side`, and optionally `start_line` and `start_side` if your comment applies to more than one line in the pull request diff.
    *
    * You can still create a review comment using the `position` parameter. When you use `position`, the `line`, `side`, `start_line`, and `start_side` parameters are not required. For more information, see the [`comfort-fade` preview notice](https://docs.github.com/rest/reference/pulls#create-a-review-comment-for-a-pull-request-preview-notices).
    *
    * **Note:** The position value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
    *
    * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#create-a-review-comment-for-a-pull-request>
    */
    pub async fn pulls_create_review_comment(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        body: &types::CreateReviewCommentPullRequestRequest,
    ) -> Result<types::PullRequestReviewComment> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/comments",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Create a reply for a review comment.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies` endpoint.
    *
    * Creates a reply to a review comment for a pull request. For the `comment_id`, provide the ID of the review comment you are replying to. This must be the ID of a _top-level review comment_, not a reply to that comment. Replies to replies are not supported.
    *
    * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#create-a-reply-for-a-review-comment>
    */
    pub async fn pulls_create_reply_for_review_comment(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        comment_id: i64,
        body: &types::CreateReplyReviewCommentRequest,
    ) -> Result<types::PullRequestReviewComment> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/comments/{}/replies",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            progenitor_support::encode_path(&comment_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List commits on a pull request.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/commits` endpoint.
    *
    * Lists a maximum of 250 commits for a pull request. To receive a complete commit list for pull requests with more than 250 commits, use the [List commits](https://docs.github.com/rest/reference/repos#list-commits) endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#list-commits-on-a-pull-request>
    */
    pub async fn pulls_list_commits(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Commit>> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/commits?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List pull requests files.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/files` endpoint.
    *
    * **Note:** Responses include a maximum of 3000 files. The paginated response returns 30 files per page by default.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#list-pull-requests-files>
    */
    pub async fn pulls_list_files(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::DiffEntry>> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/files?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Check if a pull request has been merged.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/merge` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#check-if-a-pull-request-has-been-merged>
    */
    pub async fn pulls_check_if_merged(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/merge",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Merge a pull request.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/pulls/{pull_number}/merge` endpoint.
    *
    * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-abuse-rate-limits)" for details.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#merge-a-pull-request>
    */
    pub async fn pulls_merge(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        body: &types::MergePullRequestRequest,
    ) -> Result<types::PullRequestMergeResult> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/merge",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List requested reviewers for a pull request.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#list-requested-reviewers-for-a-pull-request>
    */
    pub async fn pulls_list_requested_reviewers(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        per_page: i64,
        page: i64,
    ) -> Result<types::PullRequestReviewRequest> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/requested_reviewers?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Request reviewers for a pull request.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers` endpoint.
    *
    * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-abuse-rate-limits)" for details.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#request-reviewers-for-a-pull-request>
    */
    pub async fn pulls_request_reviewers(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        body: &types::RequestReviewersPullRequestRequest,
    ) -> Result<types::PullRequestSimple> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/requested_reviewers",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove requested reviewers from a pull request.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#remove-requested-reviewers-from-a-pull-request>
    */
    pub async fn pulls_remove_requested_reviewers(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        body: &types::RemoveRequestedReviewersFromPullRequestRequest,
    ) -> Result<types::PullRequestSimple> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/requested_reviewers",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.delete(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List reviews for a pull request.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews` endpoint.
    *
    * The list of reviews returns in chronological order.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#list-reviews-for-a-pull-request>
    */
    pub async fn pulls_list_reviews(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::PullRequestReview>> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a review for a pull request.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews` endpoint.
    *
    * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
    *
    * Pull request reviews created in the `PENDING` state do not include the `submitted_at` property in the response.
    *
    * **Note:** To comment on a specific line in a file, you need to first determine the _position_ of that line in the diff. The GitHub REST API v3 offers the `application/vnd.github.v3.diff` [media type](https://docs.github.com/rest/overview/media-types#commits-commit-comparison-and-pull-requests). To see a pull request diff, add this media type to the `Accept` header of a call to the [single pull request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) endpoint.
    *
    * The `position` value equals the number of lines down from the first "@@" hunk header in the file you want to add a comment. The line just below the "@@" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#create-a-review-for-a-pull-request>
    */
    pub async fn pulls_create_review(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        body: &types::CreateReviewPullRequestRequest,
    ) -> Result<types::PullRequestReview> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a review for a pull request.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#get-a-review-for-a-pull-request>
    */
    pub async fn pulls_get_review(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        review_id: i64,
    ) -> Result<types::PullRequestReview> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            progenitor_support::encode_path(&review_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Update a review for a pull request.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}` endpoint.
    *
    * Update the review summary comment with new text.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#update-a-review-for-a-pull-request>
    */
    pub async fn pulls_update_review(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        review_id: i64,
        body: &types::UpdateReviewPullRequestRequest,
    ) -> Result<types::PullRequestReview> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            progenitor_support::encode_path(&review_id.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete a pending review for a pull request.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#delete-a-pending-review-for-a-pull-request>
    */
    pub async fn pulls_delete_pending_review(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        review_id: i64,
    ) -> Result<types::PullRequestReview> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            progenitor_support::encode_path(&review_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List comments for a pull request review.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments` endpoint.
    *
    * List comments for a specific pull request review.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#list-comments-for-a-pull-request-review>
    */
    pub async fn pulls_list_comments_for_review(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        review_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::ReviewComment>> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews/{}/comments?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            progenitor_support::encode_path(&review_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Dismiss a review for a pull request.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals` endpoint.
    *
    * **Note:** To dismiss a pull request review on a [protected branch](https://docs.github.com/rest/reference/repos#branches), you must be a repository administrator or be included in the list of people or teams who can dismiss pull request reviews.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#dismiss-a-review-for-a-pull-request>
    */
    pub async fn pulls_dismiss_review(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        review_id: i64,
        body: &types::DismissReviewPullRequestRequest,
    ) -> Result<types::PullRequestReview> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews/{}/dismissals",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            progenitor_support::encode_path(&review_id.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Submit a review for a pull request.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#submit-a-review-for-a-pull-request>
    */
    pub async fn pulls_submit_review(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        review_id: i64,
        body: &types::SubmitReviewPullRequestRequest,
    ) -> Result<types::PullRequestReview> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/reviews/{}/events",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
            progenitor_support::encode_path(&review_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Update a pull request branch.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/pulls/{pull_number}/update-branch` endpoint.
    *
    * Updates the pull request branch with the latest upstream changes by merging HEAD from the base branch into the pull request branch.
    *
    * FROM: <https://docs.github.com/rest/reference/pulls#update-a-pull-request-branch>
    */
    pub async fn pulls_update_branch(
        &self,
        owner: &str,
        repo: &str,
        pull_number: i64,
        body: &types::UpdatePullRequestBranchRequest,
    ) -> Result<types::PutUpdatePullRequestBranchAcceptedResponse> {
        let url = format!(
            "/repos/{}/{}/pulls/{}/update-branch",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&pull_number.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a repository README.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/readme` endpoint.
    *
    * Gets the preferred README for a repository.
    *
    * READMEs support [custom media types](https://docs.github.com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-repository-readme>
    */
    pub async fn repos_get_readme(
        &self,
        owner: &str,
        repo: &str,
        ref_: &str,
    ) -> Result<types::ContentFile> {
        let url = format!(
            "/repos/{}/{}/readme?ref={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            ref_,
        );

        self.get(&url).await
    }

    /**
    * Get a repository README for a directory.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/readme/{dir}` endpoint.
    *
    * Gets the README from a repository directory.
    *
    * READMEs support [custom media types](https://docs.github.com/rest/reference/repos#custom-media-types) for retrieving the raw content or rendered HTML.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-repository-directory-readme>
    */
    pub async fn repos_get_readme_in_directory(
        &self,
        owner: &str,
        repo: &str,
        dir: &str,
        ref_: &str,
    ) -> Result<types::ContentFile> {
        let url = format!(
            "/repos/{}/{}/readme/{}?ref={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&dir.to_string()),
            ref_,
        );

        self.get(&url).await
    }

    /**
    * List releases.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/releases` endpoint.
    *
    * This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/rest/reference/repos#list-repository-tags).
    *
    * Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-releases>
    */
    pub async fn repos_list_releases(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Release>> {
        let url = format!(
            "/repos/{}/{}/releases?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a release.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/releases` endpoint.
    *
    * Users with push access to the repository can create a release.
    *
    * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-a-release>
    */
    pub async fn repos_create_release(
        &self,
        owner: &str,
        repo: &str,
        body: &types::CreateReleaseRequest,
    ) -> Result<types::Release> {
        let url = format!(
            "/repos/{}/{}/releases",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a release asset.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/releases/assets/{asset_id}` endpoint.
    *
    * To download the asset's binary content, set the `Accept` header of the request to [`application/octet-stream`](https://docs.github.com/rest/overview/media-types). The API will either redirect the client to the location, or stream it directly if possible. API clients should handle both a `200` or `302` response.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-release-asset>
    */
    pub async fn repos_get_release_asset(
        &self,
        owner: &str,
        repo: &str,
        asset_id: i64,
    ) -> Result<types::ReleaseAsset> {
        let url = format!(
            "/repos/{}/{}/releases/assets/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&asset_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a release asset.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/releases/assets/{asset_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-a-release-asset>
    */
    pub async fn repos_delete_release_asset(
        &self,
        owner: &str,
        repo: &str,
        asset_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/releases/assets/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&asset_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a release asset.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/releases/assets/{asset_id}` endpoint.
    *
    * Users with push access to the repository can edit a release asset.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#update-a-release-asset>
    */
    pub async fn repos_update_release_asset(
        &self,
        owner: &str,
        repo: &str,
        asset_id: i64,
        body: &types::UpdateReleaseAssetRequest,
    ) -> Result<types::ReleaseAsset> {
        let url = format!(
            "/repos/{}/{}/releases/assets/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&asset_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get the latest release.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/releases/latest` endpoint.
    *
    * View the latest published full release for the repository.
    *
    * The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-the-latest-release>
    */
    pub async fn repos_get_latest_release(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::Release> {
        let url = format!(
            "/repos/{}/{}/releases/latest",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get a release by tag name.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/releases/tags/{tag}` endpoint.
    *
    * Get a published release with the specified tag.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-release-by-tag-name>
    */
    pub async fn repos_get_release_by_tag(
        &self,
        owner: &str,
        repo: &str,
        tag: &str,
    ) -> Result<types::Release> {
        let url = format!(
            "/repos/{}/{}/releases/tags/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&tag.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get a release.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/releases/{release_id}` endpoint.
    *
    * **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a [hypermedia resource](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia).
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-a-release>
    */
    pub async fn repos_get_release(
        &self,
        owner: &str,
        repo: &str,
        release_id: i64,
    ) -> Result<types::Release> {
        let url = format!(
            "/repos/{}/{}/releases/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&release_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a release.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/releases/{release_id}` endpoint.
    *
    * Users with push access to the repository can delete a release.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#delete-a-release>
    */
    pub async fn repos_delete_release(
        &self,
        owner: &str,
        repo: &str,
        release_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/releases/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&release_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a release.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/releases/{release_id}` endpoint.
    *
    * Users with push access to the repository can edit a release.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#update-a-release>
    */
    pub async fn repos_update_release(
        &self,
        owner: &str,
        repo: &str,
        release_id: i64,
        body: &types::UpdateReleaseRequest,
    ) -> Result<types::Release> {
        let url = format!(
            "/repos/{}/{}/releases/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&release_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List release assets.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/releases/{release_id}/assets` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-release-assets>
    */
    pub async fn repos_list_release_assets(
        &self,
        owner: &str,
        repo: &str,
        release_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::ReleaseAsset>> {
        let url = format!(
            "/repos/{}/{}/releases/{}/assets?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&release_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Upload a release asset.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/releases/{release_id}/assets` endpoint.
    *
    * This endpoint makes use of [a Hypermedia relation](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia) to determine which URL to access. The endpoint you call to upload release assets is specific to your release. Use the `upload_url` returned in
    * the response of the [Create a release endpoint](https://docs.github.com/rest/reference/repos#create-a-release) to upload a release asset.
    *
    * You need to use an HTTP client which supports [SNI](http://en.wikipedia.org/wiki/Server_Name_Indication) to make calls to this endpoint.
    *
    * Most libraries will set the required `Content-Length` header automatically. Use the required `Content-Type` header to provide the media type of the asset. For a list of media types, see [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example:
    *
    * `application/zip`
    *
    * GitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw binary content of the asset as the request body. Everything else about the endpoint is the same as the rest of the API. For example,
    * you'll still need to pass your authentication to be able to upload an asset.
    *
    * When an upstream failure occurs, you will receive a `502 Bad Gateway` status. This may leave an empty asset with a state of `starter`. It can be safely deleted.
    *
    * **Notes:**
    * *   GitHub renames asset filenames that have special characters, non-alphanumeric characters, and leading or trailing periods. The "[List assets for a release](https://docs.github.com/rest/reference/repos#list-assets-for-a-release)"
    * endpoint lists the renamed filenames. For more information and help, contact [GitHub Support](https://support.github.com/contact).
    * *   If you upload an asset with the same filename as another uploaded asset, you'll receive an error and must delete the old file before you can re-upload the new asset.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#upload-a-release-asset>
    */
    pub async fn repos_upload_release_asset<T: Into<reqwest::Body>>(
        &self,
        owner: &str,
        repo: &str,
        release_id: i64,
        name: &str,
        label: &str,
        body: T,
    ) -> Result<types::ReleaseAsset> {
        let url = format!(
            "/repos/{}/{}/releases/{}/assets?label={}&name={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&release_id.to_string()),
            label.to_string(),
            name.to_string(),
        );

        self.post(&url, Some(body.into())).await
    }

    /**
    * Create reaction for a release.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/releases/{release_id}/reactions` endpoint.
    *
    * Create a reaction to a [release](https://docs.github.com/rest/reference/repos#releases). A response with a `Status: 200 OK` means that you already added the reaction type to this release.
    *
    * FROM: <https://docs.github.com/rest/reference/reactions/#create-reaction-for-a-release>
    */
    pub async fn reactions_create_for_release(
        &self,
        owner: &str,
        repo: &str,
        release_id: i64,
        body: &types::CreateReactionReleaseRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/repos/{}/{}/releases/{}/reactions",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&release_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List secret scanning alerts for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/secret-scanning/alerts` endpoint.
    *
    * Lists all secret scanning alerts for a private repository, from newest to oldest. To use this endpoint, you must be an administrator for the repository or organization, and you must use an access token with the `repo` scope or `security_events` scope.
    *
    * GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/secret-scanning#list-secret-scanning-alerts-for-a-repository>
    */
    pub async fn secret_scanning_list_alerts_for_repo(
        &self,
        owner: &str,
        repo: &str,
        state: &str,
        secret_type: &str,
        page: i64,
        per_page: i64,
    ) -> Result<Vec<types::SecretScanningAlert>> {
        let url = format!(
            "/repos/{}/{}/secret-scanning/alerts?page={}&per_page={}&secret_type={}&state={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            secret_type.to_string(),
            state.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a secret scanning alert.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}` endpoint.
    *
    * Gets a single secret scanning alert detected in a private repository. To use this endpoint, you must be an administrator for the repository or organization, and you must use an access token with the `repo` scope or `security_events` scope.
    *
    * GitHub Apps must have the `secret_scanning_alerts` read permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/secret-scanning#get-a-secret-scanning-alert>
    */
    pub async fn secret_scanning_get_alert(
        &self,
        owner: &str,
        repo: &str,
        alert_number: &str,
    ) -> Result<types::SecretScanningAlert> {
        let url = format!(
            "/repos/{}/{}/secret-scanning/alerts/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&alert_number.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Update a secret scanning alert.
    *
    * This function performs a `PATCH` to the `/repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}` endpoint.
    *
    * Updates the status of a secret scanning alert in a private repository. To use this endpoint, you must be an administrator for the repository or organization, and you must use an access token with the `repo` scope or `security_events` scope.
    *
    * GitHub Apps must have the `secret_scanning_alerts` write permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/secret-scanning#update-a-secret-scanning-alert>
    */
    pub async fn secret_scanning_update_alert(
        &self,
        owner: &str,
        repo: &str,
        alert_number: &str,
        body: &types::UpdateSecretScanningAlertRequest,
    ) -> Result<types::SecretScanningAlert> {
        let url = format!(
            "/repos/{}/{}/secret-scanning/alerts/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&alert_number.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List stargazers.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/stargazers` endpoint.
    *
    * Lists the people that have starred the repository.
    *
    * You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-stargazers>
    */
    pub async fn activity_list_stargazers_for_repo(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/repos/{}/{}/stargazers?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get the weekly commit activity.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/stats/code_frequency` endpoint.
    *
    * Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-the-weekly-commit-activity>
    */
    pub async fn repos_get_code_frequency_stats(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<Vec<Vec<i64>>> {
        let url = format!(
            "/repos/{}/{}/stats/code_frequency",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get the last year of commit activity.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/stats/commit_activity` endpoint.
    *
    * Returns the last year of commit activity grouped by week. The `days` array is a group of commits per day, starting on `Sunday`.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-the-last-year-of-commit-activity>
    */
    pub async fn repos_get_commit_activity_stats(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<Vec<types::CommitActivity>> {
        let url = format!(
            "/repos/{}/{}/stats/commit_activity",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get all contributor commit activity.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/stats/contributors` endpoint.
    *
    *
    * Returns the `total` number of commits authored by the contributor. In addition, the response includes a Weekly Hash (`weeks` array) with the following information:
    *
    * *   `w` - Start of the week, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time).
    * *   `a` - Number of additions
    * *   `d` - Number of deletions
    * *   `c` - Number of commits
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-all-contributor-commit-activity>
    */
    pub async fn repos_get_contributors_stats(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<Vec<types::ContributorActivity>> {
        let url = format!(
            "/repos/{}/{}/stats/contributors",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get the weekly commit count.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/stats/participation` endpoint.
    *
    * Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the commit counts for non-owners, you can subtract `owner` from `all`.
    *
    * The array order is oldest week (index 0) to most recent week.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-the-weekly-commit-count>
    */
    pub async fn repos_get_participation_stats(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::ParticipationStats> {
        let url = format!(
            "/repos/{}/{}/stats/participation",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get the hourly commit count for each day.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/stats/punch_card` endpoint.
    *
    * Each array contains the day number, hour number, and number of commits:
    *
    * *   `0-6`: Sunday - Saturday
    * *   `0-23`: Hour of day
    * *   Number of commits
    *
    * For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-the-hourly-commit-count-for-each-day>
    */
    pub async fn repos_get_punch_card_stats(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<Vec<Vec<i64>>> {
        let url = format!(
            "/repos/{}/{}/stats/punch_card",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a commit status.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/statuses/{sha}` endpoint.
    *
    * Users with push access in a repository can create commit statuses for a given SHA.
    *
    * Note: there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to create more than 1000 statuses will result in a validation error.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-a-commit-status>
    */
    pub async fn repos_create_commit_status(
        &self,
        owner: &str,
        repo: &str,
        sha: &str,
        body: &types::CreateCommitStatusRequest,
    ) -> Result<types::Status> {
        let url = format!(
            "/repos/{}/{}/statuses/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&sha.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List watchers.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/subscribers` endpoint.
    *
    * Lists the people watching the specified repository.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-watchers>
    */
    pub async fn activity_list_watchers_for_repo(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/repos/{}/{}/subscribers?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a repository subscription.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/subscription` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/activity#get-a-repository-subscription>
    */
    pub async fn activity_get_repo_subscription(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<types::RepositorySubscription> {
        let url = format!(
            "/repos/{}/{}/subscription",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Set a repository subscription.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/subscription` endpoint.
    *
    * If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore notifications made within a repository, set `ignored` to `true`. If you would like to stop watching a repository, [delete the repository's subscription](https://docs.github.com/rest/reference/activity#delete-a-repository-subscription) completely.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#set-a-repository-subscription>
    */
    pub async fn activity_set_repo_subscription(
        &self,
        owner: &str,
        repo: &str,
        body: &types::SetRepositorySubscriptionRequest,
    ) -> Result<types::RepositorySubscription> {
        let url = format!(
            "/repos/{}/{}/subscription",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete a repository subscription.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/subscription` endpoint.
    *
    * This endpoint should only be used to stop watching a repository. To control whether or not you wish to receive notifications from a repository, [set the repository's subscription manually](https://docs.github.com/rest/reference/activity#set-a-repository-subscription).
    *
    * FROM: <https://docs.github.com/rest/reference/activity#delete-a-repository-subscription>
    */
    pub async fn activity_delete_repo_subscription(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/subscription",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List repository tags.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/tags` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-repository-tags>
    */
    pub async fn repos_list_tags(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Tag>> {
        let url = format!(
            "/repos/{}/{}/tags?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Download a repository archive (tar).
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/tarball/{ref}` endpoint.
    *
    * Gets a redirect URL to download a tar archive for a repository. If you omit `:ref`, the repository’s default branch (usually
    * `master`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
    * the `Location` header to make a second `GET` request.
    * **Note**: For private repositories, these links are temporary and expire after five minutes.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#download-a-repository-archive>
    */
    pub async fn repos_download_tarball_archive(
        &self,
        owner: &str,
        repo: &str,
        ref_: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/tarball/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List repository teams.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/teams` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-repository-teams>
    */
    pub async fn repos_list_teams(
        &self,
        owner: &str,
        repo: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Team>> {
        let url = format!(
            "/repos/{}/{}/teams?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get all repository topics.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/topics` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-all-repository-topics>
    */
    pub async fn repos_get_all_topics(
        &self,
        owner: &str,
        repo: &str,
        page: i64,
        per_page: i64,
    ) -> Result<types::Topic> {
        let url = format!(
            "/repos/{}/{}/topics?page={}&per_page={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Replace all repository topics.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/topics` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#replace-all-repository-topics>
    */
    pub async fn repos_replace_all_topics(
        &self,
        owner: &str,
        repo: &str,
        body: &types::ReplaceAllRepositoryTopicsRequest,
    ) -> Result<types::Topic> {
        let url = format!(
            "/repos/{}/{}/topics",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get repository clones.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/traffic/clones` endpoint.
    *
    * Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-repository-clones>
    */
    pub async fn repos_get_clones(
        &self,
        owner: &str,
        repo: &str,
        per: &str,
    ) -> Result<types::CloneTraffic> {
        let url = format!(
            "/repos/{}/{}/traffic/clones?per={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            per.to_string(),
        );

        self.get(&url).await
    }

    /**
    * Get top referral paths.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/traffic/popular/paths` endpoint.
    *
    * Get the top 10 popular contents over the last 14 days.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-top-referral-paths>
    */
    pub async fn repos_get_top_paths(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<Vec<types::ContentTraffic>> {
        let url = format!(
            "/repos/{}/{}/traffic/popular/paths",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get top referral sources.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/traffic/popular/referrers` endpoint.
    *
    * Get the top 10 referrers over the last 14 days.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-top-referral-sources>
    */
    pub async fn repos_get_top_referrers(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<Vec<types::ReferrerTraffic>> {
        let url = format!(
            "/repos/{}/{}/traffic/popular/referrers",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get page views.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/traffic/views` endpoint.
    *
    * Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#get-page-views>
    */
    pub async fn repos_get_views(
        &self,
        owner: &str,
        repo: &str,
        per: &str,
    ) -> Result<types::ViewTraffic> {
        let url = format!(
            "/repos/{}/{}/traffic/views?per={}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            per.to_string(),
        );

        self.get(&url).await
    }

    /**
    * Transfer a repository.
    *
    * This function performs a `POST` to the `/repos/{owner}/{repo}/transfer` endpoint.
    *
    * A transfer request will need to be accepted by the new owner when transferring a personal repository to another user. The response will contain the original `owner`, and the transfer will continue asynchronously. For more details on the requirements to transfer personal and organization-owned repositories, see [about repository transfers](https://help.github.com/articles/about-repository-transfers/).
    *
    * FROM: <https://docs.github.com/rest/reference/repos#transfer-a-repository>
    */
    pub async fn repos_transfer(
        &self,
        owner: &str,
        repo: &str,
        body: &types::TransferRepositoryRequest,
    ) -> Result<types::MinimalRepository> {
        let url = format!(
            "/repos/{}/{}/transfer",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Check if vulnerability alerts are enabled for a repository.
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/vulnerability-alerts` endpoint.
    *
    * Shows whether dependency alerts are enabled or disabled for a repository. The authenticated user must have admin access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://help.github.com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
    *
    * FROM: <https://docs.github.com/rest/reference/repos#check-if-vulnerability-alerts-are-enabled-for-a-repository>
    */
    pub async fn repos_check_vulnerability_alerts(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/vulnerability-alerts",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Enable vulnerability alerts.
    *
    * This function performs a `PUT` to the `/repos/{owner}/{repo}/vulnerability-alerts` endpoint.
    *
    * Enables dependency alerts and the dependency graph for a repository. The authenticated user must have admin access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://help.github.com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
    *
    * FROM: <https://docs.github.com/rest/reference/repos#enable-vulnerability-alerts>
    */
    pub async fn repos_enable_vulnerability_alerts(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/vulnerability-alerts",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Disable vulnerability alerts.
    *
    * This function performs a `DELETE` to the `/repos/{owner}/{repo}/vulnerability-alerts` endpoint.
    *
    * Disables dependency alerts and the dependency graph for a repository. The authenticated user must have admin access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://help.github.com/en/articles/about-security-alerts-for-vulnerable-dependencies)".
    *
    * FROM: <https://docs.github.com/rest/reference/repos#disable-vulnerability-alerts>
    */
    pub async fn repos_disable_vulnerability_alerts(&self, owner: &str, repo: &str) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/vulnerability-alerts",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Download a repository archive (zip).
    *
    * This function performs a `GET` to the `/repos/{owner}/{repo}/zipball/{ref}` endpoint.
    *
    * Gets a redirect URL to download a zip archive for a repository. If you omit `:ref`, the repository’s default branch (usually
    * `master`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
    * the `Location` header to make a second `GET` request.
    * **Note**: For private repositories, these links are temporary and expire after five minutes.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#download-a-repository-archive>
    */
    pub async fn repos_download_zipball_archive(
        &self,
        owner: &str,
        repo: &str,
        ref_: &str,
    ) -> Result<()> {
        let url = format!(
            "/repos/{}/{}/zipball/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
            progenitor_support::encode_path(&ref_.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Create a repository using a template.
    *
    * This function performs a `POST` to the `/repos/{template_owner}/{template_repo}/generate` endpoint.
    *
    * Creates a new repository using a repository template. Use the `template_owner` and `template_repo` route parameters to specify the repository to use as the template. The authenticated user must own or be a member of an organization that owns the repository. To check if a repository is available to use as a template, get the repository's information using the [Get a repository](https://docs.github.com/rest/reference/repos#get-a-repository) endpoint and check that the `is_template` key is `true`.
    *
    * **OAuth scope requirements**
    *
    * When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
    *
    * *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
    * *   `repo` scope to create a private repository
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-a-repository-using-a-template>
    */
    pub async fn repos_create_using_template(
        &self,
        template_owner: &str,
        template_repo: &str,
        body: &types::CreateRepositoryUsingTemplateRequest,
    ) -> Result<types::Repository> {
        let url = format!(
            "/repos/{}/{}/generate",
            progenitor_support::encode_path(&template_owner.to_string()),
            progenitor_support::encode_path(&template_repo.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List public repositories.
    *
    * This function performs a `GET` to the `/repositories` endpoint.
    *
    * Lists all public repositories in the order that they were created.
    *
    * Note:
    * - For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.
    * - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of repositories.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-public-repositories>
    */
    pub async fn repos_list_public(&self, since: i64) -> Result<Vec<types::MinimalRepository>> {
        let url = format!("/repositories?since={}", format!("{}", since),);

        self.get_all_pages(&url).await
    }

    /**
    * List environment secrets.
    *
    * This function performs a `GET` to the `/repositories/{repository_id}/environments/{environment_name}/secrets` endpoint.
    *
    * Lists all secrets available in an environment without revealing their encrypted values. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#list-environment-secrets>
    */
    pub async fn actions_list_environment_secrets(
        &self,
        repository_id: i64,
        environment_name: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListEnvironmentSecretsOkResponse> {
        let url = format!(
            "/repositories/{}/environments/{}/secrets?page={}&per_page={}",
            progenitor_support::encode_path(&repository_id.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Get an environment public key.
    *
    * This function performs a `GET` to the `/repositories/{repository_id}/environments/{environment_name}/secrets/public-key` endpoint.
    *
    * Get the public key for an environment, which you need to encrypt environment secrets. You need to encrypt a secret before you can create or update secrets. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `secrets` repository permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-an-environment-public-key>
    */
    pub async fn actions_get_environment_public_key(
        &self,
        repository_id: i64,
        environment_name: &str,
    ) -> Result<types::ActionsPublicKey> {
        let url = format!(
            "/repositories/{}/environments/{}/secrets/public-key",
            progenitor_support::encode_path(&repository_id.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get an environment secret.
    *
    * This function performs a `GET` to the `/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}` endpoint.
    *
    * Gets a single environment secret without revealing its encrypted value. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#get-an-environment-secret>
    */
    pub async fn actions_get_environment_secret(
        &self,
        repository_id: i64,
        environment_name: &str,
        secret_name: &str,
    ) -> Result<types::ActionsSecret> {
        let url = format!(
            "/repositories/{}/environments/{}/secrets/{}",
            progenitor_support::encode_path(&repository_id.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Create or update an environment secret.
    *
    * This function performs a `PUT` to the `/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}` endpoint.
    *
    * Creates or updates an environment secret with an encrypted value. Encrypt your secret using
    * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must authenticate using an access
    * token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use
    * this endpoint.
    *
    * #### Example encrypting a secret using Node.js
    *
    * Encrypt your secret using the [tweetsodium](https://github.com/github/tweetsodium) library.
    *
    * ```
    * const sodium = require('tweetsodium');
    *
    * const key = "base64-encoded-public-key";
    * const value = "plain-text-secret";
    *
    * // Convert the message and key to Uint8Array's (Buffer implements that interface)
    * const messageBytes = Buffer.from(value);
    * const keyBytes = Buffer.from(key, 'base64');
    *
    * // Encrypt using LibSodium.
    * const encryptedBytes = sodium.seal(messageBytes, keyBytes);
    *
    * // Base64 the encrypted secret
    * const encrypted = Buffer.from(encryptedBytes).toString('base64');
    *
    * console.log(encrypted);
    * ```
    *
    *
    * #### Example encrypting a secret using Python
    *
    * Encrypt your secret using [pynacl](https://pynacl.readthedocs.io/en/stable/public/#nacl-public-sealedbox) with Python 3.
    *
    * ```
    * from base64 import b64encode
    * from nacl import encoding, public
    *
    * def encrypt(public_key: str, secret_value: str) -> str:
    *   """Encrypt a Unicode string using the public key."""
    *   public_key = public.PublicKey(public_key.encode("utf-8"), encoding.Base64Encoder())
    *   sealed_box = public.SealedBox(public_key)
    *   encrypted = sealed_box.encrypt(secret_value.encode("utf-8"))
    *   return b64encode(encrypted).decode("utf-8")
    * ```
    *
    * #### Example encrypting a secret using C#
    *
    * Encrypt your secret using the [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package.
    *
    * ```
    * var secretValue = System.Text.Encoding.UTF8.GetBytes("mySecret");
    * var publicKey = Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU=");
    *
    * var sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
    *
    * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox));
    * ```
    *
    * #### Example encrypting a secret using Ruby
    *
    * Encrypt your secret using the [rbnacl](https://github.com/RubyCrypto/rbnacl) gem.
    *
    * ```ruby
    * require "rbnacl"
    * require "base64"
    *
    * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=")
    * public_key = RbNaCl::PublicKey.new(key)
    *
    * box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
    * encrypted_secret = box.encrypt("my_secret")
    *
    * # Print the base64 encoded secret
    * puts Base64.strict_encode64(encrypted_secret)
    * ```
    *
    * FROM: <https://docs.github.com/rest/reference/actions#create-or-update-an-environment-secret>
    */
    pub async fn actions_create_or_update_environment_secret(
        &self,
        repository_id: i64,
        environment_name: &str,
        secret_name: &str,
        body: &types::CreateUpdateEnvironmentSecretRequest,
    ) -> Result<types::EmptyObject> {
        let url = format!(
            "/repositories/{}/environments/{}/secrets/{}",
            progenitor_support::encode_path(&repository_id.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete an environment secret.
    *
    * This function performs a `DELETE` to the `/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}` endpoint.
    *
    * Deletes a secret in an environment using the secret name. You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets` repository permission to use this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/actions#delete-an-environment-secret>
    */
    pub async fn actions_delete_environment_secret(
        &self,
        repository_id: i64,
        environment_name: &str,
        secret_name: &str,
    ) -> Result<()> {
        let url = format!(
            "/repositories/{}/environments/{}/secrets/{}",
            progenitor_support::encode_path(&repository_id.to_string()),
            progenitor_support::encode_path(&environment_name.to_string()),
            progenitor_support::encode_path(&secret_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List provisioned SCIM groups for an enterprise.
    *
    * This function performs a `GET` to the `/scim/v2/enterprises/{enterprise}/Groups` endpoint.
    *
    * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-provisioned-scim-groups-for-an-enterprise>
    */
    pub async fn enterprise_admin_list_provisioned_groups_enterprise(
        &self,
        enterprise: &str,
        start_index: i64,
        count: i64,
        filter: &str,
        excluded_attributes: &str,
    ) -> Result<types::ScimGroupListEnterprise> {
        let url = format!("/scim/v2/enterprises/{}/Groups?count={}&excluded_attributes={}&filter={}&start_index={}",
            progenitor_support::encode_path(&enterprise.to_string()),
format!("{}", count), excluded_attributes.to_string(), filter.to_string(), format!("{}", start_index),         );

        self.get(&url).await
    }

    /**
    * Provision a SCIM enterprise group and invite users.
    *
    * This function performs a `POST` to the `/scim/v2/enterprises/{enterprise}/Groups` endpoint.
    *
    * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
    *
    * Provision an enterprise group, and invite users to the group. This sends invitation emails to the email address of the invited users to join the GitHub organization that the SCIM group corresponds to.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#provision-a-scim-enterprise-group-and-invite-users>
    */
    pub async fn enterprise_admin_provision_and_invite_enterprise_group(
        &self,
        enterprise: &str,
        body: &types::ProvisionScimEnterpriseGroupandInviteUsersRequest,
    ) -> Result<types::ScimEnterpriseGroup> {
        let url = format!(
            "/scim/v2/enterprises/{}/Groups",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get SCIM provisioning information for an enterprise group.
    *
    * This function performs a `GET` to the `/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}` endpoint.
    *
    * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#get-scim-provisioning-information-for-an-enterprise-group>
    */
    pub async fn enterprise_admin_get_provisioning_information_for_enterprise_group(
        &self,
        enterprise: &str,
        scim_group_id: &str,
        excluded_attributes: &str,
    ) -> Result<types::ScimEnterpriseGroup> {
        let url = format!(
            "/scim/v2/enterprises/{}/Groups/{}?excluded_attributes={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_group_id.to_string()),
            excluded_attributes.to_string(),
        );

        self.get(&url).await
    }

    /**
    * Set SCIM information for a provisioned enterprise group.
    *
    * This function performs a `PUT` to the `/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}` endpoint.
    *
    * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
    *
    * Replaces an existing provisioned group’s information. You must provide all the information required for the group as if you were provisioning it for the first time. Any existing group information that you don't provide will be removed, including group membership. If you want to only update a specific attribute, use the [Update an attribute for a SCIM enterprise group](#update-an-attribute-for-a-scim-enterprise-group) endpoint instead.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#set-scim-information-for-a-provisioned-enterprise-group>
    */
    pub async fn enterprise_admin_set_information_for_provisioned_enterprise_group(
        &self,
        enterprise: &str,
        scim_group_id: &str,
        body: &types::SetScimInformationProvisionedEnterpriseGroupRequest,
    ) -> Result<types::ScimEnterpriseGroup> {
        let url = format!(
            "/scim/v2/enterprises/{}/Groups/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_group_id.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete a SCIM group from an enterprise.
    *
    * This function performs a `DELETE` to the `/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}` endpoint.
    *
    * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#delete-a-scim-group-from-an-enterprise>
    */
    pub async fn enterprise_admin_delete_scim_group_from_enterprise(
        &self,
        enterprise: &str,
        scim_group_id: &str,
    ) -> Result<()> {
        let url = format!(
            "/scim/v2/enterprises/{}/Groups/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_group_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update an attribute for a SCIM enterprise group.
    *
    * This function performs a `PATCH` to the `/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}` endpoint.
    *
    * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
    *
    * Allows you to change a provisioned group’s individual attributes. To change a group’s values, you must provide a specific Operations JSON format that contains at least one of the add, remove, or replace operations. For examples and more information on the SCIM operations format, see the [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#update-an-attribute-for-a-scim-enterprise-group>
    */
    pub async fn enterprise_admin_update_attribute_for_enterprise_group(
        &self,
        enterprise: &str,
        scim_group_id: &str,
        body: &types::UpdateAttributeScimEnterpriseGroupRequest,
    ) -> Result<types::ScimEnterpriseGroup> {
        let url = format!(
            "/scim/v2/enterprises/{}/Groups/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_group_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List SCIM provisioned identities for an enterprise.
    *
    * This function performs a `GET` to the `/scim/v2/enterprises/{enterprise}/Users` endpoint.
    *
    * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
    *
    * Retrieves a paginated list of all provisioned enterprise members, including pending invitations.
    *
    * When a user with a SAML-provisioned external identity leaves (or is removed from) an enterprise, the account's metadata is immediately removed. However, the returned list of user accounts might not always match the organization or enterprise member list you see on GitHub. This can happen in certain cases where an external identity associated with an organization will not match an organization member:
    *   - When a user with a SCIM-provisioned external identity is removed from an enterprise, the account's metadata is preserved to allow the user to re-join the organization in the future.
    *   - When inviting a user to join an organization, you can expect to see their external identity in the results before they accept the invitation, or if the invitation is cancelled (or never accepted).
    *   - When a user is invited over SCIM, an external identity is created that matches with the invitee's email address. However, this identity is only linked to a user account when the user accepts the invitation by going through SAML SSO.
    *
    * The returned list of external identities can include an entry for a `null` user. These are unlinked SAML identities that are created when a user goes through the following Single Sign-On (SSO) process but does not sign in to their GitHub account after completing SSO:
    *
    * 1. The user is granted access by the IdP and is not a member of the GitHub enterprise.
    *
    * 1. The user attempts to access the GitHub enterprise and initiates the SAML SSO process, and is not currently signed in to their GitHub account.
    *
    * 1. After successfully authenticating with the SAML SSO IdP, the `null` external identity entry is created and the user is prompted to sign in to their GitHub account:
    *    - If the user signs in, their GitHub account is linked to this entry.
    *    - If the user does not sign in (or does not create a new account when prompted), they are not added to the GitHub enterprise, and the external identity `null` entry remains in place.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#list-scim-provisioned-identities-for-an-enterprise>
    */
    pub async fn enterprise_admin_list_provisioned_identities_enterprise(
        &self,
        enterprise: &str,
        start_index: i64,
        count: i64,
        filter: &str,
    ) -> Result<types::ScimUserListEnterprise> {
        let url = format!(
            "/scim/v2/enterprises/{}/Users?count={}&filter={}&start_index={}",
            progenitor_support::encode_path(&enterprise.to_string()),
            format!("{}", count),
            filter.to_string(),
            format!("{}", start_index),
        );

        self.get(&url).await
    }

    /**
    * Provision and invite a SCIM enterprise user.
    *
    * This function performs a `POST` to the `/scim/v2/enterprises/{enterprise}/Users` endpoint.
    *
    * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
    *
    * Provision enterprise membership for a user, and send organization invitation emails to the email address.
    *
    * You can optionally include the groups a user will be invited to join. If you do not provide a list of `groups`, the user is provisioned for the enterprise, but no organization invitation emails will be sent.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#provision-and-invite-a-scim-enterprise-user>
    */
    pub async fn enterprise_admin_provision_and_invite_enterprise_user(
        &self,
        enterprise: &str,
        body: &types::ProvisionandInviteScimEnterpriseUserRequest,
    ) -> Result<types::ScimEnterpriseUser> {
        let url = format!(
            "/scim/v2/enterprises/{}/Users",
            progenitor_support::encode_path(&enterprise.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get SCIM provisioning information for an enterprise user.
    *
    * This function performs a `GET` to the `/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}` endpoint.
    *
    * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#get-scim-provisioning-information-for-an-enterprise-user>
    */
    pub async fn enterprise_admin_get_provisioning_information_for_enterprise_user(
        &self,
        enterprise: &str,
        scim_user_id: &str,
    ) -> Result<types::ScimEnterpriseUser> {
        let url = format!(
            "/scim/v2/enterprises/{}/Users/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Set SCIM information for a provisioned enterprise user.
    *
    * This function performs a `PUT` to the `/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}` endpoint.
    *
    * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
    *
    * Replaces an existing provisioned user's information. You must provide all the information required for the user as if you were provisioning them for the first time. Any existing user information that you don't provide will be removed. If you want to only update a specific attribute, use the [Update an attribute for a SCIM user](#update-an-attribute-for-an-enterprise-scim-user) endpoint instead.
    *
    * You must at least provide the required values for the user: `userName`, `name`, and `emails`.
    *
    * **Warning:** Setting `active: false` removes the user from the enterprise, deletes the external identity, and deletes the associated `{scim_user_id}`.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#set-scim-information-for-a-provisioned-enterprise-user>
    */
    pub async fn enterprise_admin_set_information_for_provisioned_enterprise_user(
        &self,
        enterprise: &str,
        scim_user_id: &str,
        body: &types::SetScimInformationProvisionedEnterpriseUserRequest,
    ) -> Result<types::ScimEnterpriseUser> {
        let url = format!(
            "/scim/v2/enterprises/{}/Users/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete a SCIM user from an enterprise.
    *
    * This function performs a `DELETE` to the `/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}` endpoint.
    *
    * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#delete-a-scim-user-from-an-enterprise>
    */
    pub async fn enterprise_admin_delete_user_from_enterprise(
        &self,
        enterprise: &str,
        scim_user_id: &str,
    ) -> Result<()> {
        let url = format!(
            "/scim/v2/enterprises/{}/Users/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update an attribute for a SCIM enterprise user.
    *
    * This function performs a `PATCH` to the `/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}` endpoint.
    *
    * **Note:** The SCIM API endpoints for enterprise accounts are currently in beta and are subject to change.
    *
    * Allows you to change a provisioned user's individual attributes. To change a user's values, you must provide a specific `Operations` JSON format that contains at least one of the `add`, `remove`, or `replace` operations. For examples and more information on the SCIM operations format, see the [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
    *
    * **Note:** Complicated SCIM `path` selectors that include filters are not supported. For example, a `path` selector defined as `"path": "emails[type eq \"work\"]"` will not work.
    *
    * **Warning:** If you set `active:false` using the `replace` operation (as shown in the JSON example below), it removes the user from the enterprise, deletes the external identity, and deletes the associated `:scim_user_id`.
    *
    * ```
    * {
    *   "Operations":[{
    *     "op":"replace",
    *     "value":{
    *       "active":false
    *     }
    *   }]
    * }
    * ```
    *
    * FROM: <https://docs.github.com/rest/reference/enterprise-admin#update-an-attribute-for-a-scim-enterprise-user>
    */
    pub async fn enterprise_admin_update_attribute_for_enterprise_user(
        &self,
        enterprise: &str,
        scim_user_id: &str,
        body: &types::UpdateAttributeScimEnterpriseUserRequest,
    ) -> Result<types::ScimEnterpriseUser> {
        let url = format!(
            "/scim/v2/enterprises/{}/Users/{}",
            progenitor_support::encode_path(&enterprise.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List SCIM provisioned identities.
    *
    * This function performs a `GET` to the `/scim/v2/organizations/{org}/Users` endpoint.
    *
    * Retrieves a paginated list of all provisioned organization members, including pending invitations. If you provide the `filter` parameter, the resources for all matching provisions members are returned.
    *
    * When a user with a SAML-provisioned external identity leaves (or is removed from) an organization, the account's metadata is immediately removed. However, the returned list of user accounts might not always match the organization or enterprise member list you see on GitHub. This can happen in certain cases where an external identity associated with an organization will not match an organization member:
    *   - When a user with a SCIM-provisioned external identity is removed from an organization, the account's metadata is preserved to allow the user to re-join the organization in the future.
    *   - When inviting a user to join an organization, you can expect to see their external identity in the results before they accept the invitation, or if the invitation is cancelled (or never accepted).
    *   - When a user is invited over SCIM, an external identity is created that matches with the invitee's email address. However, this identity is only linked to a user account when the user accepts the invitation by going through SAML SSO.
    *
    * The returned list of external identities can include an entry for a `null` user. These are unlinked SAML identities that are created when a user goes through the following Single Sign-On (SSO) process but does not sign in to their GitHub account after completing SSO:
    *
    * 1. The user is granted access by the IdP and is not a member of the GitHub organization.
    *
    * 1. The user attempts to access the GitHub organization and initiates the SAML SSO process, and is not currently signed in to their GitHub account.
    *
    * 1. After successfully authenticating with the SAML SSO IdP, the `null` external identity entry is created and the user is prompted to sign in to their GitHub account:
    *    - If the user signs in, their GitHub account is linked to this entry.
    *    - If the user does not sign in (or does not create a new account when prompted), they are not added to the GitHub organization, and the external identity `null` entry remains in place.
    *
    * FROM: <https://docs.github.com/rest/reference/scim#list-scim-provisioned-identities>
    */
    pub async fn scim_list_provisioned_identities(
        &self,
        org: &str,
        start_index: i64,
        count: i64,
        filter: &str,
    ) -> Result<types::ScimUserList> {
        let url = format!(
            "/scim/v2/organizations/{}/Users?count={}&filter={}&start_index={}",
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", count),
            filter.to_string(),
            format!("{}", start_index),
        );

        self.get(&url).await
    }

    /**
    * Provision and invite a SCIM user.
    *
    * This function performs a `POST` to the `/scim/v2/organizations/{org}/Users` endpoint.
    *
    * Provision organization membership for a user, and send an activation email to the email address.
    *
    * FROM: <https://docs.github.com/rest/reference/scim#provision-and-invite-a-scim-user>
    */
    pub async fn scim_provision_and_invite_user(
        &self,
        org: &str,
        body: &types::ProvisionandInviteScimUserRequest,
    ) -> Result<types::ScimUser> {
        let url = format!(
            "/scim/v2/organizations/{}/Users",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get SCIM provisioning information for a user.
    *
    * This function performs a `GET` to the `/scim/v2/organizations/{org}/Users/{scim_user_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/scim#get-scim-provisioning-information-for-a-user>
    */
    pub async fn scim_get_provisioning_information_for_user(
        &self,
        org: &str,
        scim_user_id: &str,
    ) -> Result<types::ScimUser> {
        let url = format!(
            "/scim/v2/organizations/{}/Users/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Update a provisioned organization membership.
    *
    * This function performs a `PUT` to the `/scim/v2/organizations/{org}/Users/{scim_user_id}` endpoint.
    *
    * Replaces an existing provisioned user's information. You must provide all the information required for the user as if you were provisioning them for the first time. Any existing user information that you don't provide will be removed. If you want to only update a specific attribute, use the [Update an attribute for a SCIM user](https://docs.github.com/rest/reference/scim#update-an-attribute-for-a-scim-user) endpoint instead.
    *
    * You must at least provide the required values for the user: `userName`, `name`, and `emails`.
    *
    * **Warning:** Setting `active: false` removes the user from the organization, deletes the external identity, and deletes the associated `{scim_user_id}`.
    *
    * FROM: <https://docs.github.com/rest/reference/scim#set-scim-information-for-a-provisioned-user>
    */
    pub async fn scim_set_information_for_provisioned_user(
        &self,
        org: &str,
        scim_user_id: &str,
        body: &types::UpdateProvisionedOrganizationMembershipRequest,
    ) -> Result<types::ScimUser> {
        let url = format!(
            "/scim/v2/organizations/{}/Users/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete a SCIM user from an organization.
    *
    * This function performs a `DELETE` to the `/scim/v2/organizations/{org}/Users/{scim_user_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/scim#delete-a-scim-user-from-an-organization>
    */
    pub async fn scim_delete_user_from_org(&self, org: &str, scim_user_id: &str) -> Result<()> {
        let url = format!(
            "/scim/v2/organizations/{}/Users/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update an attribute for a SCIM user.
    *
    * This function performs a `PATCH` to the `/scim/v2/organizations/{org}/Users/{scim_user_id}` endpoint.
    *
    * Allows you to change a provisioned user's individual attributes. To change a user's values, you must provide a specific `Operations` JSON format that contains at least one of the `add`, `remove`, or `replace` operations. For examples and more information on the SCIM operations format, see the [SCIM specification](https://tools.ietf.org/html/rfc7644#section-3.5.2).
    *
    * **Note:** Complicated SCIM `path` selectors that include filters are not supported. For example, a `path` selector defined as `"path": "emails[type eq \"work\"]"` will not work.
    *
    * **Warning:** If you set `active:false` using the `replace` operation (as shown in the JSON example below), it removes the user from the organization, deletes the external identity, and deletes the associated `:scim_user_id`.
    *
    * ```
    * {
    *   "Operations":[{
    *     "op":"replace",
    *     "value":{
    *       "active":false
    *     }
    *   }]
    * }
    * ```
    *
    * FROM: <https://docs.github.com/rest/reference/scim#update-an-attribute-for-a-scim-user>
    */
    pub async fn scim_update_attribute_for_user(
        &self,
        org: &str,
        scim_user_id: &str,
        body: &types::UpdateAttributeScimUserRequest,
    ) -> Result<types::ScimUser> {
        let url = format!(
            "/scim/v2/organizations/{}/Users/{}",
            progenitor_support::encode_path(&org.to_string()),
            progenitor_support::encode_path(&scim_user_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Search code.
    *
    * This function performs a `GET` to the `/search/code` endpoint.
    *
    * Searches for query terms inside of a file. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
    *
    * When searching for code, you can get text match metadata for the file **content** and file **path** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
    *
    * For example, if you want to find the definition of the `addClass` function inside [jQuery](https://github.com/jquery/jquery) repository, your query would look something like this:
    *
    * `q=addClass+in:file+language:js+repo:jquery/jquery`
    *
    * This query searches for the keyword `addClass` within a file's contents. The query limits the search to files where the language is JavaScript in the `jquery/jquery` repository.
    *
    * #### Considerations for code search
    *
    * Due to the complexity of searching code, there are a few restrictions on how searches are performed:
    *
    * *   Only the _default branch_ is considered. In most cases, this will be the `master` branch.
    * *   Only files smaller than 384 KB are searchable.
    * *   You must always include at least one search term when searching source code. For example, searching for [`language:go`](https://github.com/search?utf8=%E2%9C%93&q=language%3Ago&type=Code) is not valid, while [`amazing
    * language:go`](https://github.com/search?utf8=%E2%9C%93&q=amazing+language%3Ago&type=Code) is.
    *
    * FROM: <https://docs.github.com/rest/reference/search#search-code>
    */
    pub async fn search_code(
        &self,
        q: &str,
        sort: &str,
        order: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetSearchCodeOkResponse> {
        let url = format!(
            "/search/code?order={}&page={}&per_page={}&q={}&sort={}",
            order.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            q.to_string(),
            sort.to_string(),
        );

        self.get(&url).await
    }

    /**
    * Search commits.
    *
    * This function performs a `GET` to the `/search/commits` endpoint.
    *
    * Find commits via various criteria on the default branch (usually `master`). This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
    *
    * When searching for commits, you can get text match metadata for the **message** field when you provide the `text-match` media type. For more details about how to receive highlighted search results, see [Text match
    * metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
    *
    * For example, if you want to find commits related to CSS in the [octocat/Spoon-Knife](https://github.com/octocat/Spoon-Knife) repository. Your query would look something like this:
    *
    * `q=repo:octocat/Spoon-Knife+css`
    *
    * FROM: <https://docs.github.com/rest/reference/search#search-commits>
    */
    pub async fn search_commits(
        &self,
        q: &str,
        sort: &str,
        order: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetSearchCommitsOkResponse> {
        let url = format!(
            "/search/commits?order={}&page={}&per_page={}&q={}&sort={}",
            order.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            q.to_string(),
            sort.to_string(),
        );

        self.get(&url).await
    }

    /**
    * Search issues and pull requests.
    *
    * This function performs a `GET` to the `/search/issues` endpoint.
    *
    * Find issues by state and keyword. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
    *
    * When searching for issues, you can get text match metadata for the issue **title**, issue **body**, and issue **comment body** fields when you pass the `text-match` media type. For more details about how to receive highlighted
    * search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
    *
    * For example, if you want to find the oldest unresolved Python bugs on Windows. Your query might look something like this.
    *
    * `q=windows+label:bug+language:python+state:open&sort=created&order=asc`
    *
    * This query searches for the keyword `windows`, within any open issue that is labeled as `bug`. The search runs across repositories whose primary language is Python. The results are sorted by creation date in ascending order, which means the oldest issues appear first in the search results.
    *
    * **Note:** For [user-to-server](https://docs.github.com/developers/apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests) GitHub App requests, you can't retrieve a combination of issues and pull requests in a single query. Requests that don't include the `is:issue` or `is:pull-request` qualifier will receive an HTTP `422 Unprocessable Entity` response. To get results for both issues and pull requests, you must send separate queries for issues and pull requests. For more information about the `is` qualifier, see "[Searching only issues or pull requests](https://docs.github.com/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests)."
    *
    * FROM: <https://docs.github.com/rest/reference/search#search-issues-and-pull-requests>
    */
    pub async fn search_issues_and_pull_requests(
        &self,
        q: &str,
        sort: &str,
        order: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetSearchIssuesandPullRequestsOkResponse> {
        let url = format!(
            "/search/issues?order={}&page={}&per_page={}&q={}&sort={}",
            order.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            q.to_string(),
            sort.to_string(),
        );

        self.get(&url).await
    }

    /**
    * Search labels.
    *
    * This function performs a `GET` to the `/search/labels` endpoint.
    *
    * Find labels in a repository with names or descriptions that match search keywords. Returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
    *
    * When searching for labels, you can get text match metadata for the label **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
    *
    * For example, if you want to find labels in the `linguist` repository that match `bug`, `defect`, or `enhancement`. Your query might look like this:
    *
    * `q=bug+defect+enhancement&repository_id=64778136`
    *
    * The labels that best match the query appear first in the search results.
    *
    * FROM: <https://docs.github.com/rest/reference/search#search-labels>
    */
    pub async fn search_labels(
        &self,
        repository_id: i64,
        q: &str,
        sort: &str,
        order: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetSearchLabelsOkResponse> {
        let url = format!(
            "/search/labels?order={}&page={}&per_page={}&q={}&repository_id={}&sort={}",
            order.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            q.to_string(),
            format!("{}", repository_id),
            sort.to_string(),
        );

        self.get(&url).await
    }

    /**
    * Search repositories.
    *
    * This function performs a `GET` to the `/search/repositories` endpoint.
    *
    * Find repositories via various criteria. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
    *
    * When searching for repositories, you can get text match metadata for the **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
    *
    * For example, if you want to search for popular Tetris repositories written in assembly code, your query might look like this:
    *
    * `q=tetris+language:assembly&sort=stars&order=desc`
    *
    * This query searches for repositories with the word `tetris` in the name, the description, or the README. The results are limited to repositories where the primary language is assembly. The results are sorted by stars in descending order, so that the most popular repositories appear first in the search results.
    *
    * When you include the `mercy` preview header, you can also search for multiple topics by adding more `topic:` instances. For example, your query might look like this:
    *
    * `q=topic:ruby+topic:rails`
    *
    * FROM: <https://docs.github.com/rest/reference/search#search-repositories>
    */
    pub async fn search_repos(
        &self,
        q: &str,
        sort: &str,
        order: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetSearchRepositoriesOkResponse> {
        let url = format!(
            "/search/repositories?order={}&page={}&per_page={}&q={}&sort={}",
            order.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            q.to_string(),
            sort.to_string(),
        );

        self.get(&url).await
    }

    /**
    * Search topics.
    *
    * This function performs a `GET` to the `/search/topics` endpoint.
    *
    * Find topics via various criteria. Results are sorted by best match. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination). See "[Searching topics](https://help.github.com/articles/searching-topics/)" for a detailed list of qualifiers.
    *
    * When searching for topics, you can get text match metadata for the topic's **short\_description**, **description**, **name**, or **display\_name** field when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
    *
    * For example, if you want to search for topics related to Ruby that are featured on https://github.com/topics. Your query might look like this:
    *
    * `q=ruby+is:featured`
    *
    * This query searches for topics with the keyword `ruby` and limits the results to find only topics that are featured. The topics that are the best match for the query appear first in the search results.
    *
    * FROM: <https://docs.github.com/rest/reference/search#search-topics>
    */
    pub async fn search_topics(
        &self,
        q: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetSearchTopicsOkResponse> {
        let url = format!(
            "/search/topics?page={}&per_page={}&q={}",
            format!("{}", page),
            format!("{}", per_page),
            q.to_string(),
        );

        self.get(&url).await
    }

    /**
    * Search users.
    *
    * This function performs a `GET` to the `/search/users` endpoint.
    *
    * Find users via various criteria. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
    *
    * When searching for users, you can get text match metadata for the issue **login**, **email**, and **name** fields when you pass the `text-match` media type. For more details about highlighting search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata). For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
    *
    * For example, if you're looking for a list of popular users, you might try this query:
    *
    * `q=tom+repos:%3E42+followers:%3E1000`
    *
    * This query searches for users with the name `tom`. The results are restricted to users with more than 42 repositories and over 1,000 followers.
    *
    * FROM: <https://docs.github.com/rest/reference/search#search-users>
    */
    pub async fn search_users(
        &self,
        q: &str,
        sort: &str,
        order: &str,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetSearchUsersOkResponse> {
        let url = format!(
            "/search/users?order={}&page={}&per_page={}&q={}&sort={}",
            order.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            q.to_string(),
            sort.to_string(),
        );

        self.get(&url).await
    }

    /**
    * Get a team (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the [Get a team by name](https://docs.github.com/rest/reference/teams#get-a-team-by-name) endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/teams/#get-a-team-legacy>
    */
    pub async fn teams_get_legacy(&self, team_id: i64) -> Result<types::TeamFull> {
        let url = format!(
            "/teams/{}",
            progenitor_support::encode_path(&team_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a team (Legacy).
    *
    * This function performs a `DELETE` to the `/teams/{team_id}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a team](https://docs.github.com/rest/reference/teams#delete-a-team) endpoint.
    *
    * To delete a team, the authenticated user must be an organization owner or team maintainer.
    *
    * If you are an organization owner, deleting a parent team will delete all of its child teams as well.
    *
    * FROM: <https://docs.github.com/rest/reference/teams/#delete-a-team-legacy>
    */
    pub async fn teams_delete_legacy(&self, team_id: i64) -> Result<()> {
        let url = format!(
            "/teams/{}",
            progenitor_support::encode_path(&team_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a team (Legacy).
    *
    * This function performs a `PATCH` to the `/teams/{team_id}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a team](https://docs.github.com/rest/reference/teams#update-a-team) endpoint.
    *
    * To edit a team, the authenticated user must either be an organization owner or a team maintainer.
    *
    * **Note:** With nested teams, the `privacy` for parent teams cannot be `secret`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams/#update-a-team-legacy>
    */
    pub async fn teams_update_legacy(
        &self,
        team_id: i64,
        body: &types::UpdateTeamRequest,
    ) -> Result<types::TeamFull> {
        let url = format!(
            "/teams/{}",
            progenitor_support::encode_path(&team_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List discussions (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/discussions` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List discussions`](https://docs.github.com/rest/reference/teams#list-discussions) endpoint.
    *
    * List all discussions on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-discussions-legacy>
    */
    pub async fn teams_list_discussions_legacy(
        &self,
        team_id: i64,
        direction: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::TeamDiscussion>> {
        let url = format!(
            "/teams/{}/discussions?direction={}&page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            direction.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a discussion (Legacy).
    *
    * This function performs a `POST` to the `/teams/{team_id}/discussions` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create a discussion`](https://docs.github.com/rest/reference/teams#create-a-discussion) endpoint.
    *
    * Creates a new discussion post on a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#create-a-discussion-legacy>
    */
    pub async fn teams_create_discussion_legacy(
        &self,
        team_id: i64,
        body: &types::CreateDiscussionRequest,
    ) -> Result<types::TeamDiscussion> {
        let url = format!(
            "/teams/{}/discussions",
            progenitor_support::encode_path(&team_id.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a discussion (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/discussions/{discussion_number}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion](https://docs.github.com/rest/reference/teams#get-a-discussion) endpoint.
    *
    * Get a specific discussion on a team's page. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/teams#get-a-discussion-legacy>
    */
    pub async fn teams_get_discussion_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
    ) -> Result<types::TeamDiscussion> {
        let url = format!(
            "/teams/{}/discussions/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a discussion (Legacy).
    *
    * This function performs a `DELETE` to the `/teams/{team_id}/discussions/{discussion_number}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Delete a discussion`](https://docs.github.com/rest/reference/teams#delete-a-discussion) endpoint.
    *
    * Delete a discussion from a team's page. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/teams#delete-a-discussion-legacy>
    */
    pub async fn teams_delete_discussion_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
    ) -> Result<()> {
        let url = format!(
            "/teams/{}/discussions/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a discussion (Legacy).
    *
    * This function performs a `PATCH` to the `/teams/{team_id}/discussions/{discussion_number}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion](https://docs.github.com/rest/reference/teams#update-a-discussion) endpoint.
    *
    * Edits the title and body text of a discussion post. Only the parameters you provide are updated. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/teams#update-a-discussion-legacy>
    */
    pub async fn teams_update_discussion_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        body: &types::UpdateDiscussionRequest,
    ) -> Result<types::TeamDiscussion> {
        let url = format!(
            "/teams/{}/discussions/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List discussion comments (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/discussions/{discussion_number}/comments` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [List discussion comments](https://docs.github.com/rest/reference/teams#list-discussion-comments) endpoint.
    *
    * List all comments on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-discussion-comments-legacy>
    */
    pub async fn teams_list_discussion_comments_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        direction: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::TeamDiscussionComment>> {
        let url = format!(
            "/teams/{}/discussions/{}/comments?direction={}&page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            direction.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a discussion comment (Legacy).
    *
    * This function performs a `POST` to the `/teams/{team_id}/discussions/{discussion_number}/comments` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Create a discussion comment](https://docs.github.com/rest/reference/teams#create-a-discussion-comment) endpoint.
    *
    * Creates a new comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in abuse rate limiting. See "[Abuse rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#abuse-rate-limits)" and "[Dealing with abuse rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-rate-limits)" for details.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#create-a-discussion-comment-legacy>
    */
    pub async fn teams_create_discussion_comment_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        body: &types::CreateDiscussionCommentRequest,
    ) -> Result<types::TeamDiscussionComment> {
        let url = format!(
            "/teams/{}/discussions/{}/comments",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a discussion comment (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get a discussion comment](https://docs.github.com/rest/reference/teams#get-a-discussion-comment) endpoint.
    *
    * Get a specific comment on a team discussion. OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/teams#get-a-discussion-comment-legacy>
    */
    pub async fn teams_get_discussion_comment_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        comment_number: i64,
    ) -> Result<types::TeamDiscussionComment> {
        let url = format!(
            "/teams/{}/discussions/{}/comments/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a discussion comment (Legacy).
    *
    * This function performs a `DELETE` to the `/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Delete a discussion comment](https://docs.github.com/rest/reference/teams#delete-a-discussion-comment) endpoint.
    *
    * Deletes a comment on a team discussion. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/teams#delete-a-discussion-comment-legacy>
    */
    pub async fn teams_delete_discussion_comment_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        comment_number: i64,
    ) -> Result<()> {
        let url = format!(
            "/teams/{}/discussions/{}/comments/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Update a discussion comment (Legacy).
    *
    * This function performs a `PATCH` to the `/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Update a discussion comment](https://docs.github.com/rest/reference/teams#update-a-discussion-comment) endpoint.
    *
    * Edits the body text of a discussion comment. OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/teams#update-a-discussion-comment-legacy>
    */
    pub async fn teams_update_discussion_comment_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        comment_number: i64,
        body: &types::UpdateDiscussionCommentRequest,
    ) -> Result<types::TeamDiscussionComment> {
        let url = format!(
            "/teams/{}/discussions/{}/comments/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List reactions for a team discussion comment (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion comment`](https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion-comment) endpoint.
    *
    * List the reactions to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/reactions/#list-reactions-for-a-team-discussion-comment-legacy>
    */
    pub async fn reactions_list_for_team_discussion_comment_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        comment_number: i64,
        content: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/teams/{}/discussions/{}/comments/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
            content.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create reaction for a team discussion comment (Legacy).
    *
    * This function performs a `POST` to the `/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Create reaction for a team discussion comment](https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion-comment)" endpoint.
    *
    * Create a reaction to a [team discussion comment](https://docs.github.com/rest/reference/teams#discussion-comments). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.
    *
    * FROM: <https://docs.github.com/rest/reference/reactions/#create-reaction-for-a-team-discussion-comment-legacy>
    */
    pub async fn reactions_create_for_team_discussion_comment_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        comment_number: i64,
        body: &types::CreateReactionTeamDiscussionCommentRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/teams/{}/discussions/{}/comments/{}/reactions",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            progenitor_support::encode_path(&comment_number.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List reactions for a team discussion (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/discussions/{discussion_number}/reactions` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion`](https://docs.github.com/rest/reference/reactions#list-reactions-for-a-team-discussion) endpoint.
    *
    * List the reactions to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `read:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/reactions/#list-reactions-for-a-team-discussion-legacy>
    */
    pub async fn reactions_list_for_team_discussion_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        content: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Reaction>> {
        let url = format!(
            "/teams/{}/discussions/{}/reactions?content={}&page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
            content.to_string(),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create reaction for a team discussion (Legacy).
    *
    * This function performs a `POST` to the `/teams/{team_id}/discussions/{discussion_number}/reactions` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create reaction for a team discussion`](https://docs.github.com/rest/reference/reactions#create-reaction-for-a-team-discussion) endpoint.
    *
    * Create a reaction to a [team discussion](https://docs.github.com/rest/reference/teams#discussions). OAuth access tokens require the `write:discussion` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). A response with an HTTP `200` status means that you already added the reaction type to this team discussion.
    *
    * FROM: <https://docs.github.com/rest/reference/reactions/#create-reaction-for-a-team-discussion-legacy>
    */
    pub async fn reactions_create_for_team_discussion_legacy(
        &self,
        team_id: i64,
        discussion_number: i64,
        body: &types::CreateReactionTeamDiscussionRequest,
    ) -> Result<types::Reaction> {
        let url = format!(
            "/teams/{}/discussions/{}/reactions",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&discussion_number.to_string()),
        );

        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List pending team invitations (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/invitations` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List pending team invitations`](https://docs.github.com/rest/reference/teams#list-pending-team-invitations) endpoint.
    *
    * The return hash contains a `role` field which refers to the Organization Invitation role and will be one of the following values: `direct_member`, `admin`, `billing_manager`, `hiring_manager`, or `reinstate`. If the invitee is not a GitHub member, the `login` field in the return hash will be `null`.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-pending-team-invitations-legacy>
    */
    pub async fn teams_list_pending_invitations_legacy(
        &self,
        team_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::OrganizationInvitation>> {
        let url = format!(
            "/teams/{}/invitations?page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List team members (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/members` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List team members`](https://docs.github.com/rest/reference/teams#list-team-members) endpoint.
    *
    * Team members will include the members of child teams.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-team-members-legacy>
    */
    pub async fn teams_list_members_legacy(
        &self,
        team_id: i64,
        role: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/teams/{}/members?page={}&per_page={}&role={}",
            progenitor_support::encode_path(&team_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            role.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get team member (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/members/{username}` endpoint.
    *
    * The "Get team member" endpoint (described below) is deprecated.
    *
    * We recommend using the [Get team membership for a user](https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user) endpoint instead. It allows you to get both active and pending memberships.
    *
    * To list members in a team, the team must be visible to the authenticated user.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#get-team-member-legacy>
    */
    pub async fn teams_get_member_legacy(&self, team_id: i64, username: &str) -> Result<()> {
        let url = format!(
            "/teams/{}/members/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Add team member (Legacy).
    *
    * This function performs a `PUT` to the `/teams/{team_id}/members/{username}` endpoint.
    *
    * The "Add team member" endpoint (described below) is deprecated.
    *
    * We recommend using the [Add or update team membership for a user](https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint instead. It allows you to invite new organization members to your teams.
    *
    * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * To add someone to a team, the authenticated user must be an organization owner or a team maintainer in the team they're changing. The person being added to the team must be a member of the team's organization.
    *
    * **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://help.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
    *
    * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
    *
    * FROM: <https://docs.github.com/rest/reference/teams#add-team-member-legacy>
    */
    pub async fn teams_add_member_legacy(&self, team_id: i64, username: &str) -> Result<()> {
        let url = format!(
            "/teams/{}/members/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Remove team member (Legacy).
    *
    * This function performs a `DELETE` to the `/teams/{team_id}/members/{username}` endpoint.
    *
    * The "Remove team member" endpoint (described below) is deprecated.
    *
    * We recommend using the [Remove team membership for a user](https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user) endpoint instead. It allows you to remove both active and pending memberships.
    *
    * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * To remove a team member, the authenticated user must have 'admin' permissions to the team or be an owner of the org that the team is associated with. Removing a team member does not delete the user, it just removes them from the team.
    *
    * **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://help.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
    *
    * FROM: <https://docs.github.com/rest/reference/teams#remove-team-member-legacy>
    */
    pub async fn teams_remove_member_legacy(&self, team_id: i64, username: &str) -> Result<()> {
        let url = format!(
            "/teams/{}/members/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get team membership for a user (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/memberships/{username}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Get team membership for a user](https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user) endpoint.
    *
    * Team members will include the members of child teams.
    *
    * To get a user's membership with a team, the team must be visible to the authenticated user.
    *
    * **Note:**
    * The response contains the `state` of the membership and the member's `role`.
    *
    * The `role` for organization owners is set to `maintainer`. For more information about `maintainer` roles, see [Create a team](https://docs.github.com/rest/reference/teams#create-a-team).
    *
    * FROM: <https://docs.github.com/rest/reference/teams#get-team-membership-for-a-user-legacy>
    */
    pub async fn teams_get_membership_for_user_legacy(
        &self,
        team_id: i64,
        username: &str,
    ) -> Result<types::TeamMembership> {
        let url = format!(
            "/teams/{}/memberships/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Add or update team membership for a user (Legacy).
    *
    * This function performs a `PUT` to the `/teams/{team_id}/memberships/{username}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Add or update team membership for a user](https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user) endpoint.
    *
    * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * If the user is already a member of the team's organization, this endpoint will add the user to the team. To add a membership between an organization member and a team, the authenticated user must be an organization owner or a team maintainer.
    *
    * **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://help.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
    *
    * If the user is unaffiliated with the team's organization, this endpoint will send an invitation to the user via email. This newly-created membership will be in the "pending" state until the user accepts the invitation, at which point the membership will transition to the "active" state and the user will be added as a member of the team. To add a membership between an unaffiliated user and a team, the authenticated user must be an organization owner.
    *
    * If the user is already a member of the team, this endpoint will update the role of the team member's role. To update the membership of a team member, the authenticated user must be an organization owner or a team maintainer.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#add-or-update-team-membership-for-a-user-legacy>
    */
    pub async fn teams_add_or_update_membership_for_user_legacy(
        &self,
        team_id: i64,
        username: &str,
        body: &types::AddUpdateTeamMembershipUserRequest,
    ) -> Result<types::TeamMembership> {
        let url = format!(
            "/teams/{}/memberships/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove team membership for a user (Legacy).
    *
    * This function performs a `DELETE` to the `/teams/{team_id}/memberships/{username}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove team membership for a user](https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user) endpoint.
    *
    * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * To remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. Removing team membership does not delete the user, it just removes their membership from the team.
    *
    * **Note:** When you have team synchronization set up for a team with your organization's identity provider (IdP), you will see an error if you attempt to use the API for making changes to the team's membership. If you have access to manage group membership in your IdP, you can manage GitHub team membership through your identity provider, which automatically adds and removes team members in an organization. For more information, see "[Synchronizing teams between your identity provider and GitHub](https://help.github.com/articles/synchronizing-teams-between-your-identity-provider-and-github/)."
    *
    * FROM: <https://docs.github.com/rest/reference/teams#remove-team-membership-for-a-user-legacy>
    */
    pub async fn teams_remove_membership_for_user_legacy(
        &self,
        team_id: i64,
        username: &str,
    ) -> Result<()> {
        let url = format!(
            "/teams/{}/memberships/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List team projects (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/projects` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List team projects`](https://docs.github.com/rest/reference/teams#list-team-projects) endpoint.
    *
    * Lists the organization projects for a team.
    *
    * FROM: <https://docs.github.com/rest/reference/teams/#list-team-projects-legacy>
    */
    pub async fn teams_list_projects_legacy(
        &self,
        team_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::TeamProject>> {
        let url = format!(
            "/teams/{}/projects?page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Check team permissions for a project (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/projects/{project_id}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a project](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-project) endpoint.
    *
    * Checks whether a team has `read`, `write`, or `admin` permissions for an organization project. The response includes projects inherited from a parent team.
    *
    * FROM: <https://docs.github.com/rest/reference/teams/#check-team-permissions-for-a-project-legacy>
    */
    pub async fn teams_check_permissions_for_project_legacy(
        &self,
        team_id: i64,
        project_id: i64,
    ) -> Result<types::TeamProject> {
        let url = format!(
            "/teams/{}/projects/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Add or update team project permissions (Legacy).
    *
    * This function performs a `PUT` to the `/teams/{team_id}/projects/{project_id}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Add or update team project permissions](https://docs.github.com/rest/reference/teams#add-or-update-team-project-permissions) endpoint.
    *
    * Adds an organization project to a team. To add a project to a team or update the team's permission on a project, the authenticated user must have `admin` permissions for the project. The project and team must be part of the same organization.
    *
    * FROM: <https://docs.github.com/rest/reference/teams/#add-or-update-team-project-permissions-legacy>
    */
    pub async fn teams_add_or_update_project_permissions_legacy(
        &self,
        team_id: i64,
        project_id: i64,
        body: &types::AddUpdateTeamProjectPermissionsRequest,
    ) -> Result<()> {
        let url = format!(
            "/teams/{}/projects/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove a project from a team (Legacy).
    *
    * This function performs a `DELETE` to the `/teams/{team_id}/projects/{project_id}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove a project from a team](https://docs.github.com/rest/reference/teams#remove-a-project-from-a-team) endpoint.
    *
    * Removes an organization project from a team. An organization owner or a team maintainer can remove any project from the team. To remove a project from a team as an organization member, the authenticated user must have `read` access to both the team and project, or `admin` access to the team or project. **Note:** This endpoint removes the project from the team, but does not delete it.
    *
    * FROM: <https://docs.github.com/rest/reference/teams/#remove-a-project-from-a-team-legacy>
    */
    pub async fn teams_remove_project_legacy(&self, team_id: i64, project_id: i64) -> Result<()> {
        let url = format!(
            "/teams/{}/projects/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&project_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List team repositories (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/repos` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [List team repositories](https://docs.github.com/rest/reference/teams#list-team-repositories) endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/teams/#list-team-repositories-legacy>
    */
    pub async fn teams_list_repos_legacy(
        &self,
        team_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/teams/{}/repos?page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Check team permissions for a repository (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/repos/{owner}/{repo}` endpoint.
    *
    * **Note**: Repositories inherited through a parent team will also be checked.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a repository](https://docs.github.com/rest/reference/teams#check-team-permissions-for-a-repository) endpoint.
    *
    * You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:
    *
    * FROM: <https://docs.github.com/rest/reference/teams/#check-team-permissions-for-a-repository-legacy>
    */
    pub async fn teams_check_permissions_for_repo_legacy(
        &self,
        team_id: i64,
        owner: &str,
        repo: &str,
    ) -> Result<types::TeamRepository> {
        let url = format!(
            "/teams/{}/repos/{}/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Add or update team repository permissions (Legacy).
    *
    * This function performs a `PUT` to the `/teams/{team_id}/repos/{owner}/{repo}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Add or update team repository permissions](https://docs.github.com/rest/reference/teams#add-or-update-team-repository-permissions)" endpoint.
    *
    * To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is not owned by the organization.
    *
    * Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
    *
    * FROM: <https://docs.github.com/rest/reference/teams/#add-or-update-team-repository-permissions-legacy>
    */
    pub async fn teams_add_or_update_repo_permissions_legacy(
        &self,
        team_id: i64,
        owner: &str,
        repo: &str,
        body: &types::AddUpdateTeamRepositoryPermissionsRequest,
    ) -> Result<()> {
        let url = format!(
            "/teams/{}/repos/{}/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove a repository from a team (Legacy).
    *
    * This function performs a `DELETE` to the `/teams/{team_id}/repos/{owner}/{repo}` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Remove a repository from a team](https://docs.github.com/rest/reference/teams#remove-a-repository-from-a-team) endpoint.
    *
    * If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. NOTE: This does not delete the repository, it just removes it from the team.
    *
    * FROM: <https://docs.github.com/rest/reference/teams/#remove-a-repository-from-a-team-legacy>
    */
    pub async fn teams_remove_repo_legacy(
        &self,
        team_id: i64,
        owner: &str,
        repo: &str,
    ) -> Result<()> {
        let url = format!(
            "/teams/{}/repos/{}/{}",
            progenitor_support::encode_path(&team_id.to_string()),
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List IdP groups for a team (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/team-sync/group-mappings` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List IdP groups for a team`](https://docs.github.com/rest/reference/teams#list-idp-groups-for-a-team) endpoint.
    *
    * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * List IdP groups connected to a team on GitHub.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-idp-groups-for-a-team-legacy>
    */
    pub async fn teams_list_idp_groups_for_legacy(
        &self,
        team_id: i64,
    ) -> Result<types::GroupMapping> {
        let url = format!(
            "/teams/{}/team-sync/group-mappings",
            progenitor_support::encode_path(&team_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Create or update IdP group connections (Legacy).
    *
    * This function performs a `PATCH` to the `/teams/{team_id}/team-sync/group-mappings` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create or update IdP group connections`](https://docs.github.com/rest/reference/teams#create-or-update-idp-group-connections) endpoint.
    *
    * Team synchronization is available for organizations using GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    *
    * Creates, updates, or removes a connection between a team and an IdP group. When adding groups to a team, you must include all new and existing groups to avoid replacing existing groups with the new ones. Specifying an empty `groups` array will remove all connections for a team.
    *
    * FROM: <https://docs.github.com/rest/reference/teams#create-or-update-idp-group-connections-legacy>
    */
    pub async fn teams_create_or_update_idp_group_connections_legacy(
        &self,
        team_id: i64,
        body: &types::CreateUpdateIdpGroupConnectionsRequest,
    ) -> Result<types::GroupMapping> {
        let url = format!(
            "/teams/{}/team-sync/group-mappings",
            progenitor_support::encode_path(&team_id.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List child teams (Legacy).
    *
    * This function performs a `GET` to the `/teams/{team_id}/teams` endpoint.
    *
    * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List child teams`](https://docs.github.com/rest/reference/teams#list-child-teams) endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/teams/#list-child-teams-legacy>
    */
    pub async fn teams_list_child_legacy(
        &self,
        team_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Team>> {
        let url = format!(
            "/teams/{}/teams?page={}&per_page={}",
            progenitor_support::encode_path(&team_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get the authenticated user.
    *
    * This function performs a `GET` to the `/user` endpoint.
    *
    * If the authenticated user is authenticated through basic authentication or OAuth with the `user` scope, then the response lists public and private profile information.
    *
    * If the authenticated user is authenticated through OAuth without the `user` scope, then the response lists only public profile information.
    *
    * FROM: <https://docs.github.com/rest/reference/users#get-the-authenticated-user>
    */
    pub async fn users_get_authenticated(&self) -> Result<types::GetOkResponse> {
        let url = "/user".to_string();
        self.get(&url).await
    }

    /**
    * Update the authenticated user.
    *
    * This function performs a `PATCH` to the `/user` endpoint.
    *
    * **Note:** If your email is set to private and you send an `email` parameter as part of this request to update your profile, your privacy settings are still enforced: the email address will not be displayed on your public profile or via the API.
    *
    * FROM: <https://docs.github.com/rest/reference/users/#update-the-authenticated-user>
    */
    pub async fn users_update_authenticated(
        &self,
        body: &types::UpdateRequest,
    ) -> Result<types::PrivateUser> {
        let url = "/user".to_string();
        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List users blocked by the authenticated user.
    *
    * This function performs a `GET` to the `/user/blocks` endpoint.
    *
    * List the users you've blocked on your personal account.
    *
    * FROM: <https://docs.github.com/rest/reference/users#list-users-blocked-by-the-authenticated-user>
    */
    pub async fn users_list_blocked_by_authenticated(&self) -> Result<Vec<types::SimpleUser>> {
        let url = "/user/blocks".to_string();
        self.get_all_pages(&url).await
    }

    /**
    * Check if a user is blocked by the authenticated user.
    *
    * This function performs a `GET` to the `/user/blocks/{username}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/users#check-if-a-user-is-blocked-by-the-authenticated-user>
    */
    pub async fn users_check_blocked(&self, username: &str) -> Result<()> {
        let url = format!(
            "/user/blocks/{}",
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Block a user.
    *
    * This function performs a `PUT` to the `/user/blocks/{username}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/users#block-a-user>
    */
    pub async fn users_block(&self, username: &str) -> Result<()> {
        let url = format!(
            "/user/blocks/{}",
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Unblock a user.
    *
    * This function performs a `DELETE` to the `/user/blocks/{username}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/users#unblock-a-user>
    */
    pub async fn users_unblock(&self, username: &str) -> Result<()> {
        let url = format!(
            "/user/blocks/{}",
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Set primary email visibility for the authenticated user.
    *
    * This function performs a `PATCH` to the `/user/email/visibility` endpoint.
    *
    * Sets the visibility for your primary email addresses.
    *
    * FROM: <https://docs.github.com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user>
    */
    pub async fn users_set_primary_email_visibility_for_authenticated(
        &self,
        body: &types::SetPrimaryEmailVisibilityRequest,
    ) -> Result<Vec<types::Email>> {
        let url = "/user/email/visibility".to_string();
        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List email addresses for the authenticated user.
    *
    * This function performs a `GET` to the `/user/emails` endpoint.
    *
    * Lists all of your email addresses, and specifies which one is visible to the public. This endpoint is accessible with the `user:email` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/users#list-email-addresses-for-the-authenticated-user>
    */
    pub async fn users_list_emails_for_authenticated(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Email>> {
        let url = format!(
            "/user/emails?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Add an email address for the authenticated user.
    *
    * This function performs a `POST` to the `/user/emails` endpoint.
    *
    * This endpoint is accessible with the `user` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/users#add-an-email-address-for-the-authenticated-user>
    */
    pub async fn users_add_email_for_authenticated(
        &self,
        body: &types::AddEmailAddressRequest,
    ) -> Result<Vec<types::Email>> {
        let url = "/user/emails".to_string();
        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Delete an email address for the authenticated user.
    *
    * This function performs a `DELETE` to the `/user/emails` endpoint.
    *
    * This endpoint is accessible with the `user` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/users#delete-an-email-address-for-the-authenticated-user>
    */
    pub async fn users_delete_email_for_authenticated(
        &self,
        body: &types::DeleteEmailAddressRequest,
    ) -> Result<()> {
        let url = "/user/emails".to_string();
        self.delete(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List followers of the authenticated user.
    *
    * This function performs a `GET` to the `/user/followers` endpoint.
    *
    * Lists the people following the authenticated user.
    *
    * FROM: <https://docs.github.com/rest/reference/users#list-followers-of-the-authenticated-user>
    */
    pub async fn users_list_followers_for_authenticated_user(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/user/followers?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List the people the authenticated user follows.
    *
    * This function performs a `GET` to the `/user/following` endpoint.
    *
    * Lists the people who the authenticated user follows.
    *
    * FROM: <https://docs.github.com/rest/reference/users#list-the-people-the-authenticated-user-follows>
    */
    pub async fn users_list_followed_by_authenticated(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/user/following?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Check if a person is followed by the authenticated user.
    *
    * This function performs a `GET` to the `/user/following/{username}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/users#check-if-a-person-is-followed-by-the-authenticated-user>
    */
    pub async fn users_check_person_is_followed_by_authenticated(
        &self,
        username: &str,
    ) -> Result<()> {
        let url = format!(
            "/user/following/{}",
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Follow a user.
    *
    * This function performs a `PUT` to the `/user/following/{username}` endpoint.
    *
    * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
    *
    * Following a user requires the user to be logged in and authenticated with basic auth or OAuth with the `user:follow` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/users#follow-a-user>
    */
    pub async fn users_follow(&self, username: &str) -> Result<()> {
        let url = format!(
            "/user/following/{}",
            progenitor_support::encode_path(&username.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Unfollow a user.
    *
    * This function performs a `DELETE` to the `/user/following/{username}` endpoint.
    *
    * Unfollowing a user requires the user to be logged in and authenticated with basic auth or OAuth with the `user:follow` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/users#unfollow-a-user>
    */
    pub async fn users_unfollow(&self, username: &str) -> Result<()> {
        let url = format!(
            "/user/following/{}",
            progenitor_support::encode_path(&username.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List GPG keys for the authenticated user.
    *
    * This function performs a `GET` to the `/user/gpg_keys` endpoint.
    *
    * Lists the current user's GPG keys. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/users#list-gpg-keys-for-the-authenticated-user>
    */
    pub async fn users_list_gpg_keys_for_authenticated(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::GpgKey>> {
        let url = format!(
            "/user/gpg_keys?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a GPG key for the authenticated user.
    *
    * This function performs a `POST` to the `/user/gpg_keys` endpoint.
    *
    * Adds a GPG key to the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth, or OAuth with at least `write:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/users#create-a-gpg-key-for-the-authenticated-user>
    */
    pub async fn users_create_gpg_key_for_authenticated(
        &self,
        body: &types::CreateGpgKeyRequest,
    ) -> Result<types::GpgKey> {
        let url = "/user/gpg_keys".to_string();
        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a GPG key for the authenticated user.
    *
    * This function performs a `GET` to the `/user/gpg_keys/{gpg_key_id}` endpoint.
    *
    * View extended details for a single GPG key. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/users#get-a-gpg-key-for-the-authenticated-user>
    */
    pub async fn users_get_gpg_key_for_authenticated(
        &self,
        gpg_key_id: i64,
    ) -> Result<types::GpgKey> {
        let url = format!(
            "/user/gpg_keys/{}",
            progenitor_support::encode_path(&gpg_key_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a GPG key for the authenticated user.
    *
    * This function performs a `DELETE` to the `/user/gpg_keys/{gpg_key_id}` endpoint.
    *
    * Removes a GPG key from the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:gpg_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/users#delete-a-gpg-key-for-the-authenticated-user>
    */
    pub async fn users_delete_gpg_key_for_authenticated(&self, gpg_key_id: i64) -> Result<()> {
        let url = format!(
            "/user/gpg_keys/{}",
            progenitor_support::encode_path(&gpg_key_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List app installations accessible to the user access token.
    *
    * This function performs a `GET` to the `/user/installations` endpoint.
    *
    * Lists installations of your GitHub App that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
    *
    * You must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.
    *
    * The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
    *
    * You can find the permissions for the installation under the `permissions` key.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#list-app-installations-accessible-to-the-user-access-token>
    */
    pub async fn apps_list_installations_for_authenticated_user(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListAppInstallationsAccessibleUserAccessTokenOkResponse> {
        let url = format!(
            "/user/installations?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * List repositories accessible to the user access token.
    *
    * This function performs a `GET` to the `/user/installations/{installation_id}/repositories` endpoint.
    *
    * List repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access for an installation.
    *
    * The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
    *
    * You must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.
    *
    * The access the user has to each repository is included in the hash under the `permissions` key.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#list-repositories-accessible-to-the-user-access-token>
    */
    pub async fn apps_list_installation_repos_for_authenticated_user(
        &self,
        installation_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<types::GetListRepositoriesAccessibleUserAccessTokenOkResponse> {
        let url = format!(
            "/user/installations/{}/repositories?page={}&per_page={}",
            progenitor_support::encode_path(&installation_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get(&url).await
    }

    /**
    * Add a repository to an app installation.
    *
    * This function performs a `PUT` to the `/user/installations/{installation_id}/repositories/{repository_id}` endpoint.
    *
    * Add a single repository to an installation. The authenticated user must have admin access to the repository.
    *
    * You must use a personal access token (which you can create via the [command line](https://docs.github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#add-a-repository-to-an-app-installation>
    */
    pub async fn apps_add_repo_to_installation(
        &self,
        installation_id: i64,
        repository_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/user/installations/{}/repositories/{}",
            progenitor_support::encode_path(&installation_id.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Remove a repository from an app installation.
    *
    * This function performs a `DELETE` to the `/user/installations/{installation_id}/repositories/{repository_id}` endpoint.
    *
    * Remove a single repository from an installation. The authenticated user must have admin access to the repository.
    *
    * You must use a personal access token (which you can create via the [command line](https://docs.github.com/github/authenticating-to-github/creating-a-personal-access-token) or [Basic Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#remove-a-repository-from-an-app-installation>
    */
    pub async fn apps_remove_repo_from_installation(
        &self,
        installation_id: i64,
        repository_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/user/installations/{}/repositories/{}",
            progenitor_support::encode_path(&installation_id.to_string()),
            progenitor_support::encode_path(&repository_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Get interaction restrictions for your public repositories.
    *
    * This function performs a `GET` to the `/user/interaction-limits` endpoint.
    *
    * Shows which type of GitHub user can interact with your public repositories and when the restriction expires.
    *
    * FROM: <https://docs.github.com/rest/reference/interactions#get-interaction-restrictions-for-your-public-repositories>
    */
    pub async fn interactions_get_restrictions_for_authenticated_user(
        &self,
    ) -> Result<types::GetInteractionRestrictionsPublicRepositoriesOkResponse> {
        let url = "/user/interaction-limits".to_string();
        self.get(&url).await
    }

    /**
    * Set interaction restrictions for your public repositories.
    *
    * This function performs a `PUT` to the `/user/interaction-limits` endpoint.
    *
    * Temporarily restricts which type of GitHub user can interact with your public repositories. Setting the interaction limit at the user level will overwrite any interaction limits that are set for individual repositories owned by the user.
    *
    * FROM: <https://docs.github.com/rest/reference/interactions#set-interaction-restrictions-for-your-public-repositories>
    */
    pub async fn interactions_set_restrictions_for_authenticated_user(
        &self,
        body: &types::InteractionLimit,
    ) -> Result<types::InteractionLimitResponse> {
        let url = "/user/interaction-limits".to_string();
        self.put(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Remove interaction restrictions from your public repositories.
    *
    * This function performs a `DELETE` to the `/user/interaction-limits` endpoint.
    *
    * Removes any interaction restrictions from your public repositories.
    *
    * FROM: <https://docs.github.com/rest/reference/interactions#remove-interaction-restrictions-from-your-public-repositories>
    */
    pub async fn interactions_remove_restrictions_for_authenticated_user(&self) -> Result<()> {
        let url = "/user/interaction-limits".to_string();
        self.delete(&url, None).await
    }

    /**
    * List user account issues assigned to the authenticated user.
    *
    * This function performs a `GET` to the `/user/issues` endpoint.
    *
    * List issues across owned and member repositories assigned to the authenticated user.
    *
    * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
    * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
    * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
    * request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/issues#list-user-account-issues-assigned-to-the-authenticated-user>
    */
    pub async fn issues_list_for_authenticated_user(
        &self,
        filter: &str,
        state: &str,
        labels: &str,
        sort: &str,
        direction: &str,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Issue>> {
        let url = format!("/user/issues?direction={}&filter={}&labels={}&page={}&per_page={}&since={}&sort={}&state={}",
direction.to_string(), filter.to_string(), labels.to_string(), format!("{}", page), format!("{}", per_page), since.to_rfc3339(), sort.to_string(), state.to_string(),         );

        self.get_all_pages(&url).await
    }

    /**
    * List public SSH keys for the authenticated user.
    *
    * This function performs a `GET` to the `/user/keys` endpoint.
    *
    * Lists the public SSH keys for the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/users#list-public-ssh-keys-for-the-authenticated-user>
    */
    pub async fn users_list_public_ssh_keys_for_authenticated(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Key>> {
        let url = format!(
            "/user/keys?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Create a public SSH key for the authenticated user.
    *
    * This function performs a `POST` to the `/user/keys` endpoint.
    *
    * Adds a public SSH key to the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth, or OAuth with at least `write:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/users#create-a-public-ssh-key-for-the-authenticated-user>
    */
    pub async fn users_create_public_ssh_key_for_authenticated(
        &self,
        body: &types::CreatePublicSshKeyRequest,
    ) -> Result<types::Key> {
        let url = "/user/keys".to_string();
        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a public SSH key for the authenticated user.
    *
    * This function performs a `GET` to the `/user/keys/{key_id}` endpoint.
    *
    * View extended details for a single public SSH key. Requires that you are authenticated via Basic Auth or via OAuth with at least `read:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/users#get-a-public-ssh-key-for-the-authenticated-user>
    */
    pub async fn users_get_public_ssh_key_for_authenticated(
        &self,
        key_id: i64,
    ) -> Result<types::Key> {
        let url = format!(
            "/user/keys/{}",
            progenitor_support::encode_path(&key_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a public SSH key for the authenticated user.
    *
    * This function performs a `DELETE` to the `/user/keys/{key_id}` endpoint.
    *
    * Removes a public SSH key from the authenticated user's GitHub account. Requires that you are authenticated via Basic Auth or via OAuth with at least `admin:public_key` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/users#delete-a-public-ssh-key-for-the-authenticated-user>
    */
    pub async fn users_delete_public_ssh_key_for_authenticated(&self, key_id: i64) -> Result<()> {
        let url = format!(
            "/user/keys/{}",
            progenitor_support::encode_path(&key_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List subscriptions for the authenticated user.
    *
    * This function performs a `GET` to the `/user/marketplace_purchases` endpoint.
    *
    * Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/apps#list-subscriptions-for-the-authenticated-user>
    */
    pub async fn apps_list_subscriptions_for_authenticated_user(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::UserMarketplacePurchase>> {
        let url = format!(
            "/user/marketplace_purchases?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List subscriptions for the authenticated user (stubbed).
    *
    * This function performs a `GET` to the `/user/marketplace_purchases/stubbed` endpoint.
    *
    * Lists the active subscriptions for the authenticated user. You must use a [user-to-server OAuth access token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps must authenticate using an [OAuth token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/apps#list-subscriptions-for-the-authenticated-user-stubbed>
    */
    pub async fn apps_list_subscriptions_for_authenticated_user_stubbed(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::UserMarketplacePurchase>> {
        let url = format!(
            "/user/marketplace_purchases/stubbed?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List organization memberships for the authenticated user.
    *
    * This function performs a `GET` to the `/user/memberships/orgs` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#list-organization-memberships-for-the-authenticated-user>
    */
    pub async fn orgs_list_memberships_for_authenticated_user(
        &self,
        state: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::OrgMembership>> {
        let url = format!(
            "/user/memberships/orgs?page={}&per_page={}&state={}",
            format!("{}", page),
            format!("{}", per_page),
            state.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get an organization membership for the authenticated user.
    *
    * This function performs a `GET` to the `/user/memberships/orgs/{org}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#get-an-organization-membership-for-the-authenticated-user>
    */
    pub async fn orgs_get_membership_for_authenticated_user(
        &self,
        org: &str,
    ) -> Result<types::OrgMembership> {
        let url = format!(
            "/user/memberships/orgs/{}",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Update an organization membership for the authenticated user.
    *
    * This function performs a `PATCH` to the `/user/memberships/orgs/{org}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#update-an-organization-membership-for-the-authenticated-user>
    */
    pub async fn orgs_update_membership_for_authenticated_user(
        &self,
        org: &str,
        body: &types::UpdateOrganizationMembershipRequest,
    ) -> Result<types::OrgMembership> {
        let url = format!(
            "/user/memberships/orgs/{}",
            progenitor_support::encode_path(&org.to_string()),
        );

        self.patch(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List user migrations.
    *
    * This function performs a `GET` to the `/user/migrations` endpoint.
    *
    * Lists all migrations a user has started.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#list-user-migrations>
    */
    pub async fn migrations_list_for_authenticated_user(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Migration>> {
        let url = format!(
            "/user/migrations?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Start a user migration.
    *
    * This function performs a `POST` to the `/user/migrations` endpoint.
    *
    * Initiates the generation of a user migration archive.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#start-a-user-migration>
    */
    pub async fn migrations_start_for_authenticated_user(
        &self,
        body: &types::StartUserMigrationRequest,
    ) -> Result<types::Migration> {
        let url = "/user/migrations".to_string();
        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * Get a user migration status.
    *
    * This function performs a `GET` to the `/user/migrations/{migration_id}` endpoint.
    *
    * Fetches a single user migration. The response includes the `state` of the migration, which can be one of the following values:
    *
    * *   `pending` - the migration hasn't started yet.
    * *   `exporting` - the migration is in progress.
    * *   `exported` - the migration finished successfully.
    * *   `failed` - the migration failed.
    *
    * Once the migration has been `exported` you can [download the migration archive](https://docs.github.com/rest/reference/migrations#download-a-user-migration-archive).
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#get-a-user-migration-status>
    */
    pub async fn migrations_get_status_for_authenticated_user(
        &self,
        migration_id: i64,
        exclude: &[String],
    ) -> Result<types::Migration> {
        let url = format!(
            "/user/migrations/{}?exclude={}",
            progenitor_support::encode_path(&migration_id.to_string()),
            exclude.join(" "),
        );

        self.get(&url).await
    }

    /**
    * Download a user migration archive.
    *
    * This function performs a `GET` to the `/user/migrations/{migration_id}/archive` endpoint.
    *
    * Fetches the URL to download the migration archive as a `tar.gz` file. Depending on the resources your repository uses, the migration archive can contain JSON files with data for these objects:
    *
    * *   attachments
    * *   bases
    * *   commit\_comments
    * *   issue\_comments
    * *   issue\_events
    * *   issues
    * *   milestones
    * *   organizations
    * *   projects
    * *   protected\_branches
    * *   pull\_request\_reviews
    * *   pull\_requests
    * *   releases
    * *   repositories
    * *   review\_comments
    * *   schema
    * *   users
    *
    * The archive will also contain an `attachments` directory that includes all attachment files uploaded to GitHub.com and a `repositories` directory that contains the repository's Git data.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#download-a-user-migration-archive>
    */
    pub async fn migrations_get_archive_for_authenticated_user(
        &self,
        migration_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/user/migrations/{}/archive",
            progenitor_support::encode_path(&migration_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a user migration archive.
    *
    * This function performs a `DELETE` to the `/user/migrations/{migration_id}/archive` endpoint.
    *
    * Deletes a previous migration archive. Downloadable migration archives are automatically deleted after seven days. Migration metadata, which is returned in the [List user migrations](https://docs.github.com/rest/reference/migrations#list-user-migrations) and [Get a user migration status](https://docs.github.com/rest/reference/migrations#get-a-user-migration-status) endpoints, will continue to be available even after an archive is deleted.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#delete-a-user-migration-archive>
    */
    pub async fn migrations_delete_archive_for_authenticated_user(
        &self,
        migration_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/user/migrations/{}/archive",
            progenitor_support::encode_path(&migration_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Unlock a user repository.
    *
    * This function performs a `DELETE` to the `/user/migrations/{migration_id}/repos/{repo_name}/lock` endpoint.
    *
    * Unlocks a repository. You can lock repositories when you [start a user migration](https://docs.github.com/rest/reference/migrations#start-a-user-migration). Once the migration is complete you can unlock each repository to begin using it again or [delete the repository](https://docs.github.com/rest/reference/repos#delete-a-repository) if you no longer need the source data. Returns a status of `404 Not Found` if the repository is not locked.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#unlock-a-user-repository>
    */
    pub async fn migrations_unlock_repo_for_authenticated_user(
        &self,
        migration_id: i64,
        repo_name: &str,
    ) -> Result<()> {
        let url = format!(
            "/user/migrations/{}/repos/{}/lock",
            progenitor_support::encode_path(&migration_id.to_string()),
            progenitor_support::encode_path(&repo_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List repositories for a user migration.
    *
    * This function performs a `GET` to the `/user/migrations/{migration_id}/repositories` endpoint.
    *
    * Lists all the repositories for this user migration.
    *
    * FROM: <https://docs.github.com/rest/reference/migrations#list-repositories-for-a-user-migration>
    */
    pub async fn migrations_list_repos_for_user(
        &self,
        migration_id: i64,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/user/migrations/{}/repositories?page={}&per_page={}",
            progenitor_support::encode_path(&migration_id.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List organizations for the authenticated user.
    *
    * This function performs a `GET` to the `/user/orgs` endpoint.
    *
    * List organizations for the authenticated user.
    *
    * **OAuth scope requirements**
    *
    * This only lists organizations that your authorization allows you to operate on in some way (e.g., you can list teams with `read:org` scope, you can publicize your organization membership with `user` scope, etc.). Therefore, this API requires at least `user` or `read:org` scope. OAuth requests with insufficient scope receive a `403 Forbidden` response.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#list-organizations-for-the-authenticated-user>
    */
    pub async fn orgs_list_for_authenticated_user(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::OrganizationSimple>> {
        let url = format!(
            "/user/orgs?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a package for the authenticated user.
    *
    * This function performs a `GET` to the `/user/packages/{package_type}/{package_name}` endpoint.
    *
    * Gets a specific package for a package owned by the authenticated user.
    *
    * To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
    * If `package_type` is not `container`, your token must also include the `repo` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#get-a-package-for-the-authenticated-user>
    */
    pub async fn packages_get_package_for_authenticated_user(
        &self,
        package_type: &str,
        package_name: &str,
    ) -> Result<types::Package> {
        let url = format!(
            "/user/packages/{}/{}",
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a package for the authenticated user.
    *
    * This function performs a `DELETE` to the `/user/packages/{package_type}/{package_name}` endpoint.
    *
    * Deletes a package owned by the authenticated user. You cannot delete a public package if any version of the package has more than 5,000 downloads. In this scenario, contact GitHub support for further assistance.
    *
    * To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:delete` scope.
    * If `package_type` is not `container`, your token must also include the `repo` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#delete-a-package-for-the-authenticated-user>
    */
    pub async fn packages_delete_package_for_authenticated_user(
        &self,
        package_type: &str,
        package_name: &str,
    ) -> Result<()> {
        let url = format!(
            "/user/packages/{}/{}",
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Restore a package for the authenticated user.
    *
    * This function performs a `POST` to the `/user/packages/{package_type}/{package_name}/restore` endpoint.
    *
    * Restores a package owned by the authenticated user.
    *
    * You can restore a deleted package under the following conditions:
    *   - The package was deleted within the last 30 days.
    *   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.
    *
    * To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#restore-a-package-for-the-authenticated-user>
    */
    pub async fn packages_restore_package_for_authenticated_user(
        &self,
        package_type: &str,
        package_name: &str,
        token: &str,
    ) -> Result<()> {
        let url = format!(
            "/user/packages/{}/{}/restore?token={}",
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            token.to_string(),
        );

        self.post(&url, None).await
    }

    /**
    * Get all package versions for a package owned by the authenticated user.
    *
    * This function performs a `GET` to the `/user/packages/{package_type}/{package_name}/versions` endpoint.
    *
    * Returns all package versions for a package owned by the authenticated user.
    *
    * To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
    * If `package_type` is not `container`, your token must also include the `repo` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#get-all-package-versions-for-a-package-owned-by-the-authenticated-user>
    */
    pub async fn packages_get_all_package_versions_for_package_owned_by_authenticated_user(
        &self,
        package_type: &str,
        package_name: &str,
        page: i64,
        per_page: i64,
        state: &str,
    ) -> Result<Vec<types::PackageVersion>> {
        let url = format!(
            "/user/packages/{}/{}/versions?page={}&per_page={}&state={}",
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            state.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a package version for the authenticated user.
    *
    * This function performs a `GET` to the `/user/packages/{package_type}/{package_name}/versions/{package_version_id}` endpoint.
    *
    * Gets a specific package version for a package owned by the authenticated user.
    *
    * To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
    * If `package_type` is not `container`, your token must also include the `repo` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#get-a-package-version-for-the-authenticated-user>
    */
    pub async fn packages_get_package_version_for_authenticated_user(
        &self,
        package_type: &str,
        package_name: &str,
        package_version_id: i64,
    ) -> Result<types::PackageVersion> {
        let url = format!(
            "/user/packages/{}/{}/versions/{}",
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            progenitor_support::encode_path(&package_version_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Delete a package version for the authenticated user.
    *
    * This function performs a `DELETE` to the `/user/packages/{package_type}/{package_name}/versions/{package_version_id}` endpoint.
    *
    * Deletes a specific package version for a package owned by the authenticated user.  If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.
    *
    * To use this endpoint, you must have admin permissions in the organization and authenticate using an access token with the `packages:read` scope.
    * If `package_type` is not `container`, your token must also include the `repo` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#delete-a-package-version-for-the-authenticated-user>
    */
    pub async fn packages_delete_package_version_for_authenticated_user(
        &self,
        package_type: &str,
        package_name: &str,
        package_version_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/user/packages/{}/{}/versions/{}",
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            progenitor_support::encode_path(&package_version_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Restore a package version for the authenticated user.
    *
    * This function performs a `POST` to the `/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore` endpoint.
    *
    * Restores a package version owned by the authenticated user.
    *
    * You can restore a deleted package version under the following conditions:
    *   - The package was deleted within the last 30 days.
    *   - The same package namespace and version is still available and not reused for a new package. If the same package namespace is not available, you will not be able to restore your package. In this scenario, to restore the deleted package, you must delete the new package that uses the deleted package's namespace first.
    *
    * To use this endpoint, you must authenticate using an access token with the `packages:read` and `packages:write` scope. If `package_type` is not `container`, your token must also include the `repo` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#restore-a-package-version-for-the-authenticated-user>
    */
    pub async fn packages_restore_package_version_for_authenticated_user(
        &self,
        package_type: &str,
        package_name: &str,
        package_version_id: i64,
    ) -> Result<()> {
        let url = format!(
            "/user/packages/{}/{}/versions/{}/restore",
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            progenitor_support::encode_path(&package_version_id.to_string()),
        );

        self.post(&url, None).await
    }

    /**
    * Create a user project.
    *
    * This function performs a `POST` to the `/user/projects` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/projects#create-a-user-project>
    */
    pub async fn projects_create_for_authenticated_user(
        &self,
        body: &types::CreateUserProjectRequest,
    ) -> Result<types::Project> {
        let url = "/user/projects".to_string();
        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List public email addresses for the authenticated user.
    *
    * This function performs a `GET` to the `/user/public_emails` endpoint.
    *
    * Lists your publicly visible email address, which you can set with the [Set primary email visibility for the authenticated user](https://docs.github.com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user) endpoint. This endpoint is accessible with the `user:email` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/users#list-public-email-addresses-for-the-authenticated-user>
    */
    pub async fn users_list_public_emails_for_authenticated(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Email>> {
        let url = format!(
            "/user/public_emails?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List repositories for the authenticated user.
    *
    * This function performs a `GET` to the `/user/repos` endpoint.
    *
    * Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
    *
    * The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-repositories-for-the-authenticated-user>
    */
    pub async fn repos_list_for_authenticated_user(
        &self,
        visibility: &str,
        affiliation: &str,
        type_: &str,
        sort: &str,
        direction: &str,
        per_page: i64,
        page: i64,
        since: DateTime<Utc>,
        before: DateTime<Utc>,
    ) -> Result<Vec<types::Repository>> {
        let url = format!("/user/repos?affiliation={}&before={}&direction={}&page={}&per_page={}&since={}&sort={}&type={}&visibility={}",
affiliation.to_string(), before.to_rfc3339(), direction.to_string(), format!("{}", page), format!("{}", per_page), since.to_rfc3339(), sort.to_string(), type_, visibility.to_string(),         );

        self.get_all_pages(&url).await
    }

    /**
    * Create a repository for the authenticated user.
    *
    * This function performs a `POST` to the `/user/repos` endpoint.
    *
    * Creates a new repository for the authenticated user.
    *
    * **OAuth scope requirements**
    *
    * When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
    *
    * *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
    * *   `repo` scope to create a private repository.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#create-a-repository-for-the-authenticated-user>
    */
    pub async fn repos_create_for_authenticated_user(
        &self,
        body: &types::CreateRepositoryRequest,
    ) -> Result<types::Repository> {
        let url = "/user/repos".to_string();
        self.post(
            &url,
            Some(reqwest::Body::from(serde_json::to_vec(body).unwrap())),
        )
        .await
    }

    /**
    * List repository invitations for the authenticated user.
    *
    * This function performs a `GET` to the `/user/repository_invitations` endpoint.
    *
    * When authenticating as a user, this endpoint will list all currently open repository invitations for that user.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-repository-invitations-for-the-authenticated-user>
    */
    pub async fn repos_list_invitations_for_authenticated_user(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::RepositoryInvitation>> {
        let url = format!(
            "/user/repository_invitations?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Decline a repository invitation.
    *
    * This function performs a `DELETE` to the `/user/repository_invitations/{invitation_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#decline-a-repository-invitation>
    */
    pub async fn repos_decline_invitation(&self, invitation_id: i64) -> Result<()> {
        let url = format!(
            "/user/repository_invitations/{}",
            progenitor_support::encode_path(&invitation_id.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * Accept a repository invitation.
    *
    * This function performs a `PATCH` to the `/user/repository_invitations/{invitation_id}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/repos#accept-a-repository-invitation>
    */
    pub async fn repos_accept_invitation(&self, invitation_id: i64) -> Result<()> {
        let url = format!(
            "/user/repository_invitations/{}",
            progenitor_support::encode_path(&invitation_id.to_string()),
        );

        self.patch(&url, None).await
    }

    /**
    * List repositories starred by the authenticated user.
    *
    * This function performs a `GET` to the `/user/starred` endpoint.
    *
    * Lists repositories the authenticated user has starred.
    *
    * You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-repositories-starred-by-the-authenticated-user>
    */
    pub async fn activity_list_repos_starred_by_authenticated_user(
        &self,
        sort: &str,
        direction: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Repository>> {
        let url = format!(
            "/user/starred?direction={}&page={}&per_page={}&sort={}",
            direction.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            sort.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Check if a repository is starred by the authenticated user.
    *
    * This function performs a `GET` to the `/user/starred/{owner}/{repo}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/activity#check-if-a-repository-is-starred-by-the-authenticated-user>
    */
    pub async fn activity_check_repo_is_starred_by_authenticated_user(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<()> {
        let url = format!(
            "/user/starred/{}/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Star a repository for the authenticated user.
    *
    * This function performs a `PUT` to the `/user/starred/{owner}/{repo}` endpoint.
    *
    * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
    *
    * FROM: <https://docs.github.com/rest/reference/activity#star-a-repository-for-the-authenticated-user>
    */
    pub async fn activity_star_repo_for_authenticated_user(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<()> {
        let url = format!(
            "/user/starred/{}/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.put(&url, None).await
    }

    /**
    * Unstar a repository for the authenticated user.
    *
    * This function performs a `DELETE` to the `/user/starred/{owner}/{repo}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/activity#unstar-a-repository-for-the-authenticated-user>
    */
    pub async fn activity_unstar_repo_for_authenticated_user(
        &self,
        owner: &str,
        repo: &str,
    ) -> Result<()> {
        let url = format!(
            "/user/starred/{}/{}",
            progenitor_support::encode_path(&owner.to_string()),
            progenitor_support::encode_path(&repo.to_string()),
        );

        self.delete(&url, None).await
    }

    /**
    * List repositories watched by the authenticated user.
    *
    * This function performs a `GET` to the `/user/subscriptions` endpoint.
    *
    * Lists repositories the authenticated user is watching.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-repositories-watched-by-the-authenticated-user>
    */
    pub async fn activity_list_watched_repos_for_authenticated_user(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/user/subscriptions?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List teams for the authenticated user.
    *
    * This function performs a `GET` to the `/user/teams` endpoint.
    *
    * List all of the teams across all of the organizations to which the authenticated user belongs. This method requires `user`, `repo`, or `read:org` [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/) when authenticating via [OAuth](https://docs.github.com/apps/building-oauth-apps/).
    *
    * FROM: <https://docs.github.com/rest/reference/teams#list-teams-for-the-authenticated-user>
    */
    pub async fn teams_list_for_authenticated_user(
        &self,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::TeamFull>> {
        let url = format!(
            "/user/teams?page={}&per_page={}",
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List users.
    *
    * This function performs a `GET` to the `/users` endpoint.
    *
    * Lists all users, in the order that they signed up on GitHub. This list includes personal user accounts and organization accounts.
    *
    * Note: Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of users.
    *
    * FROM: <https://docs.github.com/rest/reference/users#list-users>
    */
    pub async fn users_list(&self, since: i64, per_page: i64) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/users?per_page={}&since={}",
            format!("{}", per_page),
            format!("{}", since),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a user.
    *
    * This function performs a `GET` to the `/users/{username}` endpoint.
    *
    * Provides publicly available information about someone with a GitHub account.
    *
    * GitHub Apps with the `Plan` user permission can use this endpoint to retrieve information about a user's GitHub plan. The GitHub App must be authenticated as a user. See "[Identifying and authorizing users for GitHub Apps](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/)" for details about authentication. For an example response, see 'Response with GitHub plan information' below"
    *
    * The `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be “public” which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/overview/resources-in-the-rest-api#authentication).
    *
    * The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see "[Emails API](https://docs.github.com/rest/reference/users#emails)".
    *
    * FROM: <https://docs.github.com/rest/reference/users#get-a-user>
    */
    pub async fn users_get_by_username(&self, username: &str) -> Result<types::GetUserOkResponse> {
        let url = format!(
            "/users/{}",
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List events for the authenticated user.
    *
    * This function performs a `GET` to the `/users/{username}/events` endpoint.
    *
    * If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-events-for-the-authenticated-user>
    */
    pub async fn activity_list_events_for_authenticated_user(
        &self,
        username: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Event>> {
        let url = format!(
            "/users/{}/events?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List organization events for the authenticated user.
    *
    * This function performs a `GET` to the `/users/{username}/events/orgs/{org}` endpoint.
    *
    * This is the user's organization dashboard. You must be authenticated as the user to view this.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-organization-events-for-the-authenticated-user>
    */
    pub async fn activity_list_org_events_for_authenticated_user(
        &self,
        username: &str,
        org: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Event>> {
        let url = format!(
            "/users/{}/events/orgs/{}?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            progenitor_support::encode_path(&org.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List public events for a user.
    *
    * This function performs a `GET` to the `/users/{username}/events/public` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-public-events-for-a-user>
    */
    pub async fn activity_list_public_events_for_user(
        &self,
        username: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Event>> {
        let url = format!(
            "/users/{}/events/public?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List followers of a user.
    *
    * This function performs a `GET` to the `/users/{username}/followers` endpoint.
    *
    * Lists the people following the specified user.
    *
    * FROM: <https://docs.github.com/rest/reference/users#list-followers-of-a-user>
    */
    pub async fn users_list_followers_for_user(
        &self,
        username: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/users/{}/followers?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List the people a user follows.
    *
    * This function performs a `GET` to the `/users/{username}/following` endpoint.
    *
    * Lists the people who the specified user follows.
    *
    * FROM: <https://docs.github.com/rest/reference/users#list-the-people-a-user-follows>
    */
    pub async fn users_list_following_for_user(
        &self,
        username: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::SimpleUser>> {
        let url = format!(
            "/users/{}/following?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Check if a user follows another user.
    *
    * This function performs a `GET` to the `/users/{username}/following/{target_user}` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/users#check-if-a-user-follows-another-user>
    */
    pub async fn users_check_following_for_user(
        &self,
        username: &str,
        target_user: &str,
    ) -> Result<()> {
        let url = format!(
            "/users/{}/following/{}",
            progenitor_support::encode_path(&username.to_string()),
            progenitor_support::encode_path(&target_user.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List gists for a user.
    *
    * This function performs a `GET` to the `/users/{username}/gists` endpoint.
    *
    * Lists public gists for the specified user:
    *
    * FROM: <https://docs.github.com/rest/reference/gists#list-gists-for-a-user>
    */
    pub async fn gists_list_for_user(
        &self,
        username: &str,
        since: DateTime<Utc>,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::BaseGist>> {
        let url = format!(
            "/users/{}/gists?page={}&per_page={}&since={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            since.to_rfc3339(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List GPG keys for a user.
    *
    * This function performs a `GET` to the `/users/{username}/gpg_keys` endpoint.
    *
    * Lists the GPG keys for a user. This information is accessible by anyone.
    *
    * FROM: <https://docs.github.com/rest/reference/users#list-gpg-keys-for-a-user>
    */
    pub async fn users_list_gpg_keys_for_user(
        &self,
        username: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::GpgKey>> {
        let url = format!(
            "/users/{}/gpg_keys?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get contextual information for a user.
    *
    * This function performs a `GET` to the `/users/{username}/hovercard` endpoint.
    *
    * Provides hovercard information when authenticated through basic auth or OAuth with the `repo` scope. You can find out more about someone in relation to their pull requests, issues, repositories, and organizations.
    *
    * The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which returns more information than without the parameters. For example, if you wanted to find out more about `octocat` who owns the `Spoon-Knife` repository via cURL, it would look like this:
    *
    * ```shell
    *  curl -u username:token
    *   https://api.github.com/users/octocat/hovercard?subject_type=repository&subject_id=1300192
    * ```
    *
    * FROM: <https://docs.github.com/rest/reference/users#get-contextual-information-for-a-user>
    */
    pub async fn users_get_context_for_user(
        &self,
        username: &str,
        subject_type: &str,
        subject_id: &str,
    ) -> Result<types::Hovercard> {
        let url = format!(
            "/users/{}/hovercard?subject_id={}&subject_type={}",
            progenitor_support::encode_path(&username.to_string()),
            subject_id.to_string(),
            subject_type.to_string(),
        );

        self.get(&url).await
    }

    /**
    * Get a user installation for the authenticated app.
    *
    * This function performs a `GET` to the `/users/{username}/installation` endpoint.
    *
    * Enables an authenticated GitHub App to find the user’s installation information.
    *
    * You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
    *
    * FROM: <https://docs.github.com/rest/reference/apps#get-a-user-installation-for-the-authenticated-app>
    */
    pub async fn apps_get_user_installation(&self, username: &str) -> Result<types::Installation> {
        let url = format!(
            "/users/{}/installation",
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List public keys for a user.
    *
    * This function performs a `GET` to the `/users/{username}/keys` endpoint.
    *
    * Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
    *
    * FROM: <https://docs.github.com/rest/reference/users#list-public-keys-for-a-user>
    */
    pub async fn users_list_public_keys_for_user(
        &self,
        username: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::KeySimple>> {
        let url = format!(
            "/users/{}/keys?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List organizations for a user.
    *
    * This function performs a `GET` to the `/users/{username}/orgs` endpoint.
    *
    * List [public organization memberships](https://help.github.com/articles/publicizing-or-concealing-organization-membership) for the specified user.
    *
    * This method only lists _public_ memberships, regardless of authentication. If you need to fetch all of the organization memberships (public and private) for the authenticated user, use the [List organizations for the authenticated user](https://docs.github.com/rest/reference/orgs#list-organizations-for-the-authenticated-user) API instead.
    *
    * FROM: <https://docs.github.com/rest/reference/orgs#list-organizations-for-a-user>
    */
    pub async fn orgs_list_for_user(
        &self,
        username: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::OrganizationSimple>> {
        let url = format!(
            "/users/{}/orgs?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a package for a user.
    *
    * This function performs a `GET` to the `/users/{username}/packages/{package_type}/{package_name}` endpoint.
    *
    * Gets a specific package metadata for a public package owned by a user.
    *
    * To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
    * If `package_type` is not `container`, your token must also include the `repo` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#get-a-package-for-a-user>
    */
    pub async fn packages_get_package_for_user(
        &self,
        package_type: &str,
        package_name: &str,
        username: &str,
    ) -> Result<types::Package> {
        let url = format!(
            "/users/{}/packages/{}/{}",
            progenitor_support::encode_path(&username.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get all package versions for a package owned by a user.
    *
    * This function performs a `GET` to the `/users/{username}/packages/{package_type}/{package_name}/versions` endpoint.
    *
    * Returns all package versions for a public package owned by a specified user.
    *
    * To use this endpoint, you must authenticate using an access token with the `packages:read` scope.
    * If `package_type` is not `container`, your token must also include the `repo` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#get-all-package-versions-for-a-package-owned-by-a-user>
    */
    pub async fn packages_get_all_package_versions_for_package_owned_by_user(
        &self,
        package_type: &str,
        package_name: &str,
        username: &str,
    ) -> Result<Vec<types::PackageVersion>> {
        let url = format!(
            "/users/{}/packages/{}/{}/versions",
            progenitor_support::encode_path(&username.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get a package version for a user.
    *
    * This function performs a `GET` to the `/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}` endpoint.
    *
    * Gets a specific package version for a public package owned by a specified user.
    *
    * At this time, to use this endpoint, you must authenticate using an access token with the `packages:read` scope.
    * If `package_type` is not `container`, your token must also include the `repo` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/packages#get-a-package-version-for-a-user>
    */
    pub async fn packages_get_package_version_for_user(
        &self,
        package_type: &str,
        package_name: &str,
        package_version_id: i64,
        username: &str,
    ) -> Result<types::PackageVersion> {
        let url = format!(
            "/users/{}/packages/{}/{}/versions/{}",
            progenitor_support::encode_path(&username.to_string()),
            progenitor_support::encode_path(&package_type.to_string()),
            progenitor_support::encode_path(&package_name.to_string()),
            progenitor_support::encode_path(&package_version_id.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List user projects.
    *
    * This function performs a `GET` to the `/users/{username}/projects` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/projects#list-user-projects>
    */
    pub async fn projects_list_for_user(
        &self,
        username: &str,
        state: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Project>> {
        let url = format!(
            "/users/{}/projects?page={}&per_page={}&state={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
            state.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List events received by the authenticated user.
    *
    * This function performs a `GET` to the `/users/{username}/received_events` endpoint.
    *
    * These are events that you've received by watching repos and following users. If you are authenticated as the given user, you will see private events. Otherwise, you'll only see public events.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-events-received-by-the-authenticated-user>
    */
    pub async fn activity_list_received_events_for_user(
        &self,
        username: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Event>> {
        let url = format!(
            "/users/{}/received_events?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List public events received by a user.
    *
    * This function performs a `GET` to the `/users/{username}/received_events/public` endpoint.
    *
    *
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-public-events-received-by-a-user>
    */
    pub async fn activity_list_received_public_events_for_user(
        &self,
        username: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::Event>> {
        let url = format!(
            "/users/{}/received_events/public?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List repositories for a user.
    *
    * This function performs a `GET` to the `/users/{username}/repos` endpoint.
    *
    * Lists public repositories for the specified user. Note: For GitHub AE, this endpoint will list internal repositories for the specified user.
    *
    * FROM: <https://docs.github.com/rest/reference/repos#list-repositories-for-a-user>
    */
    pub async fn repos_list_for_user(
        &self,
        username: &str,
        type_: &str,
        sort: &str,
        direction: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/users/{}/repos?direction={}&page={}&per_page={}&sort={}&type={}",
            progenitor_support::encode_path(&username.to_string()),
            direction.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            sort.to_string(),
            type_,
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get GitHub Actions billing for a user.
    *
    * This function performs a `GET` to the `/users/{username}/settings/billing/actions` endpoint.
    *
    * Gets the summary of the free and paid GitHub Actions minutes used.
    *
    * Paid minutes only apply to workflows in private repositories that use GitHub-hosted runners. Minutes used is listed for each GitHub-hosted runner operating system. Any job re-runs are also included in the usage. The usage returned includes any minute multipliers for macOS and Windows runners, and is rounded up to the nearest whole minute. For more information, see "[Managing billing for GitHub Actions](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
    *
    * Access tokens must have the `user` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/billing#get-github-actions-billing-for-a-user>
    */
    pub async fn billing_get_github_actions_billing_user(
        &self,
        username: &str,
    ) -> Result<types::ActionsBillingUsage> {
        let url = format!(
            "/users/{}/settings/billing/actions",
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get GitHub Packages billing for a user.
    *
    * This function performs a `GET` to the `/users/{username}/settings/billing/packages` endpoint.
    *
    * Gets the free and paid storage used for GitHub Packages in gigabytes.
    *
    * Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
    *
    * Access tokens must have the `user` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/billing#get-github-packages-billing-for-a-user>
    */
    pub async fn billing_get_github_packages_billing_user(
        &self,
        username: &str,
    ) -> Result<types::PackagesBillingUsage> {
        let url = format!(
            "/users/{}/settings/billing/packages",
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * Get shared storage billing for a user.
    *
    * This function performs a `GET` to the `/users/{username}/settings/billing/shared-storage` endpoint.
    *
    * Gets the estimated paid and estimated total storage used for GitHub Actions and Github Packages.
    *
    * Paid minutes only apply to packages stored for private repositories. For more information, see "[Managing billing for GitHub Packages](https://help.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-packages)."
    *
    * Access tokens must have the `user` scope.
    *
    * FROM: <https://docs.github.com/rest/reference/billing#get-shared-storage-billing-for-a-user>
    */
    pub async fn billing_get_shared_storage_billing_user(
        &self,
        username: &str,
    ) -> Result<types::CombinedBillingUsage> {
        let url = format!(
            "/users/{}/settings/billing/shared-storage",
            progenitor_support::encode_path(&username.to_string()),
        );

        self.get(&url).await
    }

    /**
    * List repositories starred by a user.
    *
    * This function performs a `GET` to the `/users/{username}/starred` endpoint.
    *
    * Lists repositories a user has starred.
    *
    * You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-repositories-starred-by-a-user>
    */
    pub async fn activity_list_repos_starred_by_user(
        &self,
        username: &str,
        sort: &str,
        direction: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::StarredRepository>> {
        let url = format!(
            "/users/{}/starred?direction={}&page={}&per_page={}&sort={}",
            progenitor_support::encode_path(&username.to_string()),
            direction.to_string(),
            format!("{}", page),
            format!("{}", per_page),
            sort.to_string(),
        );

        self.get_all_pages(&url).await
    }

    /**
    * List repositories watched by a user.
    *
    * This function performs a `GET` to the `/users/{username}/subscriptions` endpoint.
    *
    * Lists repositories a user is watching.
    *
    * FROM: <https://docs.github.com/rest/reference/activity#list-repositories-watched-by-a-user>
    */
    pub async fn activity_list_repos_watched_by_user(
        &self,
        username: &str,
        per_page: i64,
        page: i64,
    ) -> Result<Vec<types::MinimalRepository>> {
        let url = format!(
            "/users/{}/subscriptions?page={}&per_page={}",
            progenitor_support::encode_path(&username.to_string()),
            format!("{}", page),
            format!("{}", per_page),
        );

        self.get_all_pages(&url).await
    }

    /**
    * Get the Zen of GitHub.
    *
    * This function performs a `GET` to the `/zen` endpoint.
    *
    * Get a random sentence from the Zen of GitHub
    */
    pub async fn meta_get_zen(&self) -> Result<String> {
        let url = "/zen".to_string();
        self.get(&url).await
    }
}
